<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Embree: High Performance Ray Tracing Kernels" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <title>Embree</title>
    <link rel="icon" type="image/png" href="images/icon192.png" sizes="192x192">
    <link rel="SHORTCUT ICON" HREF="images/icon32.ico">
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
div.sourceCode { overflow-x: initial; }
    </style>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <div class="inner">
        <a id="forkme_banner" href="https://github.com/embree">View on GitHub</a>
        <h1 id="project_title">Embree</h1>
        <h2 id="project_tagline">High Performance Ray Tracing Kernels</h2>
      </div>

      <div id="nav">
      <div id="nbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
          <li><a href="downloads.html">Downloads</a></li>
          <li id="selected"><a href="api.html">API</a></li>
          <li><a href="tutorials.html">Tutorials</a></li>
          <li><a href="gallery.html">Gallery</a></li>
          <li><a href="related.html">Related Projects</a></li>
        </ul>
      </div>
      </div>

    </div>

    <a id="news_banner" href="https://github.com/embree/embree/releases">
      We recently released Embree v3.0.0!
    </a>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <div id="main_content" class="inner">
<h1 id="embree-api">Embree API</h1>
<p>The Embree API is a low-level C99 ray tracing API which can be used to construct 3D scenes and perform ray queries of different types inside these scenes. All API calls carry the prefix <code>rtc</code> (or <code>RTC</code> for types) which stands for <strong>r</strong>ay <strong>t</strong>racing <strong>c</strong>ore.</p>
<p>The API also exists in an ISPC version, which is almost identical but contains additional functions that operate on ray packets with a size of the native SIMD width used by ISPC. For simplicity this document refers to the C99 version of the API functions. For changes when upgrading from the Embree 2 to the current Embree 3 API see Section <a href="#upgrading-from-embree-2-to-embree-3">Upgrading from Embree 2 to Embree 3</a>.</p>
<p>The API supports scenes consisting of different geometry types such as triangle meshes, quad meshes (triangle pairs), curves, subdivision meshes, instanced geometries, and user-defined geometries. See Section <a href="#scene-object">Scene Object</a> for more information.</p>
<p>Finding the closest hit of a ray segment with the scene (<code>rtcIntersect</code>-type functions), and determining whether any hit between a ray segment and the scene exists (<code>rtcOccluded</code>-type functions) are both supported. The API supports queries for single rays, ray packets, and ray streams. See Section <a href="#ray-queries">Ray Queries</a> for more information.</p>
<p>The API is designed in an object-oriented manner, e.g. it contains device objects (<code>RTCDevice</code> type), scene objects (<code>RTCScene</code> type), geometry objects (<code>RTCGeometry</code> type), buffer objects (<code>RTCBuffer</code> type), and BVH objects (<code>RTCBVH</code> type). All objects are reference counted, and handles can be released by calling the appropriate release function (e.g. <code>rtcReleaseDevice</code>) or retained by incrementing the reference count (e.g. <code>rtcRetainDevice</code>). In general, API calls that access the same object are not thread-safe, unless specified differently. However, attaching geometries to the same scene and performing ray queries in a scene is thread-safe.</p>
<h2 id="device-object">Device Object</h2>
<p>Embree supports a device concept, which allows different components of the application to use the Embree API without interfering with each other. An application typically first creates a device using the <a href="#rtcnewdevice">rtcNewDevice</a> function. This device can then be used to construct further objects, such as scenes and geometries. Before the application exits, it should release all devices by invoking <a href="#rtcreleasedevice">rtcReleaseDevice</a>. An application typically creates only a single device. If required differently, it should only use a small number of devices at any given time.</p>
<p>Each user thread has its own error flag per device. If an error occurs when invoking an API function, this flag is set to an error code (if it isn’t already set by a previous error). See Section <a href="#rtcgetdeviceerror">rtcGetDeviceError</a> for information on how to read the error code and Section <a href="#rtcsetdeviceerrorfunction">rtcSetDeviceErrorFunction</a> on how to register a callback that is invoked for each error encountered. It is recommended to always set a error callback function, to detect all errors.</p>
<h2 id="scene-object">Scene Object</h2>
<p>A scene is a container for a set of geometries, and contains a spatial acceleration structure which can be used to perform different types of ray queries.</p>
<p>A scene is created using the <code>rtcNewScene</code> function call, and released using the <code>rtcReleaseScene</code> function call. To populate a scene with geometries use the <code>rtcAttachGeometry</code> call, and to detach them use the <code>rtcDetachGeometry</code> call. Once all scene geometries are attached, an <code>rtcCommitScene</code> call (or <code>rtcJoinCommitScene</code> call) will finish the scene description and trigger building of internal data structures. After the scene got committed, it is safe to perform ray queries (see Section <a href="#ray-queries">Ray Queries</a>) or to query the scene bounding box (see <a href="#rtcgetscenebounds">rtcGetSceneBounds</a> and <a href="#rtcgetscenelinearbounds">rtcGetSceneLinearBounds</a>).</p>
<p>If scene geometries get modified or attached or detached, the <code>rtcCommitScene</code> call must be invoked before performing any further ray queries for the scene; otherwise the effect of the ray query is undefined. The modification of a geometry, committing the scene, and tracing of rays must always happen sequentially, and never at the same time.</p>
<p>Scene flags can be used to configure a scene to use less memory (<code>RTC_SCENE_FLAG_COMPACT</code>), use more robust traversal algorithms (<code>RTC_SCENE_FLAG_ROBUST</code>), and to optimize for dynamic content. See Section <a href="#rtcsetsceneflags">rtcSetSceneFlags</a> for more details.</p>
<p>A build quality can be specified for a scene to balance between acceleration structure build performance and ray query performance. See Section <a href="#rtcsetscenebuildquality">rtcSetSceneBuildQuality</a> for more details on build quality.</p>
<h2 id="geometry-object">Geometry Object</h2>
<p>A new geometry is created using the <code>rtcNewGeometry</code> function. Depending on the geometry type, different buffers must be bound (e.g. using <code>rtcSetSharedGeometryBuffer</code>) to set up the geometry data. In most cases, binding of a vertex and index buffer is required. The number of primitives and vertices of that geometry is typically inferred from the size of these bound buffers.</p>
<p>Changes to the geometry always must be committed using the <code>rtcCommitGeometry</code> call before using the geometry. After committing, a geometry is not included in any scene. A geometry can be added to a scene by using the <code>rtcAttachGeometry</code> function (to automatically assign a geometry ID) or using the <code>rtcAttachGeometryById</code> function (to specify the geometry ID manually). A geometry can only be attached to a single scene at a time.</p>
<p>All geometry types support multi-segment motion blur with an arbitrary number of equidistant time steps (in the range of 2 to 129). Each geometry can have a different number of time steps. The motion blur geometry is defined by linearly interpolating the geometries of neighboring time steps. To construct a motion blur geometry, first the number of time steps of the geometry must be specified using the <code>rtcSetGeometryTimeStepCount</code> function, and then a vertex buffer for each time step must be bound, e.g. using the <code>rtcSetSharedGeometryBuffer</code> function.</p>
<p>The API supports per-geometry filter callback functions (see <code>rtcSetGeometryIntersectFilterFunction</code> and <code>rtcSetGeometryOccludedFilterFunction</code>) that are invoked for each intersection found during the <code>rtcIntersect</code>-type or <code>rtcOccluded</code>-type calls. The former ones are called geometry intersection filter functions, the latter ones geometry occlusion filter functions. These filter functions are designed to be used to ignore intersections outside of a user-defined silhouette of a primitive, e.g. to model tree leaves using transparency textures.</p>
<h2 id="ray-queries">Ray Queries</h2>
<p>The API supports finding the closest hit of a ray segment with the scene (<code>rtcIntersect</code>-type functions), and determining whether any hit between a ray segment and the scene exists (<code>rtcOccluded</code>-type functions).</p>
<p>Supported are single ray queries (<code>rtcIntersect1</code> and <code>rtcOccluded1</code>) as well as ray packet queries for ray packets of size 4 (<code>rtcIntersect4</code> and <code>rtcOccluded4</code>), ray packets of size 8 (<code>rtcIntersect8</code> and <code>rtcOccluded8</code>), and ray packets of size 16 (<code>rtcIntersect16</code> and <code>rtcOccluded16</code>).</p>
<p>Ray streams in a variety of layouts are supported as well, such as streams of single rays (<code>rtcIntersect1M</code> and <code>rtcOccluded1M</code>), streams of pointers to single rays (<code>rtcIntersect1p</code> and <code>rtcOccluded1p</code>), streams of ray packets (<code>rtcIntersectNM</code> and <code>rtcOccludedNM</code>), and large packet-like streams in structure of pointer layout (<code>rtcIntersectNp</code> and <code>rtcOccludedNp</code>).</p>
<p>See Sections <a href="#rtcintersect1">rtcIntersect1</a> and <a href="#rtcoccluded1">rtcOccluded1</a> for a detailed description of how to set up and trace a ray.</p>
<p>See tutorial <a href="tutorials.html#triangle-geometry">Triangle Geometry</a> for a complete example of how to trace single rays and ray packets. Also have a look at the tutorial <a href="tutorials.html#stream-viewer">Stream Viewer</a> for an example of how to trace ray streams.</p>
<h2 id="miscellaneous">Miscellaneous</h2>
<p>A context filter function, which can be set per ray query is supported (see <code>rtcInitIntersectContext</code>). This filter function is designed to change the semantics of the ray query, e.g. to accumulate opacity for transparent shadows, count the number of surfaces along a ray, collect all hits along a ray, etc.</p>
<p>The internal algorithms to build a BVH are exposed through the <code>RTCBVH</code> object and <code>rtcBuildBVH</code> call. This call makes it possible to build a BVH in a user-specified format over user-specified primitives. See the documentation of the <code>rtcBuildBVH</code> call for more details.</p>
<p>For getting the most performance out of Embree, see the Section <a href="#performance-recommendations">Performance Recommendations</a>.</p>
<p></p>
<h1 id="upgrading-from-embree-2-to-embree-3">Upgrading from Embree 2 to Embree 3</h1>
<p>We decided to introduce an improved API in Embree 3 that is not backward compatible with the Embree 2 API. This step was required to remove various deprecated API functions that accumulated over time, improve extensibility of the API, fix suboptimal design decisions, fix design mistakes (such as incompatible single ray and ray packet layouts), clean up inconsistent naming, and increase flexibility.</p>
<p>To make porting to the new API easy, we provide a conversion script that can do most of the work, and will annotate the code with remaining changes required. The script can be invoked the following way for CPP files:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">./scripts/cpp-patch.py --patch embree2_to_embree3.patch
  --in infile.cpp --out outfile.cpp</code></pre>
<p>When invoked for ISPC files, add the <code>--ispc</code> option:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">./scripts/cpp-patch.py --ispc --patch embree2_to_embree3.patch
  --in infile.ispc --out outfile.ispc</code></pre>
<p>Apply the script to each source file of your project that contains Embree API calls or types. The input file and output file can also be identical to perform the patch in-place. Please always backup your original code before running the script, and inspect the code changes done by the script using diff (e.g. <code>git diff</code>), to make sure no undesired code locations got changed. Grep the code for comments containing <code>EMBREE_FIXME</code> and perform the action described in the comment.</p>
<p>The following changes need to be performed when switching from Embree 2 to Embree 3. Most of these changes are automatically done by the script if not described differently.</p>
<p>We strongly recommend to set an error callback function (see <code>rtcSetDeviceErrorFunction</code>) when porting to Embree 3 to detect all runtime errors early.</p>
<h2 id="device">Device</h2>
<ul>
<li><p><code>rtcInit</code> and <code>rtcExit</code> got removed. Please use the device concept using the <code>rtcNewDevice</code> and <code>rtcReleaseDevice</code> functions instead.</p></li>
<li><p>Functions that conceptually should operate on a device but did not get a device argument got removed. The upgrade script replaces these functions by the proper functions that operate on a device, however, manually propagating the device handle to these function calls might still be required.</p></li>
</ul>
<h2 id="scene">Scene</h2>
<ul>
<li><p>The API no longer distinguishes between a static and a dynamic scene. Some users had issues as they wanted to do minor modifications to static scenes, but maintain high traversal performance.</p>
<p>The new approach gives more flexibility, as each scene is changeable, and build quality settings can be changed on a commit basis to balance between build performance and render performance.</p></li>
<li><p>The <code>rtcCommitThread</code> function got removed; use <code>rtcJoinCommitScene</code> instead.</p></li>
<li><p>The scene now supports different build quality settings. Please use those instead of the previous way of <code>RTC_SCENE_STATIC</code>, <code>RTC_SCENE_DYNAMIC</code>, and <code>RTC_SCENE_HIGH_QUALITY</code> flags.</p></li>
</ul>
<h2 id="geometry">Geometry</h2>
<ul>
<li><p>There is now only one <code>rtcNewGeometry</code> function to create geometries which gets passed an enum to specify the type of geometry to create. The number of vertices and primitives of the geometries is inferred from the size of data buffers.</p></li>
<li><p>We introduced an object type <code>RTCGeometry</code> for all geometries. Previously a geometry was not a standalone object and could only exist inside a scene. The new approach comes with more flexibility and more readable code.</p>
<p>Operations like <code>rtcInterpolate</code> can now be performed on the geometry object directly without the need of a scene. Further, an application can choose to create its geometries independent of a scene, e.g. each time a geometry node is added to its scene graph.</p>
<p>This modification changed many API functions to get passed one <code>RTCGeometry</code> object instead of a <code>RTCScene</code> and <code>geomID</code>. The script does all required changed automatically. However, in some cases the script may introduce <code>rtcGetGeometry(scene, geomID)</code> calls to retrieve the geometry handle. Best store the geometry handle inside your scene representation (and release it in the destructor) and access the handle directly instead of calling <code>rtcGetGeometry</code>.</p></li>
<li><p>Geometries are not included inside a scene anymore but can be attached to a single scene using the <code>rtcAttachGeomety</code> or <code>rtcAttachGeometryByID</code> functions.</p></li>
<li><p>As geometries are separate objects, commit semantics got introduced for them too. Thus geometries must be committed through the <code>rtcCommitGeometry</code> call before getting used. This allows for earlier error checking and pre-calculating internal data per geometry object.</p>
<p>Such commit points were previously not required in the Embree 2 API. The upgrade script attempts to insert the commits automatically, but cannot do so properly under all circumstances. Thus please check if every <code>rtcCommitGeometry</code> call inserted by the script is properly placed, and if a <code>rtcCommitGeometry</code> call is placed after a sequence of changes to a geometry.</p></li>
<li><p>Only the latest version of the previous displacement function call (<code>RTCDisplacementFunc2</code>) is now supported, and the callback is passed as a structure containing all arguments.</p></li>
<li><p>The deprecated <code>RTCBoundaryMode</code> type and <code>rtcSetBoundaryMode</code> function got removed and replaced by <code>RTCSubdivisionMode</code> enum and the <code>rtcSetGeometrySubdivisionMode</code> function. The script does this replacement automatically.</p></li>
<li><p>Ribbon curves and lines now avoid self-intersections automatically The application can be simplified by removing special code paths that previously did the self-intersection handling.</p></li>
<li><p>The previous Embree 2 way of instancing was suboptimal as it required user geometries to update the <code>instID</code> field of the ray differently when used inside an instanced scene or inside a top-level scene. The user geometry intersection code now just has to copy the <code>context.instID</code> field into the <code>ray.instID</code> field to function properly under all circumstances.</p></li>
<li><p>The internal instancing code will update the <code>context.instID</code> field properly when entering or leaving an instance. When instancing is implemented manually through user geometries, the code must be modified to set the <code>context.instID</code> field properly and no longer pass <code>instID</code> through the ray. This change must done manually and cannot be performed by the script.</p></li>
<li><p>We flipped the direction of the geometry normal to the widely used convention that a shape with counter-clockwise layout of vertices has the normal pointing upwards (right-hand rule). Most modeling tools follow that convention.</p>
<p>The conversion script does not perform this change, thus if required adjust your code to flip <code>Ng</code> for triangle, quad, and subdivision surfaces.</p></li>
</ul>
<h2 id="buffers">Buffers</h2>
<ul>
<li><p>With Embree 3 we are introducing explicit <code>RTCBuffer</code> objects. However, you can still use the short way of sharing buffers with Embree through the <code>rtcSetSharedGeometryBuffer</code> call.</p></li>
<li><p>The <code>rtcMapBuffer</code> and <code>rtcUnmapBuffer</code> API calls were removed, and we added the <code>rtcGetBufferData</code> call instead.</p>
<p>Previously the <code>rtcMapBuffer</code> call had the semantics of creating an internal buffer when no buffer was shared for the corresponding buffer slot. These invocations of <code>rtcMapBuffer</code> must be replaced by an explicit creation of an internally managed buffer using the <code>rtcNewGeometryBuffer</code> function.</p>
<p>The upgrade script cannot always detect if the <code>rtcMapBuffer</code> call would create an internal buffer or just map the buffer pointer. Thus check whether the <code>rtcNewGeometryBuffer</code> and <code>rtcGetBufferData</code> calls are correct after the conversion.</p></li>
<li><p>The <code>rtcUpdateGeometryBuffer</code> function now must be called for every buffer that got modified by the application. Note that the conversion script cannot automatically detect each location where a buffer update is now required.</p></li>
<li><p>The buffer type no longer encodes the time step or user vertex buffer index. Now <code>RTC_VERTEX_BUFFER_TYPE</code> and additional <code>slot</code> specifies the vertex buffer for a specific time step, and <code>RTC_USER_VERTEX_BUFFER_TYPE</code> and additional <code>slot</code> specifies a vertex attribute.</p></li>
</ul>
<h2 id="miscellaneous-1">Miscellaneous</h2>
<ul>
<li><p>The header files for Embree 3 are now inside the <code>embree3</code> folder (instead of <code>embree2</code> folder) and <code>libembree.so</code> is now called <code>libembree3.so</code> to be able to install multiple Embree versions side by side. We made the headers C99 compliant.</p></li>
<li><p>All API objects are now reference counted with release functions to decrement and retain functions to increment the reference count (if required).</p></li>
<li><p>Most callback functions no longer get different arguments as input, but a pointer to a structure containing all arguments. This results in more readable code, faster callback invocation (as some arguments do not change between invocations) and is extensible, as new members to the structure can be later added in a backward compatible way (if required).</p>
<p>The conversion script can convert the definition and declaration of the old callback functions in most cases. Before running the script, make sure that you never type-cast a callback function when assigning it (as this has the danger of assigning a callback function with a wrong type if the conversion did not detect some callbacks as such). If the script does not detect a callback function, make sure the argument types match exactly the types in the header (e.g. write <code>const int</code> instead of <code>int const</code> or convert the callback manually).</p></li>
<li><p>An intersection context is now required for each ray query invocation. The context should be initialized using the <code>rtcInitIntersectContext</code> function.</p></li>
<li><p>The <code>rtcIntersect</code>-type functions get as input an <code>RTCRayHit</code> type, which is similar to before, but has the ray and hit parts split into two sub-structures.</p>
<p>The <code>rtcOccluded</code>-type functions get as input an <code>RTCRay</code> type, which does not contain hit data anymore. When an occlusion is found, the <code>tfar</code> element of the ray is set to <code>-inf</code>.</p>
<p>Required code changes cannot be done by the upgrade script and need to be done manually.</p></li>
<li><p>The ray layout for single rays and packets of rays had certain incompatibilities (alignment of <code>org</code> and <code>dir</code> for single rays caused gaps in the single ray layout that were not in the ray packet layout). This issue never showed up because single rays and ray packets were separate in the system initially. This layout issue is now fixed, and a single ray has the same layout as a ray packet of size 1.</p></li>
<li><p>Previously Embree supported placing additional data at the end of the ray structure, and accessing that data inside user geometry callbacks and filter callback functions.</p>
<p>With Embree 3 this is no longer supported, and the ray passed to a callback function may be copied to a different memory location. To attach additional data to your ray, simply extend the intersection context with a pointer to that data.</p>
<p>This change cannot be done by the script. Further, code will still work if you extend the ray as the implementation did not change yet.</p></li>
<li><p>The ray structure now contains an additional <code>id</code> and <code>flags</code> field. The <code>id</code> can be used to store the index of the ray with respect to a ray packet or ray stream. The <code>flags</code> is reserved for future use, and currently must be set to 0.</p></li>
<li><p>All previous intersection filter callback variants have been removed, except for the <code>RTCFilterFuncN</code> which gets a varying size ray packet as input. The semantics of this filter function type have changed from copying the hit on acceptance to clearing the ray’s valid argument in case of non-acceptance. This way, chaining multiple filters is more efficient.</p>
<p>We kept the guarantee that for <code>rtcIntersect1/4/8/16</code> and <code>rtcOccluded1/4/8/16</code> calls the packet size and ray order will not change from the initial size and ordering when entering a filter callback.</p></li>
<li><p>We no longer export ISPC-specific symbols. This has the advantage that certain linking issues went away, e.g. it is now possible to link an ISPC application compiled for any combination of ISAs, and link this to an Embree library compiled with a different set of ISAs. Previously the ISAs of the application had to be a subset of the ISAs of Embree, and when the user enabled exactly one ISA, they had to do this in Embree and the application.</p></li>
<li><p>We no longer export the ISPC tasking system, which means that the application has the responsibility to implement the ISPC tasking system itself. ISPC comes with example code on how to do this. This change is not performed by the script and must be done manually.</p></li>
<li><p>Fixed many naming inconsistencies, and changed names of further API functions. All these renamings are properly done by the script and need no further attention.</p></li>
</ul>
<p></p>
<h1 id="embree-api-reference">Embree API Reference</h1>
<h2 id="rtcnewdevice">rtcNewDevice</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewDevice - creates a <span class="kw">new</span> device</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCDevice rtcNewDevice(<span class="dt">const</span> <span class="dt">char</span>* config);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>This function creates a new device and returns a handle to this device. The device object is reference counted with an initial reference count of 1. The handle can be released using the <code>rtcReleaseDevice</code> API call.</p>
<p>The device object acts as a class factory for all other object types. All objects created from the device (like scenes, geometries, etc.) hold a reference to the device, thus the device will not be destroyed unless these objects are destroyed first.</p>
<p>Objects are only compatible if they belong to the same device, e.g it is not allowed to create a geometry in one device and attach it to a scene created with a different device.</p>
<p>A configuration string (<code>config</code> argument) can be passed to the device construction. This configuration string can be <code>NULL</code> to use the default configuration.</p>
<p>When creating the device, Embree reads configurations for the device from the following locations in order:</p>
<ol style="list-style-type: decimal">
<li><code>config</code> string passed to the <code>rtcNewDevice</code> function</li>
<li><code>.embree3</code> file in the application folder</li>
<li><code>.embree3</code> file in the home folder</li>
</ol>
<p>Settings performed later overwrite previous settings. This way the configuration for the application can be changed globally (either through the <code>rtcNewDevice</code> call or through the <code>.embree3</code> file in the application folder), and each user has the option to modify the configuration to fit their needs.</p>
<p>The following configuration is supported:</p>
<ul>
<li><p><code>threads=[int]</code>: Specifies a number of build threads to use. A value of 0 enables all detected hardware threads. By default all hardware threads are used.</p></li>
<li><p><code>set_affinity=[0/1]</code>: When enabled, build threads are affinitized to hardware threads. This option is disabled by default on standard CPUs, and enabled by default on Xeon Phi Processors.</p></li>
<li><p><code>start_threads=[0/1]</code>: When enabled, the build threads are started upfront. This can be useful for benchmarking to exclude thread creation time. This option is disabled by default.</p></li>
<li><p><code>isa=[sse2,sse4.2,avx,avx2,avx512knl,avx512skx]</code>: Use specified ISA. By default the ISA is selected automatically.</p></li>
<li><p><code>max_isa=[sse2,sse4.2,avx,avx2,avx512knl,avx512skx]</code>: Configures the automated ISA selection to use maximally the specified ISA.</p></li>
<li><p><code>hugepages=[0/1]</code>: Enables or disables usage of huge pages. Under Linux huge pages are used by default but under Windows and macOS they are disabled by default.</p></li>
<li><p><code>enable_selockmemoryprivilege=[0/1]</code>: When set to 1, this enables the <code>SeLockMemoryPrivilege</code> privilege with is required to use huge pages on Windows. This option has an effect only under Windows and is ignored on other platforms. See Section <a href="#huge-page-support">Huge Page Support</a> for more details.</p></li>
<li><p><code>ignore_config_files=[0/1]</code>: When set to 1, configuration files are ignored. Default is 0.</p></li>
<li><p><code>verbose=[0,1,2,3]</code>: Sets the verbosity of the output. When set to 0, no output is printed by Embree, when set to a higher level more output is printed. By default Embree does not print anything on the console.</p></li>
</ul>
<p>Different configuration options should be separated by commas, e.g.:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewDevice(<span class="st">&quot;threads=1,isa=avx&quot;</span>);</code></pre>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On success returns a handle of the created device. On failure returns <code>NULL</code> as device and sets a per-thread error code that can be queried using <code>rtcDeviceGetError(NULL)</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretaindevice">rtcRetainDevice</a>, <a href="#rtcreleasedevice">rtcReleaseDevice</a></p>
<p></p>
<h2 id="rtcretaindevice">rtcRetainDevice</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainDevice - increments the device reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainDevice(RTCDevice device);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Device objects are reference counted. The <code>rtcRetainDevice</code> function increments the reference count of the passed device object (<code>device</code> argument). This function together with <code>rtcReleaseDevice</code> allows to use the internal reference counting in a C++ wrapper class to manage the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewdevice">rtcNewDevice</a>, <a href="#rtcreleasedevice">rtcReleaseDevice</a></p>
<p></p>
<h2 id="rtcreleasedevice">rtcReleaseDevice</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseDevice - decrements the device reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseDevice(RTCDevice device);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Device objects are reference counted. The <code>rtcReleaseDevice</code> function decrements the reference count of the passed device object (<code>device</code> argument). When the reference count falls to 0, the device gets destroyed.</p>
<p>All objects created from the device (like scenes, geometries, etc.) hold a reference to the device, thus the device will not get destroyed unless these objects are destroyed first.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewdevice">rtcNewDevice</a>, <a href="#rtcretaindevice">rtcRetainDevice</a></p>
<p></p>
<h2 id="rtcgetdeviceproperty">rtcGetDeviceProperty</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetDeviceProperty - queries properties of the device</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

ssize_t rtcGetDeviceProperty(
  RTCDevice device,
  RTCDeviceProperty prop
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetDeviceProperty</code> function can be used to query properties (<code>prop</code> argument) of a device object (<code>device</code> argument). The returned property is an integer of type <code>ssize_t</code>.</p>
<p>Possible properties to query are:</p>
<ul>
<li><p><code>RTC_DEVICE_PROPERTY_VERSION</code>: Queries the combined version number (MAJOR.MINOR.PATCH) with two decimal digits per component. E.g. for Embree 2.8.3 the integer 208003 is returned.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_VERSION_MAJOR</code>: Queries the major version number of Embree.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_VERSION_MINOR</code>: Queries the minor version number of Embree.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_VERSION_PATCH</code>: Queries the patch version number of Embree.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_NATIVE_RAY4_SUPPORTED</code>: Queries whether the <code>rtcIntersect4</code> and <code>rtcOccluded4</code> functions preserve packet size and ray order when invoking callback functions. This is only the case if Embree is compiled with <code>EMBREE_RAY_PACKETS</code> and <code>SSE2</code> (or <code>SSE4.2</code>) enabled, and if the machine it is running on supports <code>SSE2</code> (or <code>SSE4.2</code>).</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_NATIVE_RAY8_SUPPORTED</code>: Queries whether the <code>rtcIntersect8</code> and <code>rtcOccluded8</code> functions preserve packet size and ray order when invoking callback functions. This is only the case if Embree is compiled with <code>EMBREE_RAY_PACKETS</code> and <code>AVX</code> (or <code>AVX2</code>) enabled, and if the machine it is running on supports <code>AVX</code> (or <code>AVX2</code>).</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_NATIVE_RAY16_SUPPORTED</code>: Queries whether the <code>rtcIntersect16</code> and <code>rtcOccluded16</code> functions preserve packet size and ray order when invoking callback functions. This is only the case if Embree is compiled with <code>EMBREE_RAY_PACKETS</code> and <code>AVX512SKX</code> (or <code>AVX512KNL</code>) enabled, and if the machine it is running on supports <code>AVX512SKX</code> (or <code>AVX512KNL</code>).</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_RAY_STREAM_SUPPORTED</code>: Queries whether <code>rtcIntersect1M</code>, <code>rtcIntersect1Mp</code>, <code>rtcIntersectNM</code>, <code>rtcIntersectNp</code>, <code>rtcOccluded1M</code>, <code>rtcOccluded1Mp</code>, <code>rtcOccludedNM</code>, and <code>rtcOccludedNp</code> are supported. This is only the case if Embree is compiled with <code>EMBREE_RAY_PACKETS</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_RAY_MASK_SUPPORTED</code>: Queries whether ray masks are supported. This is only the case if Embree is compiled with <code>EMBREE_RAY_MASK</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_BACKFACE_CULLING_ENABLED</code>: Queries whether back face culling is enabled. This is only the case if Embree is compiled with <code>EMBREE_BACKFACE_CULLING</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_FILTER_FUNCTION_SUPPORTED</code>: Queries whether filter functions are supported, which is the case if Embree is compiled with <code>EMBREE_FILTER_FUNCTION</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_IGNORE_INVALID_RAYS_ENABLED</code>: Queries whether invalid rays are ignored, which is the case if Embree is compiled with <code>EMBREE_IGNORE_INVALID_RAYS</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_TRIANGLE_GEOMETRY_SUPPORTED</code>: Queries whether triangles are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_TRIANGLE</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_QUAD_GEOMETRY_SUPPORTED</code>: Queries whether quads are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_QUAD</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_SUBDIVISION_GEOMETRY_SUPPORTED</code>: Queries whether subdivision meshes are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_SUBDIVISION</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_CURVE_GEOMETRY_SUPPORTED</code>: Queries whether curves are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_CURVE</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_USER_GEOMETRY_SUPPORTED</code>: Queries whether user geometries are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_USER</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_TASKING_SYSTEM</code>: Queries the tasking system Embree is compiled with. Possible return values are:</p>
<ol start="0" style="list-style-type: decimal">
<li>internal tasking system</li>
<li>Intel Threading Building Blocks (TBB)</li>
<li>Parallel Patterns Library (PPL)</li>
</ol></li>
<li><p><code>RTC_DEVICE_PROPERTY_COMMIT_JOIN_SUPPORTED</code>: Queries whether <code>rtcJoinCommitScene</code> is supported. This is not the case when Embree is compiled with PPL or older versions of TBB.</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On success returns the value of the queried property. For properties returning a boolean value, the return value 0 denotes <code>false</code> and 1 denotes <code>true</code>.</p>
<p>On failure zero is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p>[rtcSetDeviceProperty]</p>
<p></p>
<h2 id="rtcgetdeviceerror">rtcGetDeviceError</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetDeviceError - returns the error code of the device</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCError rtcGetDeviceError(RTCDevice device);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Each thread has its own error code per device. If an error occurs when calling an API function, this error code is set to the occurred error if it stores no previous error. The <code>rtcGetDeviceError</code> function reads and returns the currently stored error and clears the error code. This assures that the returned error code is always the first error occurred since the last invocation of <code>rtcGetDeviceError</code>.</p>
<p>Possible error codes returned by <code>rtcGetDeviceError</code> are:</p>
<ul>
<li><p><code>RTC_ERROR_NONE</code>: No error occurred.</p></li>
<li><p><code>RTC_ERROR_UNKNOWN</code>: An unknown error has occurred.</p></li>
<li><p><code>RTC_ERROR_INVALID_ARGUMENT</code>: An invalid argument was specified.</p></li>
<li><p><code>RTC_ERROR_INVALID_OPERATION</code>: The operation is not allowed for the specified object.</p></li>
<li><p><code>RTC_ERROR_OUT_OF_MEMORY</code>: There is not enough memory left to complete the operation.</p></li>
<li><p><code>RTC_ERROR_UNSUPPORTED_CPU</code>: The CPU is not supported as it does not support the lowest ISA Embree is compiled for.</p></li>
<li><p><code>RTC_ERROR_CANCELLED</code>: The operation got canceled by a memory monitor callback or progress monitor callback function.</p></li>
</ul>
<p>When the device construction fails, <code>rtcNewDevice</code> returns <code>NULL</code> as device. To detect the error code of a such a failed device construction, pass <code>NULL</code> as device to the <code>rtcGetDeviceError</code> function. For all other invocations of <code>rtcGetDeviceError</code>, a proper device pointer must be specified.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>Returns the error code for the device.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetdeviceerrorfunction">rtcSetDeviceErrorFunction</a></p>
<p></p>
<h2 id="rtcsetdeviceerrorfunction">rtcSetDeviceErrorFunction</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetDeviceErrorFunction - sets an error callback function <span class="kw">for</span> the device</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCErrorFunction)(
  <span class="dt">void</span>* userPtr,
  RTCError code,
  <span class="dt">const</span> <span class="dt">char</span>* str
);

<span class="dt">void</span> rtcSetDeviceErrorFunction(
  RTCDevice device,
  RTCErrorFunction error,
  <span class="dt">void</span>* userPtr
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Using the <code>rtcSetDeviceErrorFunction</code> call, it is possible to set a callback function (<code>error</code> argument) with payload (<code>userPtr</code> argument), which is called whenever an error occurs for the specified device (<code>device</code> argument).</p>
<p>Only a single callback function can be registered per device, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>When the registered callback function is invoked, it gets passed the user-defined payload (<code>userPtr</code> argument as specified at registration time), the error code (<code>code</code> argument) of the occurred error, as well as a string (<code>str</code> argument) that further describes the error.</p>
<p>The error code is also set if an error callback function is registered.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetdeviceerror">rtcGetDeviceError</a></p>
<p></p>
<h2 id="rtcsetdevicememorymonitorfunction">rtcSetDeviceMemoryMonitorFunction</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetDeviceMemoryMonitorFunction - registers a callback function
  to track memory consumption</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">typedef</span> <span class="dt">bool</span> (*RTCMemoryMonitorFunction)(
  <span class="dt">void</span>* userPtr,
  ssize_t bytes,
  <span class="dt">bool</span> post
);

<span class="dt">void</span> rtcSetDeviceMemoryMonitorFunction(
  RTCDevice device,
  RTCMemoryMonitorFunction memoryMonitor,
  <span class="dt">void</span>* userPtr
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Using the <code>rtcSetDeviceMemoryMonitorFunction</code> call, it is possible to register a callback function (<code>memoryMonitor</code> argument) with payload (<code>userPtr</code> argument) for a device (<code>device</code> argument), which is called whenever internal memory is allocated or deallocated by objects of that device. Using this memory monitor callback mechanism, the application can track the memory consumption of an Embree device, and optionally terminate API calls that consume too much memory.</p>
<p>Only a single callback function can be registered per device, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>Once registered, the Embree device will invoke the memory monitor callback function before or after it allocates or frees important memory blocks. The callback function gets passed the payload as specified at registration time (<code>userPtr</code> argument), the number of bytes allocated or deallocated (<code>bytes</code> argument), and whether the callback is invoked after the allocation or deallocation took place (<code>post</code> argument). The callback function might get called from multiple threads concurrently.</p>
<p>The application can track the current memory usage of the Embree device by atomically accumulating the <code>bytes</code> input parameter provided to the callback function. This parameter will be &gt;0 for allocations and &lt;0 for deallocations.</p>
<p>Embree will continue its operation normally when returning <code>true</code> from the callback function. If <code>false</code> is returned, Embree will cancel the current operation with the <code>RTC_ERROR_OUT_OF_MEMORY</code> error code. Issuing multiple cancel requests from different threads is allowed. Canceling will only happen when the callback was called for allocations (bytes &gt; 0), otherwise the cancel request will be ignored.</p>
<p>If a callback to cancel was invoked before the allocation happens (<code>post == false</code>), then the <code>bytes</code> parameter should not be accumulated, as the allocation will never happen. If the callback to cancel was invoked after the allocation happened (<code>post == true</code>), then the <code>bytes</code> parameter should be accumulated, as the allocation properly happened and a deallocation will later free that data block.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewdevice">rtcNewDevice</a></p>
<p></p>
<h2 id="rtcnewscene">rtcNewScene</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewScene - creates a <span class="kw">new</span> scene</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCScene rtcNewScene(RTCDevice device);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>This function creates a new scene bound to the specified device (<code>device</code> argument), and returns a handle to this scene. The scene object is reference counted with an initial reference count of 1. The scene handle can be released using the <code>rtcReleaseScene</code> API call.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On success a scene handle is returned. On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretainscene">rtcRetainScene</a>, <a href="#rtcreleasescene">rtcReleaseScene</a></p>
<p></p>
<h2 id="rtcretainscene">rtcRetainScene</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainScene - increments the scene reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainScene(RTCScene scene);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Scene objects are reference counted. The <code>rtcRetainScene</code> function increments the reference count of the passed scene object (<code>scene</code> argument). This function together with <code>rtcReleaseScene</code> allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewscene">rtcNewScene</a>, <a href="#rtcreleasescene">rtcReleaseScene</a></p>
<p></p>
<h2 id="rtcreleasescene">rtcReleaseScene</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseScene - decrements the scene reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseScene(RTCScene scene);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Scene objects are reference counted. The <code>rtcReleaseScene</code> function decrements the reference count of the passed scene object (<code>scene</code> argument). When the reference count falls to 0, the scene gets destroyed.</p>
<p>The scene holds a reference to all attached geometries, thus if the scene gets destroyed, all geometries get detached and their reference count decremented.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewscene">rtcNewScene</a>, <a href="#rtcretainscene">rtcRetainScene</a></p>
<p></p>
<h2 id="rtcattachgeometry">rtcAttachGeometry</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcAttachGeometry - attaches a geometry to the scene</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">unsigned</span> <span class="dt">int</span> rtcAttachGeometry(
  RTCScene scene,
  RTCGeometry geometry
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcAttachGeometry</code> function attaches a geometry (<code>geometry</code> argument) to a scene (<code>scene</code> argument) and assigns a geometry ID to that geometry. All geometries attached to a scene are defined to be included inside the scene. A geometry can only get attached to a single scene at a given time. However, it is possible to detach and re-attach a geometry to a different scene. The geometry ID is unique for the scene, and is used to identify the geometry when hit by a ray during ray queries.</p>
<p>This function is thread-safe, thus multiple threads can attach geometries to a scene in parallel.</p>
<p>The geometry IDs are assigned sequentially, starting from 0, as long as no geometry got detached. If geometries got detached, the implementation will reuse IDs in an implementation dependent way. Consequently sequential assignment is no longer guaranteed, but a compact range of IDs.</p>
<p>These rules allow the application to manage a dynamic array to efficiently map from geometry IDs to its own geometry representation. Alternatively, the application can also use per-geometry user data to map to its geometry representation. See <code>rtcSetGeometryUserData</code> and <code>rtcGetGeometryUserData</code> for more information.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcgetgeometryuserdata">rtcGetGeometryUserData</a></p>
<p></p>
<h2 id="rtcattachgeometrybyid">rtcAttachGeometryByID</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcAttachGeometryByID - attaches a geometry to the scene
  <span class="kw">using</span> a specified geometry ID</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcAttachGeometryByID(
  RTCScene scene,
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcAttachGeometryByID</code> function attaches a geometry (<code>geometry</code> argument) to a scene (<code>scene</code> argument) and assigns a user provided geometry ID (<code>geomID</code> argument) to that geometry. All geometries attached to a scene are defined to be included inside the scene. A geometry can only get attached to a single scene at a given time. However, it is possible to detach and re-attach a geometry to a different scene. The passed user-defined geometry ID is used to identify the geometry when hit by a ray during ray queries. Using this function, it is possible to share the same IDs to refer to geometries inside the application and Embree.</p>
<p>This function is thread-safe, thus multiple threads can attach geometries to a scene in parallel.</p>
<p>The user-provided geometry ID must be unused in the scene, otherwise the creation of the geometry will fail. Further, the user-provided geometry IDs should be compact, as Embree internally creates a vector which size is equal to the largest geometry ID used. Creating very large geometry IDs for small scenes would thus cause a memory consumption and performance overhead.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcattachgeometry">rtcAttachGeometry</a></p>
<p></p>
<h2 id="rtcdetachgeometry">rtcDetachGeometry</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcDetachGeometry - detaches a geometry from the scene</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcDetachGeometry(RTCScene scene, <span class="dt">unsigned</span> <span class="dt">int</span> geomID);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>This function detaches a geometry identified by its geometry ID (<code>geomID</code> argument) from a scene (<code>scene</code> argument). When detached, the geometry is no longer contained in the scene.</p>
<p>This function is thread-safe, thus multiple threads can detach geometries from a scene at the same time.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcattachgeometry">rtcAttachGeometry</a>, <a href="#rtcattachgeometrybyid">rtcAttachGeometryByID</a></p>
<p></p>
<h2 id="rtcgetgeometry">rtcGetGeometry</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometry - returns the geometry bound to
  the specified geometry ID</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry rtcGetGeometry(RTCScene scene, <span class="dt">unsigned</span> <span class="dt">int</span> geomID);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometry</code> function returns the geometry that is bound to the specified geometry ID (<code>geomID</code> argument) for the specified scene (<code>scene</code> argument). This function just looks up the handle and does <em>not</em> increment the reference count. If you want to get ownership of the handle, you need to additionally call <code>rtcRetainGeometry</code>. For this reason, this function is fast and can be used during rendering. However, it is generally recommended to store the geometry handle inside the application’s geometry representation and look up the geometry handle from that representation directly.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcattachgeometry">rtcAttachGeometry</a>, <a href="#rtcattachgeometrybyid">rtcAttachGeometryByID</a></p>
<p></p>
<h2 id="rtccommitscene">rtcCommitScene</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcCommitScene - commits scene changes</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcCommitScene(RTCScene scene);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcCommitScene</code> function commits all changes for the specified scene (<code>scene</code> argument). This internally triggers building of a spatial acceleration structure for the scene using all available worker threads. Ray queries can be performed only after committing all scene changes.</p>
<p>The kind of acceleration structure built can be influenced using scene flags (see <code>rtcSetSceneFlags</code>), and the quality can be specified using the <code>rtcSetSceneBuildQuality</code> function.</p>
<p>Embree silently ignores primitives during spatial acceleration structure construction that would cause numerical issues, e.g. primitives containing NaNs, INFs, or values greater than 1.844E18f (as no reasonable calculations can be performed with such values without causing overflows).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p>[rtcCommitJoinScene]</p>
<p></p>
<h2 id="rtcjoincommitscene">rtcJoinCommitScene</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcJoinCommitScene - commits the scene from multiple threads</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcJoinCommitScene(RTCScene scene);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcJoinCommitScene</code> function commits all changes for the specified scene (<code>scene</code> argument). In contrast to the <code>rtcCommitScene</code> function, the <code>rtcJoinCommitScene</code> function can be called from multiple threads, which all cooperate in the same scene commit. All threads will return from this function after the scene commit is finished. All threads must consistently call <code>rtcJoinCommitScene</code> and not <code>rtcCommitScene</code>.</p>
<p>The scene commit internally triggers building of a spatial acceleration structure for the scene. Ray queries can be performed after scene changes got properly committed.</p>
<p>The <code>rtcJoinCommitScene</code> feature allows a flexible way to lazily create hierarchies during rendering. A thread reaching a not-yet-constructed sub-scene of a two-level scene can generate the sub-scene geometry and call <code>rtcJoinCommitScene</code> on that just generated scene. During construction, further threads reaching the not-yet-built scene can join the build operation by also invoking <code>rtcJoinCommitScene</code>. A thread that calls <code>rtcJoinCommitScene</code> after the build finishes will directly return from the <code>rtcJoinCommitScene</code> call.</p>
<p>Multiple scene commit operations on different scenes can be running at the same time, hence it is possible to commit many small scenes in parallel, distributing the commits to many threads.</p>
<p>When using Embree with the Intel® Threading Building Blocks (which is the default), threads that call <code>rtcJoinCommitScene</code> will join the build operation, but other TBB worker threads might also participate in the build. To avoid thread oversubscription, we recommend using TBB also inside the application. Further, the join mode only works properly starting with TBB v4.4 Update 1. For earlier TBB versions, threads that call <code>rtcJoinCommitScene</code> to join a running build will just trigger the build and wait for the build to finish. Further, old TBB versions with <code>TBB_INTERFACE_VERSION_MAJOR &lt; 8</code> do not support <code>rtcJoinCommitScene</code>, and invoking this function will result in an error.</p>
<p>When using Embree with the internal tasking system, only threads that call <code>rtcJoinCommitScene</code> will perform the build operation, and no additional worker threads will be scheduled.</p>
<p>When using Embree with the Parallel Patterns Library (PPL), <code>rtcJoinCommitScene</code> is not supported and calling that function will result in an error.</p>
<p>To detect whether <code>rtcJoinCommitScene</code> is supported, use the <code>rtcGetDeviceProperty</code> function.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtccommitscene">rtcCommitScene</a>, <a href="#rtcgetdeviceproperty">rtcGetDeviceProperty</a></p>
<p></p>
<h2 id="rtcsetsceneprogressmonitorfunction">rtcSetSceneProgressMonitorFunction</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetSceneProgressMonitorFunction - registers a callback
  to track build progress</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">typedef</span> <span class="dt">bool</span> (*RTCProgressMonitorFunction)(
  <span class="dt">void</span>* ptr,
  <span class="dt">double</span> n
);

<span class="dt">void</span> rtcSetSceneProgressMonitorFunction(
  RTCScene scene,
  RTCProgressMonitorFunction progress,
  <span class="dt">void</span>* userPtr
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Embree supports a progress monitor callback mechanism that can be used to report progress of hierarchy build operations and to cancel build operations.</p>
<p>The <code>rtcSetSceneProgressMonitorFunction</code> registers a progress monitor callback function (<code>progress</code> argument) with payload (<code>userPtr</code> argument) for the specified scene (<code>scene</code> argument).</p>
<p>Only a single callback function can be registered per scene, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>Once registered, Embree will invoke the callback function multiple times during hierarchy build operations of the scene, by passing the payload as set at registration time (<code>userPtr</code> argument), and a double in the range <span class="math">[0, 1]</span> which estimates the progress of the operation (<code>n</code> argument). The callback function might be called from multiple threads concurrently.</p>
<p>When returning <code>true</code> from the callback function, Embree will continue the build operation normally. When returning <code>false</code>, Embree will cancel the build operation with the <code>RTC_ERROR_CANCELLED</code> error code. Issuing multiple cancel requests for the same build operation is allowed.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewscene">rtcNewScene</a></p>
<p></p>
<h2 id="rtcsetscenebuildquality">rtcSetSceneBuildQuality</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetSceneBuildQuality - sets the build quality <span class="kw">for</span>
  the scene</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetSceneBuildQuality(
  RTCScene scene,
  <span class="kw">enum</span> RTCBuildQuality quality
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetSceneBuildQuality</code> function sets the build quality (<code>quality</code> argument) for the specified scene (<code>scene</code> argument). Possible values for the build quality are:</p>
<ul>
<li><p><code>RTC_BUILD_QUALITY_LOW</code>: Create lower quality data structures, e.g. for dynamic scenes. A two-level spatial index structure is built when enabling this mode, which supports fast partial scene updates, and allows for setting a per-geometry build quality through the <code>rtcSetGeometryBuildQuality</code> function.</p></li>
<li><p><code>RTC_BUILD_QUALITY_MEDIUM</code>: Default build quality for most usages. Gives a good compromise between build and render performance.</p></li>
<li><p><code>RTC_BUILD_QUALITY_HIGH</code>: Create higher quality data structures for final-frame rendering. For certain geometry types this enables a spatial split BVH.</p></li>
</ul>
<p>Selecting a higher build quality results in better rendering performance but slower scene commit times. The default build quality for a scene is <code>RTC_BUILD_QUALITY_MEDIUM</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p>[rtcGetSceneBuildQuality], <a href="#rtcsetgeometrybuildquality">rtcSetGeometryBuildQuality</a></p>
<p></p>
<h2 id="rtcsetsceneflags">rtcSetSceneFlags</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetSceneFlags - sets the flags <span class="kw">for</span> the scene</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetSceneFlags(RTCScene scene, <span class="kw">enum</span> RTCSceneFlags flags);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetSceneFlags</code> function sets the scene flags (<code>flags</code> argument) for the specified scene (<code>scene</code> argument). Possible scene flags are:</p>
<ul>
<li><p><code>RTC_SCENE_FLAG_NONE</code>: No flags set.</p></li>
<li><p><code>RTC_SCENE_FLAG_DYNAMIC</code>: Provides better build performance for dynamic scenes (but also higher memory consumption).</p></li>
<li><p><code>RTC_SCENE_FLAG_COMPACT</code>: Uses compact acceleration structures and avoids algorithms that consume much memory.</p></li>
<li><p><code>RTC_SCENE_FLAG_ROBUST</code>: Uses acceleration structures that allow for robust traversal, and avoids optimizations that reduce arithmetic accuracy. This mode is typically used for avoiding artifacts caused by rays shooting through edges of neighboring primitives.</p></li>
<li><p><code>RTC_SCENE_FLAG_CONTEXT_FILTER_FUNCTION</code>: Enables support for a filter function inside the intersection context. See Section <a href="#rtcinitintersectcontext">rtcInitIntersectContext</a> for more details.</p></li>
</ul>
<p>Multiple flags can be enabled using an <code>or</code> operation, e.g. <code>RTC_SCENE_FLAG_COMPACT | RTC_SCENE_FLAG_ROBUST</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetsceneflags">rtcGetSceneFlags</a></p>
<p></p>
<h2 id="rtcgetsceneflags">rtcGetSceneFlags</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetSceneFlags - returns the flags of the scene</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">enum</span> RTCSceneFlags rtcGetSceneFlags(RTCScene scene);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Queries the flags of a scene. This function can be useful when setting individual flags, e.g. to just set the robust mode without changing other flags the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCSceneFlags flags = rtcGetSceneFlags(scene);
rtcSetSceneFlags(scene, RTC_SCENE_FLAG_ROBUST | flags);</code></pre>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>RTC_SCENE_FLAG_NONE</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetsceneflags">rtcSetSceneFlags</a></p>
<p></p>
<h2 id="rtcgetscenebounds">rtcGetSceneBounds</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetSceneBounds - returns the axis-aligned bounding box of the scene</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCORE_ALIGN(<span class="dv">16</span>) RTCBounds
{
  <span class="dt">float</span> lower_x, lower_y, lower_z, align0;
  <span class="dt">float</span> upper_x, upper_y, upper_z, align1;
};

<span class="dt">void</span> rtcGetSceneBounds(
  RTCScene scene,
  <span class="kw">struct</span> RTCBounds* bounds_o
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetSceneBounds</code> function queries the axis-aligned bounding box of the specified scene (<code>scene</code> argument) and stores that bounding box to the provided destination pointer (<code>bounds_o</code> argument). The stored bounding box consists of lower and upper bounds for the x, y, and z dimensions as specified by the <code>RTCBounds</code> structure.</p>
<p>The provided destination pointer must be aligned to 16 bytes. The function may be invoked only after committing the scene; otherwise the result is undefined.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetscenelinearbounds">rtcGetSceneLinearBounds</a>, <a href="#rtccommitscene">rtcCommitScene</a>, <a href="#rtcjoincommitscene">rtcJoinCommitScene</a></p>
<p></p>
<h2 id="rtcgetscenelinearbounds">rtcGetSceneLinearBounds</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetSceneLinearBounds - returns the linear bounds of the scene</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCORE_ALIGN(<span class="dv">16</span>) RTCLinearBounds
{
  RTCBounds bounds0;
  RTCBounds bounds1;
};

<span class="dt">void</span> rtcGetSceneLinearBounds(
  RTCScene scene,
  <span class="kw">struct</span> RTCLinearBounds* bounds_o
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetSceneLinearBounds</code> function queries the linear bounds of the specified scene (<code>scene</code> argument) and stores them to the provided destination pointer (<code>bounds_o</code> argument). The stored linear bounds consist of bounding boxes for time 0 (<code>bounds0</code> member) and time 1 (<code>bounds1</code> member) as specified by the <code>RTCLinearBounds</code> structure. Linearly interpolating these bounds to a specific time <code>t</code> yields bounds for the geometry at that time.</p>
<p>The provided destination pointer must be aligned to 16 bytes. The function may be called only after committing the scene, otherwise the result is undefined.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetscenebounds">rtcGetSceneBounds</a>, <a href="#rtccommitscene">rtcCommitScene</a>, <a href="#rtcjoincommitscene">rtcJoinCommitScene</a></p>
<p></p>
<h2 id="rtcnewgeometry">rtcNewGeometry</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewGeometry - creates a <span class="kw">new</span> geometry object</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">enum</span> RTCGeometryType
{
 RTC_GEOMETRY_TYPE_TRIANGLE,
 RTC_GEOMETRY_TYPE_QUAD,
 RTC_GEOMETRY_TYPE_SUBDIVISION,
 RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE,
 RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE,
 RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE,
 RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE,
 RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE,
 RTC_GEOMETRY_TYPE_USER,
 RTC_GEOMETRY_TYPE_INSTANCE
};

RTCGeometry rtcNewGeometry(
  RTCDevice device,
  <span class="kw">enum</span> RTCGeometryType type
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Geometries are objects that represent an array of primitives of the same type. The <code>rtcNewGeometry</code> function creates a new geometry of specified type (<code>type</code> argument) bound to the specified device (<code>device</code> argument) and returns a handle to this geometry. The geometry object is reference counted with an initial reference count of 1. The geometry handle can be released using the <code>rtcReleaseGeometry</code> API call.</p>
<p>Supported geometry types are triangle meshes (<code>RTC_GEOMETRY_TYPE_TRIANGLE</code> type), quad meshes (triangle pairs) (<code>RTC_GEOMETRY_TYPE_QUAD</code> type), Catmull-Clark subdivision surfaces (<code>RTC_GEOMETRY_TYPE_SUBDIVISION</code> type), curve geometries with different bases (<code>RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE</code> types), user-defined geometries (<code>RTC_GEOMETRY_TYPE_USER</code>), and instances (<code>RTC_GEOMETRY_TYPE_INSTANCE</code>).</p>
<p>The types <code>RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE</code> and <code>RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE</code> will treat the curve as a sweep surface of a varying-radius circle swept tangentially along the curve. The types <code>RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE</code> and <code>RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE</code> use ray-facing ribbons as a faster-to-intersect approximation.</p>
<p>After construction, geometries are enabled by default and not attached to any scene. Geometries can be disabled (<code>rtcDisableGeometry</code> call), and enabled again (<code>rtcEnableGeometry</code> call). A geometry can be attached to a single scene using the <code>rtcAttachGeometry</code> call (or <code>rtcAttachGeometryByID</code> call), and detached using the <code>rtcDetachGeometry</code> call. During attachment, a geometry ID is assigned to the geometry (or assigned by the user when using the <code>rtcAttachGeometryByID</code> call), which uniquely identifies the geometry inside that scene. This identifier is returned when primitives of the geometry are hit in later ray queries for the scene.</p>
<p>Geometries can also be modified, including their vertex and index buffers. After modifying a buffer, <code>rtcUpdateGeometryBuffer</code> must be called to notify that the buffer got modified.</p>
<p>The application can use the <code>rtcSetGeometryUserData</code> function to set a user data pointer to its own geometry representation, and later read out this pointer using the <code>rtcGetGeometryUserData</code> function.</p>
<p>After setting up the geometry or modifying it, <code>rtcCommitGeometry</code> must be called to finish the geometry setup. After committing the geometry, vertex data interpolation can be performed using the <code>rtcInterpolate</code> and <code>rtcInterpolateN</code> functions.</p>
<p>A build quality can be specified for a geometry using the <code>rtcSetGeometryBuildQuality</code> function, to balance between acceleration structure build performance and ray query performance. The build quality per geometry will be used if a two-level acceleration structure is built internally, which is the case if the <code>RTC_BUILD_QUALITY_LOW</code> is set as the scene build quality. See Section <a href="#rtcsetscenebuildquality">rtcSetSceneBuildQuality</a> for more details.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcenablegeometry">rtcEnableGeometry</a>, <a href="#rtcdisablegeometry">rtcDisableGeometry</a>, <a href="#rtcattachgeometry">rtcAttachGeometry</a>, <a href="#rtcattachgeometrybyid">rtcAttachGeometryByID</a>, <a href="#rtcupdategeometrybuffer">rtcUpdateGeometryBuffer</a>, <a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcgetgeometryuserdata">rtcGetGeometryUserData</a>, <a href="#rtccommitgeometry">rtcCommitGeometry</a>, <a href="#rtcinterpolate">rtcInterpolate</a>, <a href="#rtcinterpolaten">rtcInterpolateN</a>, <a href="#rtcsetgeometrybuildquality">rtcSetGeometryBuildQuality</a>, <a href="#rtcsetscenebuildquality">rtcSetSceneBuildQuality</a>, <a href="#rtc_geometry_type_triangle">RTC_GEOMETRY_TYPE_TRIANGLE</a>, <a href="#rtc_geometry_type_quad">RTC_GEOMETRY_TYPE_QUAD</a>, <a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a>, <a href="#rtc_geometry_type_curve">RTC_GEOMETRY_TYPE_CURVE</a>, <a href="#rtc_geometry_type_user">RTC_GEOMETRY_TYPE_USER</a>, <a href="#rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</a></p>
<p></p>
<h2 id="rtc_geometry_type_triangle">RTC_GEOMETRY_TYPE_TRIANGLE</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_TRIANGLE - triangle geometry type</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_TRIANGLE);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Triangle meshes are created by passing <code>RTC_GEOMETRY_TYPE_TRIANGLE</code> to the <code>rtcNewGeometry</code> function call. The triangle indices can be specified by setting an index buffer (<code>RTC_BUFFER_TYPE_INDEX</code> type) and the triangle vertices by setting a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> type). See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers. The index buffer contains an array of three 32-bit indices per triangle (<code>RTC_FORMAT_UINT</code> format) and the number of primitives is inferred from the size of that buffer. The vertex buffer contains an array of single precision <code>x</code>, <code>y</code>, <code>z</code> floating point coordinates (<code>RTC_FORMAT_FLOAT3</code> format), and the number of vertices are inferred from the size of that buffer. The vertex buffer can be at most 16 GB large.</p>
<p>The parametrization of a triangle uses the first vertex <code>p0</code> as base point, the vector <code>p1 - p0</code> as u-direction and the vector <code>p2 - p0</code> as v-direction. Thus vertex attributes <code>t0,t1,t2</code> can be linearly interpolated over the triangle the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">t_uv = (<span class="dv">1</span>-u-v)*t0 + u*t1 + v*t2
     = t0 + u*(t1-t0) + v*(t2-t0)</code></pre>
<p>A triangle whose vertices are laid out counter-clockwise has its geometry normal pointing upwards outside the front face, like illustrated in the following picture:</p>
<p>[][imgTriangleUV]</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers have to have the same stride and size.</p>
<p>Also see tutorial [Triangle Geometry] for an example of how to create triangle meshes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that be get queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtc_geometry_type_quad">RTC_GEOMETRY_TYPE_QUAD</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_QUAD - quad geometry type</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_QUAD);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Quad meshes are created by passing <code>RTC_GEOMETRY_TYPE_QUAD</code> to the <code>rtcNewGeometry</code> function call. The quad indices can be specified by setting an index buffer (<code>RTC_BUFFER_TYPE_INDEX</code> type) and the quad vertices by setting a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> type). See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers. The index buffer contains an array of four 32-bit indices per quad (<code>RTC_FORMAT_UINT</code> format), and the number of primitives is inferred from the size of that buffer. The vertex buffer contains an array of single precision <code>x</code>, <code>y</code>, <code>z</code> floating point coordinates (<code>RTC_FORMAT_FLOAT3</code> format), and the number of vertices is inferred from the size of that buffer. The vertex buffer can be at most 16 GB large.</p>
<p>A quad is internally handled as a pair of two triangles <code>v0,v1,v3</code> and <code>v2,v3,v1</code>, with the <code>u'</code>/<code>v'</code> coordinates of the second triangle corrected by <code>u = 1-u'</code> and <code>v = 1-v'</code> to produce a quad parametrization where <code>u</code> and <code>v</code> are in the range 0 to 1. Thus the parametrization of a quad uses the first vertex <code>p0</code> as base point, and the vector <code>p1 - p0</code> as <code>u</code>-direction, and <code>p3 - p0</code> as v-direction. Thus vertex attributes <code>t0,t1,t2,t3</code> can be bilinearly interpolated over the quadrilateral the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">t_uv = (<span class="dv">1</span>-v)((<span class="dv">1</span>-u)*t0 + u*t1) + v*((<span class="dv">1</span>-u)*t3 + u*t2)</code></pre>
<p>Mixed triangle/quad meshes are supported by encoding a triangle as a quad, which can be achieved by replicating the last triangle vertex (<code>v0,v1,v2</code> -&gt; <code>v0,v1,v2,v2</code>). This way the second triangle is a line (which can never get hit), and the parametrization of the first triangle is compatible with the standard triangle parametrization.</p>
<p>A quad whose vertices are laid out counter-clockwise has its geometry normal pointing upwards outside the front face, like illustrated in the following picture.</p>
<p>[][imgQuadUV]</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_SUBDIVISION - subdivision geometry type</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_SUBDIVISION);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Catmull-Clark subdivision meshes are supported, including support for edge creases, vertex creases, holes, non-manifold geometry, and face-varying interpolation. The number of vertices per face can be in the range of 3 to 15 vertices (triangles, quadrilateral, pentagons, etc).</p>
<p>Subdivision meshes are created by passing <code>RTC_GEOMETRY_TYPE_SUBDIVISION</code> to the <code>rtcNewGeometry</code> function. Various buffers need to be set by the application to set up the subdivision mesh. See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers. The face buffer (<code>RTC_BUFFER_TYPE_FACE</code> type and <code>RTC_FORMAT_UINT</code> format) contains the number of edges/indices of each face (3 to 15), and the number of faces is inferred from the size of this buffer. The index buffer (<code>RTC_BUFFER_TYPE_INDEX</code> type) contains multiple (3 to 15) 32-bit vertex indices (<code>RTC_FORMAT_UINT</code> format) for each face, and the number of edges is inferred from the size of this buffer. The vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> type) stores an array of single precision <code>x</code>, <code>y</code>, <code>z</code> floating point coordinates (<code>RTC_FORMAT_FLOAT3</code> format), and the number of vertices is inferred from the size of this buffer.</p>
<p>Optionally, the application may set additional index buffers using different buffer slots if multiple topologies are required for face-varying interpolation. The standard vertex buffers (<code>RTC_BUFFER_TYPE_VERTEX</code>) are always bound to the geometry topology (topology 0) thus use <code>RTC_BUFFER_TYPE_INDEX</code> with buffer slot 0. User vertex data interpolation may use different topologies as described later.</p>
<p>Optionally, the application can set up the hole buffer (<code>RTC_BUFFER_TYPE_HOLE</code>) which contains an array of 32-bit indices (<code>RTC_FORMAT_UINT</code> format) of faces that should be considered non-existing in all topologies. The number of holes is inferred from the size of this buffer.</p>
<p>Optionally, the application can fill the level buffer (<code>RTC_BUFFER_TYPE_LEVEL</code>) with a tessellation rate for each of the edges of each face. This buffer must have the same size as the index buffer. The tessellation level is a positive floating point value (<code>RTC_FORMAT_FLOAT</code> format) that specifies how many quads along the edge should be generated during tessellation. If no level buffer is specified, a level of 1 is used. The maximally supported edge level is 4096, and larger levels are clamped to that value. Note that edges may be shared between (typically 2) faces. To guarantee a watertight tessellation, the level of these shared edges should be identical. A uniform tessellation rate for an entire subdivision mesh can be set by using the <code>rtcSetGeometryTessellationRate</code> function. The existence of a level buffer has precedence over the uniform tessellation rate.</p>
<p>Optionally, the application can fill the sparse edge crease buffers to make edges appear sharper. The edge crease index buffer (<code>RTC_BUFFER_TYPE_EDGE_CREASE_INDEX</code>) contains an array of pairs of 32-bit vertex indices (<code>RTC_FORMAT_UINT2</code> format) that specify unoriented edges in the geometry topology. The edge crease weight buffer (<code>RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT</code>) stores for each of these crease edges a positive floating point weight (<code>RTC_FORMAT_FLOAT</code> format). The number of edge creases is inferred from the size of these buffers, which has to be identical. The larger a weight, the sharper the edge. Specifying a weight of infinity is supported and marks an edge as infinitely sharp. Storing an edge multiple times with the same crease weight is allowed, but has lower performance. Storing an edge multiple times with different crease weights results in undefined behavior. For a stored edge (i,j), the reverse direction edges (j,i) do not have to be stored, as both are considered the same unoriented edge. Edge crease features are shared between all topologies.</p>
<p>Optionally, the application can fill the sparse vertex crease buffers to make vertices appear sharper. The vertex crease index buffer (<code>RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX</code>), contains an array of 32-bit vertex indices (<code>RTC_FORMAT_UINT</code> format) to specify a set of vertices from the geometry topology. The vertex crease weight buffer (<code>RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT</code>) specifies for each of these vertices a positive floating point weight (<code>RTC_FORMAT_FLOAT</code> format). The number of vertex creases is inferred from the size of these buffers, and has to be identical. The larger a weight, the sharper the vertex. Specifying a weight of infinity is supported and makes the vertex infinitely sharp. Storing a vertex multiple times with the same crease weight is allowed, but has lower performance. Storing a vertex multiple times with different crease weights results in undefined behavior. Vertex crease features are shared between all topologies.</p>
<p>Subdivision modes can be used to force linear interpolation for parts of the subdivision mesh; see <code>rtcSetGeometrySubdivisionMode</code> for more details.</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers have to have the same stride and size.</p>
<p>Also see tutorial [Subdivision Geometry] for an example of how to create subdivision surfaces.</p>
<h4 id="parametrization">Parametrization</h4>
<p>The parametrization for subdivision faces is different for quadrilaterals and non-quadrilateral faces.</p>
<p>The parametrization of a quadrilateral face uses the first vertex <code>p0</code> as base point, and the vector <code>p1 - p0</code> as u-direction and <code>p3 - p0</code> as v-direction.</p>
<p>The parametrization for all other face types (with number of vertices not equal 4), have a special parametrization where the subpatch ID <code>n</code> (of the <code>n</code>-th quadrilateral that would be obtained by a single subdivision step) and the local hit location inside this quadrilateral are encoded in the UV coordinates. The following code extracts the sub-patch ID <code>i</code> and local UVs of this subpatch:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">int</span> l = floorf(<span class="fl">0.</span><span class="er">5f</span>*U);
<span class="dt">unsigned</span> <span class="dt">int</span> h = floorf(<span class="fl">0.</span><span class="er">5f</span>*V);
<span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">4</span>*h+l;
<span class="dt">float</span> u = <span class="fl">2.</span><span class="er">0f</span>*fracf(<span class="fl">0.</span><span class="er">5f</span>*U)<span class="fl">-0.</span><span class="er">5f</span>;
<span class="dt">float</span> v = <span class="fl">2.</span><span class="er">0f</span>*fracf(<span class="fl">0.</span><span class="er">5f</span>*V)<span class="fl">-0.</span><span class="er">5f</span>;</code></pre>
<p>This encoding allows local subpatch UVs to be in the range <code>[-0.5,1.5[</code> thus negative subpatch UVs can be passed to <code>rtcInterpolate</code> to sample subpatches slightly out of bounds. This can be useful to calculate derivatives using finite differences if required. The encoding further has the property that one can just move the value <code>u</code> (or <code>v</code>) on a subpatch by adding <code>du</code> (or <code>dv</code>) to the special UV encoding as long as it does not fall out of the <code>[-0.5,1.5[</code> range.</p>
<p>To smoothly interpolate vertex attributes over the subdivision surface we recommend using the <code>rtcInterpolate</code> function, which will apply the standard subdivision rules for interpolation and automatically takes care of the special UV encoding for non-quadrilaterals.</p>
<h4 id="face-varying-data">Face-Varying Data</h4>
<p>Face-varying interpolation is supported through multiple topologies per subdivision mesh and binding such topologies to vertex attribute buffers to interpolate. This way, texture coordinates may use a different topology with additional boundaries to construct separate UV regions inside one subdivision mesh.</p>
<p>Each such topology <code>i</code> has a separate index buffer (specified using <code>RTC_BUFFER_TYPE_INDEX</code> with buffer slot <code>i</code>) and separate subdivision mode that can be set using <code>rtcSetGeometrySubdivisionMode</code>. A vertex attribute buffer <code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code> bound to a buffer slot <code>j</code> can be assigned to use a topology for interpolation using the <code>rtcSetGeometryVertexAttributeTopology</code> call.</p>
<p>The face buffer (<code>RTC_BUFFER_TYPE_FACE</code> type) is shared between all topologies, which means that the <code>n</code>-th primitive always has the same number of vertices (e.g. being a triangle or a quad) for each topology. However, the indices of the topologies themselves may be different.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtc_geometry_type_curve">RTC_GEOMETRY_TYPE_CURVE</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE -
  Bézier curve geometry type <span class="kw">using</span> a sweep surface

RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE -
  B-spline curve geometry type <span class="kw">using</span> a sweep surface

RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE -
  linear curve geometry type

RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE -
  Bézier curve geometry type <span class="kw">using</span> a ribbon approximation

RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE - 
  B-spline curve geometry type <span class="kw">using</span> a ribbon approximation</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Curves with per vertex radii are supported with linear, cubic Bézier, and cubic B-spline bases. Such curve geometries are created by passing <code>RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE</code>, or <code>RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE</code>, to the <code>rtcNewGeometry</code> function. The curve indices can be specified through an index buffer (<code>RTC_BUFFER_TYPE_INDEX</code>) and the curve vertices through a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code>). See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers.</p>
<p>The index buffer contains an array of 32-bit indices (<code>RTC_FORMAT_UINT</code> format), each pointing to the ID of the first control vertex. The vertex buffer stores each control vertex in the form of a single precision position and radius stored in <code>x</code>, <code>y</code>, <code>z</code>, <code>r</code> order in memory (<code>RTC_FORMAT_FLOAT4</code> format). The number of vertices is inferred from the size of this buffer. The radii may be smaller than zero for the B-Spline basis, but the interpolated radii should always be greater or equal to zero.</p>
<p>The <code>RTC_GEOMETRY_TYPE_FLAT_*</code> flat mode is a fast mode designed to render distant hair. In this mode the curve is rendered as a connected sequence of ray facing quads. Individual quads are considered to have subpixel size, and zooming onto the curve might show geometric artifacts. The number of quads to subdivide into can be specified through the <code>rtcSetGeometryTessellationRate</code> function. By default the tessellation rate is 4.</p>
<p>In the <code>RTC_GEOMETRY_TYPE_ROUND_*</code> round mode, a real geometric surface is rendered for the curve, which is more expensive but allows closeup views. For the Bézier and B-spline bases, this mode renders a sweep surface by sweeping a varying radius circle tangential along the curve. As a limitation, the radius of the curve has to be smaller than the curvature radius of the curve at each location on the curve. The round mode is currently not supported for the linear basis.</p>
<p>The intersection with the curve segment stores the parametric hit location along the curve segment as u-coordinate (range 0 to +1).</p>
<p>For Bézier and B-spline curves, the v-coordinate is set to the normalized distance in the range -1 to +1. For the linear basis and in round mode the v-coordinate is set to zero.</p>
<p>In flat mode, the geometry normal <code>Ng</code> is set to the tangent of the curve at the hit location. In round mode, the geometry normal <code>Ng</code> is set to the non-normalized geometric normal of the surface.</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size.</p>
<p>Also see tutorials [Hair] and [Curves] for examples of how to create and use curve geometries.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtc_geometry_type_user">RTC_GEOMETRY_TYPE_USER</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_USER - user geometry type</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_USER);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>User-defined geometries contain a number of user-defined primitives, just like triangle meshes contain multiple triangles. The shape of the user-defined primitives is specified through registered callback functions, which enable extending Embree with arbitrary types of primitives.</p>
<p>User-defined geometries are created by passing <code>RTC_GEOMETRY_TYPE_USER</code> to the <code>rtcNewGeometry</code> function call. One has to set the number of primitives (see <code>rtcSetGeometryUserPrimitiveCount</code>), a user data pointer (see <code>rtcSetGeometryUserData</code>), a bounding function closure (see <code>rtcSetGeometryBoundsFunction</code>), as well as user-defined intersect (see <code>rtcSetGeometryIntersectFunction</code>) and occluded (see <code>rtcSetGeometryOccludedFunction</code>) callback functions. The bounding function is used to query the bounds of all time steps of a user primitive, while the intersect and occluded callback functions are called to intersect the primitive with a ray. The user data pointer is passed to each callback invocation and can be used to point to the application’s representation of the user geometry.</p>
<p>The creation of a user geometry typically looks the following:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCGeometry geometry = rtcNewGeometry(device, RTC_GEOMETRY_TYPE_USER);
rtcSetGeometryUserPrimitiveCount(geometry, numPrimitives);
rtcSetGeometryUserData(geometry, userGeometryRepresentation);
rtcSetGeometryBoundsFunction(geometry, boundsFunction);
rtcSetGeometryIntersectFunction(geometry, intersectFunction);
rtcSetGeometryOccludedFunction(geometry, occludedFunction);</code></pre>
<p>Please have a look at the <code>rtcSetGeometryBoundsFunction</code>, <code>rtcSetGeometryIntersectFunction</code>, and <code>rtcSetGeometryOccludedFunction</code> functions on the implementation of the callback functions.</p>
<p>See tutorial [User Geometry] for an example of how to use the user-defined geometries.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcsetgeometryuserprimitivecount">rtcSetGeometryUserPrimitiveCount</a>, <a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcsetgeometryboundsfunction">rtcSetGeometryBoundsFunction</a>, <a href="#rtcsetgeometryintersectfunction">rtcSetGeometryIntersectFunction</a>, <a href="#rtcsetgeometryoccludedfunction">rtcSetGeometryOccludedFunction</a></p>
<p></p>
<h2 id="rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_INSTANCE - instance geometry type</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
   rtcNewGeometry(device, RTC_GEOMETRY_TYPE_INSTANCE);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Embree supports instancing of scenes using affine transformations (3x3 matrix plus translation). As the instanced scene is stored only a single time, even if instanced to multiple locations, this feature can be used to create very complex scenes with small memory footprint. Only single-level instancing is supported natively by Embree, however, multi-level instancing can be manually implemented through user geometries.</p>
<p>Instances are created by passing <code>RTC_GEOMETRY_TYPE_INSTANCE</code> to the <code>rtcNewGeometry</code> function call. The instanced scene can be set using the <code>rtcSetGeometryInstancedScene</code> call, and the affine transformation can be set using the <code>rtcSetGeometryTransform</code> function.</p>
<p>Please note that <code>rtcCommitScene</code> on the instanced scene should be called first, followed by <code>rtcCommitGeometry</code> on the instance, followed by <code>rtcCommitScene</code> for the top-level scene containing the instance.</p>
<p>If a ray hits the instance, the <code>geomID</code> and <code>primID</code> members of the hit are set to the geometry ID and primitive ID of the hit primitive in the instanced scene, and the <code>instID</code> member of the hit is set to the geometry ID of the instance in the top-level scene.</p>
<p>The instancing scheme can also be implemented using user geometries. To achieve this, the user geometry code should set the <code>instID</code> member of the intersection context to the geometry ID of the instance, then trace the transformed ray, and finally set the <code>instID</code> field of the intersection context again to -1. The <code>instID</code> field is copied automatically by each primitive intersector into the <code>instID</code> field of the hit structure when the primitive is hit. See the [User Geometry] tutorial for an example.</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> function. Then a transformation for each time step can be specified using the <code>rtcSetGeometryTransform</code> function.</p>
<p>See tutorial [Instanced Geometry] for an example of how to use instances.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcsetgeometryinstancedscene">rtcSetGeometryInstancedScene</a>, <a href="#rtcsetgeometrytransform">rtcSetGeometryTransform</a></p>
<p></p>
<h2 id="rtcretaingeometry">rtcRetainGeometry</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainGeometry - increments the geometry reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainGeometry(RTCGeometry geometry);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Geometry objects are reference counted. The <code>rtcRetainGeometry</code> function increments the reference count of the passed geometry object (<code>geometry</code> argument). This function together with <code>rtcReleaseGeometry</code> allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcreleasegeometry">rtcReleaseGeometry</a></p>
<p></p>
<h2 id="rtcreleasegeometry">rtcReleaseGeometry</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseGeometry - decrements the geometry reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseGeometry(RTCGeometry geometry);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Geometry objects are reference counted. The <code>rtcReleaseGeometry</code> function decrements the reference count of the passed geometry object (<code>geometry</code> argument). When the reference count falls to 0, the geometry gets destroyed.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcretaingeometry">rtcRetainGeometry</a></p>
<p></p>
<h2 id="rtccommitgeometry">rtcCommitGeometry</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcCommitGeometry - commits geometry changes</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcCommitGeometry(RTCGeometry geometry);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcCommitGeometry</code> function is used to commit all geometry changes performed to a geometry (<code>geometry</code> parameter). After a geometry gets modified, this function must be called to properly update the internal state of the geometry to perform interpolations using <code>rtcInterpolate</code> or to commit a scene containing the geometry using <code>rtcCommitScene</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcinterpolate">rtcInterpolate</a>, <a href="#rtccommitscene">rtcCommitScene</a></p>
<p></p>
<h2 id="rtcenablegeometry">rtcEnableGeometry</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcEnableGeometry - enables the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcEnableGeometry(RTCGeometry geometry);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcEnableGeometry</code> function enables the specified geometry (<code>geometry</code> argument). Only enabled geometries are rendered. Each geometry is enabled by default at construction time.</p>
<p>After enabling a geometry, the scene containing that geometry must be committed using <code>rtcCommitScene</code> for the change to have effect.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcdisablegeometry">rtcDisableGeometry</a>, <a href="#rtccommitscene">rtcCommitScene</a></p>
<p></p>
<h2 id="rtcdisablegeometry">rtcDisableGeometry</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcDisableGeometry - disables the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcDisableGeometry(RTCGeometry geometry);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcDisableGeometry</code> function disables the specified geometry (<code>geometry</code> argument). A disabled geometry is not rendered. Each geometry is enabled by default at construction time.</p>
<p>After disabling a geometry, the scene containing that geometry must be committed using <code>rtcCommitScene</code> for the change to have effect.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcenablegeometry">rtcEnableGeometry</a>, <a href="#rtccommitscene">rtcCommitScene</a></p>
<p></p>
<h2 id="rtcsetgeometrytimestepcount">rtcSetGeometryTimeStepCount</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTimeStepCount - sets the number of time steps of the
  geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTimeStepCount(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> timeStepCount
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTimeStepCount</code> function sets the number of time steps for multi-segment motion blur (<code>timeStepCount</code> parameter) of the specified geometry (<code>geometry</code> parameter).</p>
<p>For triangle meshes (<code>RTC_GEOMETRY_TYPE_TRIANGLE</code>), quad meshes (<code>RTC_GEOMETRY_TYPE_QUAD</code>), curves (<code>RTC_GEOMETRY_TYPE_CURVE</code>), and subdivision geometries (<code>RTC_GEOMETRY_TYPE_SUBDIVISION</code>), the number of time steps directly corresponds to the number of vertex buffer slots available (<code>RTC_BUFFER_TYPE_VERTEX</code> buffer type). For these geometries, one vertex buffer per time step must be specified when creating multi-segment motion blur geometries.</p>
<p>For instance geometries (<code>RTC_GEOMETRY_TYPE_INSTANCE</code>), a transformation must be specified for each time step (see <code>rtcSetGeometryTransform</code>).</p>
<p>For user geometries, the registered bounding callback function must provide a bounding box per primitive and time step, and the intersection and occlusion callback functions should properly intersect the motion-blurred geometry at the ray time.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtcsetgeometryvertexattributecount">rtcSetGeometryVertexAttributeCount</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryVertexAttributeCount - sets the number of vertex
  attributes of the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryVertexAttributeCount(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> vertexAttributeCount
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryVertexAttributeCount</code> function sets the number of slots (<code>vertexAttributeCount</code> parameter) for vertex attribute buffers (<code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>) that can be used for the specified geometry (<code>geometry</code> parameter).</p>
<p>This function is supported only for triangle meshes (<code>RTC_GEOMETRY_TYPE_TRIANGLE</code>), quad meshes (<code>RTC_GEOMETRY_TYPE_QUAD</code>), curves (<code>RTC_GEOMETRY_TYPE_CURVE</code>), and subdivision geometries (<code>RTC_GEOMETRY_TYPE_SUBDIVISION</code>).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, [RTCBufferType]</p>
<p></p>
<h2 id="rtcsetgeometrymask">rtcSetGeometryMask</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryMask - sets the geometry mask</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryMask(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> mask
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryMask</code> function sets a 32-bit geometry mask (<code>mask</code> argument) for the specified geometry (<code>geometry</code> argument).</p>
<p>This geometry mask is used together with the ray mask stored inside the <code>mask</code> field of the ray. The primitives of the geometry are hit by the ray only if the bitwise <code>and</code> operation of the geometry mask with the ray mask is not 0. This feature can be used to disable selected geometries for specifically tagged rays, e.g. to disable shadow casting for certain geometries.</p>
<p>Ray masks are disabled in Embree by default at compile time, and can be enabled through the <code>EMBREE_RAY_MASK</code> parameter in CMake. One can query whether ray masks are enabled by querying the <code>RTC_DEVICE_PROPERTY_RAY_MASK_SUPPORTED</code> device property using <code>rtcGetDeviceProperty</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcray">RTCRay</a>, <a href="#rtcgetdeviceproperty">rtcGetDeviceProperty</a></p>
<p></p>
<h2 id="rtcsetgeometrybuildquality">rtcSetGeometryBuildQuality</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryBuildQuality - sets the build quality <span class="kw">for</span> the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryBuildQuality(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBuildQuality quality
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryBuildQuality</code> function sets the build quality (<code>quality</code> argument) for the specified geometry (<code>geometry</code> argument). The per-geometry build quality is only a hint and may be ignored. Embree currently uses the per-geometry build quality when the scene build quality is set to <code>RTC_BUILD_QUALITY_LOW</code>. In this mode a two-level acceleration structure is build, and geometries build a separate acceleration structure using the geometry build quality. The per-geometry build quality can be one of:</p>
<ul>
<li><p><code>RTC_BUILD_QUALITY_LOW</code>: Creates lower quality data structures, e.g. for dynamic scenes.</p></li>
<li><p><code>RTC_BUILD_QUALITY_MEDIUM</code>: Default build quality for most usages. Gives a good compromise between build and render performance.</p></li>
<li><p><code>RTC_BUILD_QUALITY_HIGH</code>: Creates higher quality data structures for final-frame rendering. Enables a spatial split builder for certain primitive types.</p></li>
<li><p><code>RTC_BUILD_QUALITY_REFIT</code>: Uses a BVH refitting approach when changing only the vertex buffer.</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetscenebuildquality">rtcSetSceneBuildQuality</a></p>
<p></p>
<h2 id="rtcsetgeometrybuffer">rtcSetGeometryBuffer</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryBuffer - assigns a view of a buffer to the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryBuffer(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot,
  <span class="kw">enum</span> RTCFormat format,
  RTCBuffer buffer,
  size_t byteOffset,
  size_t byteStride,
  size_t itemCount
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryBuffer</code> function binds a view of a buffer object (<code>buffer</code> argument) to a geometry buffer type and slot (<code>type</code> and <code>slot</code> argument) of the specified geometry (<code>geometry</code> argument).</p>
<p>One can specify the start of the first buffer element in bytes (<code>byteOffset</code> argument), the byte stride between individual buffer elements (<code>byteStride</code> argument), the format of the buffer elements (<code>format</code> argument), and the number of elements to bind (<code>itemCount</code>).</p>
<p>The start address (<code>byteOffset</code> argument) and stride (<code>byteStride</code> argument) must be both aligned to 4 bytes, otherwise the <code>rtcSetGeometryBuffer</code> function will fail.</p>
<p>After successful completion of this function, the geometry will hold a reference to the buffer object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetsharedgeometrybuffer">rtcSetSharedGeometryBuffer</a>, <a href="#rtcsetnewgeometrybuffer">rtcSetNewGeometryBuffer</a></p>
<p></p>
<h2 id="rtcsetsharedgeometrybuffer">rtcSetSharedGeometryBuffer</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetSharedGeometryBuffer - assigns a view of a shared data buffer
  to a geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetSharedGeometryBuffer(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot,
  <span class="kw">enum</span> RTCFormat format,
  <span class="dt">const</span> <span class="dt">void</span>* ptr,
  size_t byteOffset,
  size_t byteStride,
  size_t itemCount
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetSharedGeometryBuffer</code> function binds a view of a shared user-managed data buffer (<code>ptr</code> argument) to a geometry buffer type and slot (<code>type</code> and <code>slot</code> argument) of the specified geometry (<code>geometry</code> argument).</p>
<p>One can specify the start of the first buffer element in bytes (<code>byteOffset</code> argument), the byte stride between individual buffer elements (<code>byteStride</code> argument), the format of the buffer elements (<code>format</code> argument), and the number of elements to bind (<code>itemCount</code>).</p>
<p>The start address (<code>byteOffset</code> argument) and stride (<code>byteStride</code> argument) must be both aligned to 4 bytes; otherwise the <code>rtcSetGeometryBuffer</code> function will fail.</p>
<p>When the buffer will be used as a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> and <code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>), the last buffer element must be readable using 16-byte SSE load instructions, thus padding the last element is required for certain layouts. E.g. a standard <code>float3</code> vertex buffer layout should add storage for at least one more float to the end of the buffer.</p>
<p>The buffer data must remain valid for as long as the buffer may be used, and the user is responsible for freeing the buffer data when no longer required.</p>
<p>Sharing buffers can significantly reduce the memory required by the application, thus we recommend using this feature. When enabling the <code>RTC_SCENE_COMPACT</code> scene flag, the spatial index structures index into the vertex buffer, resulting in even higher memory savings.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrybuffer">rtcSetGeometryBuffer</a>, <a href="#rtcsetnewgeometrybuffer">rtcSetNewGeometryBuffer</a></p>
<p></p>
<h2 id="rtcsetnewgeometrybuffer">rtcSetNewGeometryBuffer</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetNewGeometryBuffer - creates <span class="kw">and</span> assigns a <span class="kw">new</span> data buffer to
  the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span>* rtcSetNewGeometryBuffer(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot,
  <span class="kw">enum</span> RTCFormat format,
  size_t byteStride,
  size_t itemCount
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetNewGeometryBuffer</code> function creates a new data buffer of specified format (<code>format</code> argument), byte stride (<code>byteStride</code> argument), and number of items (<code>itemCount</code> argument), and assigns it to a geometry buffer slot (<code>type</code> and <code>slot</code> argument) of the specified geometry (<code>geometry</code> argument). The buffer data is managed internally and automatically freed when the geometry is destroyed.</p>
<p>The byte stride (<code>byteStride</code> argument) must be aligned to 4 bytes; otherwise the <code>rtcSetNewGeometryBuffer</code> function will fail.</p>
<p>The allocated buffer will be automatically over-allocated slightly when used as a vertex buffer, where a requirement is that each buffer element should be readable using 16-byte SSE load instructions.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrybuffer">rtcSetGeometryBuffer</a>, <a href="#rtcsetsharedgeometrybuffer">rtcSetSharedGeometryBuffer</a></p>
<p></p>
<h2 id="rtcgetgeometrybufferdata">rtcGetGeometryBufferData</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryBufferData - gets pointer to
  the first buffer view element</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span>* rtcGetGeometryBufferData(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryBufferData</code> function returns a pointer to the first element of the buffer view attached to the specified buffer type and slot (<code>type</code> and <code>slot</code> argument) of the geometry (<code>geometry</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrybuffer">rtcSetGeometryBuffer</a>, <a href="#rtcsetsharedgeometrybuffer">rtcSetSharedGeometryBuffer</a>, <a href="#rtcsetnewgeometrybuffer">rtcSetNewGeometryBuffer</a></p>
<p></p>
<h2 id="rtcupdategeometrybuffer">rtcUpdateGeometryBuffer</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcUpdateGeometryBuffer - marks a buffer view bound to the geometry
  as modified</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcUpdateGeometryBuffer(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcUpdateGeometryBuffer</code> function marks the buffer view bound to the specified buffer type and slot (<code>type</code> and <code>slot</code> argument) of a geometry (<code>geometry</code> argument) as modified.</p>
<p>If a data buffer is changed by the application, the <code>rtcUpdateGeometryBuffer</code> call must be invoked for that buffer. Each buffer view assigned to a buffer slot is initially marked as modified, thus this function needs to be called only when doing buffer modifications after the first <code>rtcCommitScene</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtccommitscene">rtcCommitScene</a></p>
<p></p>
<h2 id="rtcsetgeometryintersectfilterfunction">rtcSetGeometryIntersectFilterFunction</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryIntersectFilterFunction - sets the intersection filter
  <span class="kw">for</span> the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCFilterFunctionNArguments
{
  <span class="dt">int</span>* valid;
  <span class="dt">void</span>* geometryUserPtr;
  <span class="dt">const</span> <span class="kw">struct</span> RTCIntersectContext* context;
  <span class="kw">struct</span> RTCRayN* ray;
  <span class="kw">struct</span> RTCHitN* hit;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCFilterFunctionN)(
  <span class="dt">const</span> <span class="kw">struct</span> RTCFilterFunctionNArguments* args
);

<span class="dt">void</span> rtcSetGeometryIntersectFilterFunction(
  RTCGeometry geometry,
  RTCFilterFunctionN filter
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryIntersectFilterFunction</code> function registers an intersection filter callback function (<code>filter</code> argument) for the specified geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered intersection filter function is invoked for every hit encountered during the <code>rtcIntersect</code>-type ray queries and can accept or reject that hit. The feature can be used to define a silhouette for a primitive and reject hits that are outside the silhouette. E.g. a tree leaf could be modeled with an alpha texture that decides whether hit points lie inside or outside the leaf.</p>
<p>If the <code>RTC_SCENE_HIGH_QUALITY</code> mode is set, the filter functions may be called multiple times for the same primitive hit. Further, rays hitting exactly the edge might also report two hits for the same surface. For certain use cases, the application may have to work around this limitation by collecting already reported hits (<code>geomID</code>/<code>primID</code> pairs) and ignoring duplicates.</p>
<p>The filter function callback of type <code>RTCFilterFunctionN</code> gets passed a number of arguments through the <code>RTCFilterFunctionNArguments</code> structure. The <code>valid</code> parameter of that structure points to an integer valid mask (0 means invalid and -1 means valid). The <code>geometryUserPtr</code> member is a user pointer optionally set per geometry through the <code>rtcSetGeometryUserData</code> function. The <code>context</code> member points to the intersection context passed to the ray query function. The <code>ray</code> parameter points to <code>N</code> rays in SOA layout. The <code>hit</code> parameter points to <code>N</code> hits in SOA layout to test. The <code>N</code> parameter is the number of rays and hits in <code>ray</code> and <code>hit</code>. The hit distance is provided as the <code>tfar</code> value of the ray. If the hit geometry is instanced, the <code>instID</code> member of the ray is valid, and the ray and the potential hit are in object space.</p>
<p>The filter callback function has the task to check for each valid ray whether it wants to accept or reject the corresponding hit. To reject a hit, the filter callback function just has to write <code>0</code> to the integer valid mask of the corresponding ray. To accept the hit, it just has to leave the valid mask set to <code>-1</code>. The filter function is further allowed to change the hit and decrease the <code>tfar</code> value of the ray but it should not modify other ray data nor any inactive components of the ray or hit.</p>
<p>When performing ray queries using <code>rtcIntersect1</code>, it is guaranteed that the packet size is 1 when the callback is invoked. When performing ray queries using the <code>rtcIntersect4/8/16</code> functions, it is not generally guaranteed that the ray packet size (and order of rays inside the packet) passed to the callback matches the initial ray packet. However, under some circumstances these properties are guaranteed, and whether this is the case can be queried using <code>rtcGetDeviceProperty</code>. When performing ray queries using the stream API such as <code>rtcIntersect1M</code>, <code>rtcIntersect1Mp</code>, <code>rtcIntersectNM</code>, or <code>rtcIntersectNp</code> the order of rays and ray packet size of the callback function might change to either 1, 4, 8, or 16.</p>
<p>For many usage scenarios, repacking and re-ordering of rays does not cause difficulties in implementing the callback function. However, algorithms that need to extend the ray with additional data must use the <code>rayID</code> component of the ray to identify the original ray to access the per-ray data.</p>
<p>The implementation of the filter function can choose to implement a single code path that uses the ray access helper functions <code>RTCRay_XXX</code> and hit access helper functions <code>RTCHit_XXX</code> to access ray and hit data. Alternatively the code can branch to optimized implementations for specific sizes of <code>N</code> and cast the <code>ray</code> and <code>hit</code> inputs to the proper packet types.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryoccludedfilterfunction">rtcSetGeometryOccludedFilterFunction</a></p>
<p></p>
<h2 id="rtcsetgeometryoccludedfilterfunction">rtcSetGeometryOccludedFilterFunction</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryOccludedFilterFunction - sets the occlusion filter
  <span class="kw">for</span> the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryOccludedFilterFunction(
  RTCGeometry geometry,
  RTCFilterFunctionN filter
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryOccludedFilterFunction</code> function registers an occlusion filter callback function (<code>filter</code> argument) for the specified geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered intersection filter function is invoked for every hit encountered during the <code>rtcOccluded</code>-type ray queries and can accept or reject that hit. The feature can be used to define a silhouette for a primitive and reject hits that are outside the silhouette. E.g. a tree leaf could be modeled with an alpha texture that decides whether hit points lie inside or outside the leaf.</p>
<p>Please see the description of the <code>rtcSetGeometryIntersectFilterFunction</code> for a description of the filter callback function.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryintersectfilterfunction">rtcSetGeometryIntersectFilterFunction</a></p>
<p></p>
<h2 id="rtcfilterintersection">rtcFilterIntersection</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcFilterIntersection - invokes the intersection filter function</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcFilterIntersection(
  <span class="dt">const</span> <span class="kw">struct</span> RTCIntersectFunctionNArguments* args,
  <span class="dt">const</span> <span class="kw">struct</span> RTCFilterFunctionNArguments* filterArgs
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcFilterIntersection</code> function can be called inside an <code>RTCIntersectFunctionN</code> callback function to invoke the intersection filter registered to the geometry and stored inside the context. For this an <code>RTCFilterFunctionNArguments</code> structure must be created (see <code>rtcSetGeometryIntersectFilterFunction</code>) which basically consists of a valid mask, a hit packet to filter, the corresponding ray packet, and the packet size. After the invocation of <code>rtcFilterIntersection</code>, only rays that are still valid (valid mask set to -1) should update a hit.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcfilterocclusion">rtcFilterOcclusion</a>, <a href="#rtcsetgeometryintersectfunction">rtcSetGeometryIntersectFunction</a></p>
<p></p>
<h2 id="rtcfilterocclusion">rtcFilterOcclusion</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcFilterOcclusion - invokes the occlusion filter function</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcFilterOcclusion(
  <span class="dt">const</span> <span class="kw">struct</span> RTCOccludedFunctionNArguments* args,
  <span class="dt">const</span> <span class="kw">struct</span> RTCFilterFunctionNArguments* filterArgs
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcFilterOcclusion</code> function can be called inside an <code>RTCOccludedFunctionN</code> callback function to invoke the occlusion filter registered to the geometry and stored inside the context. For this an <code>RTCFilterFunctionNArguments</code> structure must be created (see <code>rtcSetGeometryIntersectFilterFunction</code>) which basically consists of a valid mask, a hit packet to filter, the corresponding ray packet, and the packet size. After the invocation of <code>rtcFilterOcclusion</code> only rays that are still valid (valid mask set to -1) should signal an occlusion.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcfilterintersection">rtcFilterIntersection</a>, <a href="#rtcsetgeometryoccludedfunction">rtcSetGeometryOccludedFunction</a></p>
<p></p>
<h2 id="rtcsetgeometryuserdata">rtcSetGeometryUserData</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryUserData - sets the user-defined data pointer of the
  geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryUserData(RTCGeometry geometry, <span class="dt">void</span>* userPtr);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryUserData</code> function sets the user-defined data pointer (<code>userPtr</code> argument) for a geometry (<code>geometry</code> argument). This user data pointer is intended to be pointing to the application’s representation of the geometry, and is passed to various callback functions. The application can use this pointer inside the callback functions to access its geometry representation.</p>
<p>The <code>rtcGetGeometryUserData</code> function can be used to query an already set user data pointer of a geometry.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetgeometryuserdata">rtcGetGeometryUserData</a></p>
<p></p>
<h2 id="rtcgetgeometryuserdata">rtcGetGeometryUserData</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryUserData - returns the user data pointer
  of the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span>* rtcGetGeometryUserData(RTCGeometry geometry);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryUserData</code> function queries the user data pointer previously set with <code>rtcSetGeometryUserData</code>. When <code>rtcSetGeometryUserData</code> was not called yet, <code>NULL</code> is returned.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a></p>
<p></p>
<h2 id="rtcsetgeometryuserprimitivecount">rtcSetGeometryUserPrimitiveCount</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryUserPrimitiveCount - sets the number of primitives
  of a user-defined geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryUserPrimitiveCount(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> userPrimitiveCount
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryUserPrimitiveCount</code> function sets the number of user-defined primitives (<code>userPrimitiveCount</code> parameter) of the specified user-defined geometry (<code>geometry</code> parameter).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_user">RTC_GEOMETRY_TYPE_USER</a></p>
<p></p>
<h2 id="rtcsetgeometryboundsfunction">rtcSetGeometryBoundsFunction</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryBoundsFunction - sets a callback to query the
  bounding box of user-defined primitives</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCBoundsFunctionArguments
{
  <span class="dt">void</span>* geometryUserPtr;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="dt">unsigned</span> <span class="dt">int</span> timeStep;
  <span class="kw">struct</span> RTCBounds* bounds_o;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCBoundsFunction)(
  <span class="dt">const</span> <span class="kw">struct</span> RTCBoundsFunctionArguments* args
);

<span class="dt">void</span> rtcSetGeometryBoundsFunction(
  RTCGeometry geometry,
  RTCBoundsFunction bounds,
  <span class="dt">void</span>* userPtr
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryBoundsFunction</code> function registers a bounding box callback function (<code>bounds</code> argument) with payload (<code>userPtr</code> argument) for the specified user geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered bounding box callback function is invoked to calculate axis-aligned bounding boxes of the primitives of the user-defined geometry during spatial acceleration structure construction. The bounding box callback of <code>RTCBoundsFunction</code> type is invoked with a pointer to a structure of type <code>RTCBoundsFunctionArguments</code> which contains various arguments, such as: the user data of the geometry (<code>geometryUserPtr</code> member), the ID of the primitive to calculate the bounds for (<code>primID</code> member), the time step at which to calculate the bounds (<code>timeStep</code> member), and a memory location to write the calculated bound to (<code>bounds_o</code> member).</p>
<p>In a typical usage scenario one would store a pointer to the internal representation of the user geometry object using <code>rtcSetGeometryUserData</code>. The callback function can then read that pointer from the <code>geometryUserPtr</code> field and calculate the proper bounding box for the requested primitive and time, and store that bounding box to the destination structure (<code>bounds_o</code> member).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_user">RTC_GEOMETRY_TYPE_USER</a></p>
<p></p>
<h2 id="rtcsetgeometryintersectfunction">rtcSetGeometryIntersectFunction</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryIntersectFunction - sets the callback function to
  intersect a user geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCIntersectFunctionNArguments
{
  <span class="dt">int</span>* valid;
  <span class="dt">void</span>* geometryUserPtr;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="kw">struct</span> RTCIntersectContext* context;
  <span class="kw">struct</span> RTCRayHitN* rayhit;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCIntersectFunctionN)(
  <span class="dt">const</span> <span class="kw">struct</span> RTCIntersectFunctionNArguments* args
);

<span class="dt">void</span> rtcSetGeometryIntersectFunction(
  RTCGeometry geometry,
  RTCIntersectFunctionN intersect
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryIntersectFunction</code> function registers a ray/primitive intersection callback function (<code>intersect</code> argument) for the specified user geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered callback function is invoked by <code>rtcIntersect</code>-type ray queries to calculate the intersection of a ray packet of variable size with one user-defined primitive. The callback function of type <code>RTCIntersectFunctionN</code> gets passed a number of arguments through the <code>RTCIntersectFunctionNArguments</code> structure. The value <code>N</code> specifies the ray packet size, <code>valid</code> points to an array of integers that specify whether the corresponding ray is valid (-1) or invalid (0), the <code>geometryUserPtr</code> member points to the geometry user data previously set through <code>rtcSetGeometryUserData</code>, the <code>context</code> member points to the intersection context passed to the ray query, the <code>rayhit</code> member points to a ray and hit packet of variable size <code>N</code>, and the <code>primID</code> member identifies the primitive ID of the primitive to intersect.</p>
<p>The <code>ray</code> component of the <code>rayhit</code> structure contains valid data, in particular the <code>tfar</code> value is the current closest hit distance found. All data inside the <code>hit</code> component of the <code>rayhit</code> structure are undefined and should not be read by the function.</p>
<p>The task of the callback function is to intersect each active ray from the ray packet with the specified user primitive. If the user-defined primitive is missed by a ray of the ray packet, the function should return without modifying the ray or hit. If an intersection of the user-defined primitive with the ray was found in the valid range (from <code>tnear</code> to <code>tfar</code>), it should update the hit distance of the ray (<code>tfar</code> member) and the hit (<code>u</code>, <code>v</code>, <code>Ng</code>, <code>instID</code>, <code>geomID</code>, <code>primID</code> members). In particular, the currently intersected instance is stored in the <code>instID</code> field of the intersection context, which must be copied into the <code>instID</code> member of the hit.</p>
<p>As a primitive might have multiple intersections with a ray, the intersection filter function needs to be invoked by the user geometry intersection callback for each encountered intersection, if filtering of intersections is desired. This can be achieved through the <code>rtcFilterIntersection</code> call.</p>
<p>Within the user geometry intersect function, it is safe to trace new rays and create new scenes and geometries.</p>
<p>When performing ray queries using <code>rtcIntersect1</code>, it is guaranteed that the packet size is 1 when the callback is invoked. When performing ray queries using the <code>rtcIntersect4/8/16</code> functions, it is not generally guaranteed that the ray packet size (and order of rays inside the packet) passed to the callback matches the initial ray packet. However, under some circumstances these properties are guaranteed, and whether this is the case can be queried using <code>rtcGetDeviceProperty</code>. When performing ray queries using the stream API such as <code>rtcIntersect1M</code>, <code>rtcIntersect1Mp</code>, <code>rtcIntersectNM</code>, or <code>rtcIntersectNp</code> the order of rays and ray packet size of the callback function might change to either 1, 4, 8, or 16.</p>
<p>For many usage scenarios, repacking and re-ordering of rays does not cause difficulties in implementing the callback function. However, algorithms that need to extend the ray with additional data must use the <code>rayID</code> component of the ray to identify the original ray to access the per-ray data.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryoccludedfunction">rtcSetGeometryOccludedFunction</a>, <a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcfilterintersection">rtcFilterIntersection</a></p>
<p></p>
<h2 id="rtcsetgeometryoccludedfunction">rtcSetGeometryOccludedFunction</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryOccludedFunction - sets the callback function to
  test a user geometry <span class="kw">for</span> occlusion</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCOccludedFunctionNArguments
{
  <span class="dt">int</span>* valid;
  <span class="dt">void</span>* geometryUserPtr;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="kw">struct</span> RTCIntersectContext* context;
  <span class="kw">struct</span> RTCRayN* ray;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCOccludedFunctionN)(
  <span class="dt">const</span> <span class="kw">struct</span> RTCOccludedFunctionNArguments* args
);

<span class="dt">void</span> rtcSetGeometryOccludedFunction(
  RTCGeometry geometry,
  RTCOccludedFunctionN filter
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryOccludedFunction</code> function registers a ray/primitive occlusion callback function (<code>filter</code> argument) for the specified user geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered callback function is invoked by <code>rtcOccluded</code>-type ray queries to test whether the rays of a packet of variable size are occluded by a user-defined primitive. The callback function of type <code>RTCOccludedFunctionN</code> gets passed a number of arguments through the <code>RTCOccludedFunctionNArguments</code> structure. The value <code>N</code> specifies the ray packet size, <code>valid</code> points to an array of integers which specify whether the corresponding ray is valid (-1) or invalid (0), the <code>geometryUserPtr</code> member points to the geometry user data previously set through <code>rtcSetGeometryUserData</code>, the <code>context</code> member points to the intersection context passed to the ray query, the <code>ray</code> member points to a ray packet of variable size <code>N</code>, and the <code>primID</code> member identifies the primitive ID of the primitive to test for occlusion.</p>
<p>The task of the callback function is to intersect each active ray from the ray packet with the specified user primitive. If the user-defined primitive is missed by a ray of the ray packet, the function should return without modifying the ray. If an intersection of the user-defined primitive with the ray was found in the valid range (from <code>tnear</code> to <code>tfar</code>), it should set the <code>tfar</code> member of the ray to <code>-inf</code>.</p>
<p>As a primitive might have multiple intersections with a ray, the occlusion filter function needs to be invoked by the user geometry occlusion callback for each encountered intersection, if filtering of intersections is desired. This can be achieved through the <code>rtcFilterOcclusion</code> call.</p>
<p>Within the user geometry occlusion function, it is safe to trace new rays and create new scenes and geometries.</p>
<p>When performing ray queries using <code>rtcOccluded1</code>, it is guaranteed that the packet size is 1 when the callback is invoked. When performing ray queries using the <code>rtcOccluded4/8/16</code> functions, it is not generally guaranteed that the ray packet size (and order of rays inside the packet) passed to the callback matches the initial ray packet. However, under some circumstances these properties are guaranteed, and whether this is the case can be queried using <code>rtcGetDeviceProperty</code>. When performing ray queries using the stream API such as <code>rtcOccluded1M</code>, <code>rtcOccluded1Mp</code>, <code>rtcOccludedNM</code>, or <code>rtcOccludedNp</code> the order of rays and ray packet size of the callback function might change to either 1, 4, 8, or 16.</p>
<p>For many usage scenarios, repacking and re-ordering of rays does not cause difficulties in implementing the callback function. However, algorithms that need to extend the ray with additional data must use the <code>rayID</code> component of the ray to identify the original ray to access the per-ray data.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryintersectfunction">rtcSetGeometryIntersectFunction</a>, <a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcfilterocclusion">rtcFilterOcclusion</a></p>
<p></p>
<h2 id="rtcsetgeometryinstancedscene">rtcSetGeometryInstancedScene</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryInstancedScene - sets the instanced scene of
  an instance geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryInstancedScene(
  RTCGeometry geometry,
  RTCScene scene
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryInstancedScene</code> function sets the instanced scene (<code>scene</code> argument) of the specified instance geometry (<code>geometry</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</a>, <a href="#rtcsetgeometrytransform">rtcSetGeometryTransform</a></p>
<p></p>
<h2 id="rtcsetgeometrytransform">rtcSetGeometryTransform</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTransform - sets the transformation <span class="kw">for</span> a particular
  time step of an instance geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTransform(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> timeStep,
  <span class="kw">enum</span> RTCFormat format,
  <span class="dt">const</span> <span class="dt">float</span>* xfm
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTransform</code> function sets the local-to-world affine transformation (<code>xfm</code> parameter) of an instance geometry (<code>geometry</code> parameter) for a particular time step (<code>timeStep</code> parameter). The transformation is specified as a 3×4 matrix (3×3 linear transformation plus translation), for which the following formats (<code>format</code> parameter) are supported:</p>
<ul>
<li><p><code>RTC_FORMAT_FLOAT3X4_ROW_MAJOR</code>: The 3×4 float matrix is laid out in row-major form.</p></li>
<li><p><code>RTC_FORMAT_FLOAT3X4_COLUMN_MAJOR</code>: The 3×4 float matrix is laid out in column-major form.</p></li>
<li><p><code>RTC_FORMAT_FLOAT4X4_COLUMN_MAJOR</code>: The 3×4 float matrix is laid out in column-major form as a 4×4 homogeneous matrix with the last row being equal to (0, 0, 0, 1).</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</a></p>
<p></p>
<h2 id="rtcgetgeometrytransform">rtcGetGeometryTransform</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryTransform - returns the interpolated instance
  transformation <span class="kw">for</span> the specified time</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcGetGeometryTransform(
  RTCGeometry geometry,
  <span class="dt">float</span> time,
  <span class="kw">enum</span> RTCFormat format,
  <span class="dt">void</span>* xfm
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryTransform</code> function returns the interpolated local to world transformation (<code>xfm</code> parameter) of an instance geometry (<code>geometry</code> parameter) for a particular time (<code>time</code> parameter in range <span class="math">[0, 1]</span>) in the specified format (<code>format</code> parameter).</p>
<p>Possible formats for the returned matrix are:</p>
<ul>
<li><p><code>RTC_FORMAT_FLOAT3X4_ROW_MAJOR</code>: The 3×4 float matrix is laid out in row-major form.</p></li>
<li><p><code>RTC_FORMAT_FLOAT3X4_COLUMN_MAJOR</code>: The 3×4 float matrix is laid out in column-major form.</p></li>
<li><p><code>RTC_FORMAT_FLOAT4X4_COLUMN_MAJOR</code>: The 3×4 float matrix is laid out in column-major form as a 4x4 homogeneous matrix with last row equal to (0, 0, 0, 1).</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</a>, <a href="#rtcsetgeometrytransform">rtcSetGeometryTransform</a></p>
<p></p>
<h2 id="rtcsetgeometrytessellationrate">rtcSetGeometryTessellationRate</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTessellationRate - sets the tessellation rate of the
  geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTessellationRate(
  RTCGeometry geometry,
  <span class="dt">float</span> tessellationRate
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTessellationRate</code> function sets the tessellation rate (<code>tessellationRate</code> argument) for the specified geometry (<code>geometry</code> argument). The tessellation rate can only be set for flat curves and subdivision geometries. For curves, the tessellation rate specifies the number of ray-facing quads per curve segment. For subdivision surfaces, the tessellation rate specifies the number of quads along each edge.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_curve">RTC_GEOMETRY_TYPE_CURVE</a>, <a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a></p>
<p></p>
<h2 id="rtcsetgeometrytopologycount">rtcSetGeometryTopologyCount</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTopologyCount - sets the number of topologies of
  a subdivision geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTopologyCount(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> topologyCount
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTopologyCount</code> function sets the number of topologies (<code>topologyCount</code> parameter) for the specified subdivision geometry (<code>geometry</code> parameter). The number of topologies of a subdivision geometry must be greater or equal to 1.</p>
<p>To use multiple topologies, first the number of topologies must be specified, then the individual topologies can be configured using <code>rtcSetGeometrySubdivisionMode</code> and by setting an index buffer (<code>RTC_BUFFER_TYPE_INDEX</code>) using the topology ID as the buffer slot.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a>, <a href="#rtcsetgeometrysubdivisionmode">rtcSetGeometrySubdivisionMode</a></p>
<p></p>
<h2 id="rtcsetgeometrysubdivisionmode">rtcSetGeometrySubdivisionMode</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometrySubdivisionMode - sets the subdivision mode
  of a subdivision geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometrySubdivisionMode(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> topologyID,
  <span class="kw">enum</span> RTCSubdivisionMode mode
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometrySubdivisionMode</code> function sets the subdivision mode (<code>mode</code> parameter) for the topology (<code>topologyID</code> parameter) of the specified subdivision geometry (<code>geometry</code> parameter).</p>
<p>The subdivision modes can be used to force linear interpolation for certain parts of the subdivision mesh:</p>
<ul>
<li><p><code>RTC_SUBDIVISION_MODE_NO_BOUNDARY</code>: Boundary patches are ignored. This way each rendered patch has a full set of control vertices.</p></li>
<li><p><code>RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY</code>: The sequence of boundary control points are used to generate a smooth B-spline boundary curve (default mode).</p></li>
<li><p><code>RTC_SUBDIVISION_MODE_PIN_CORNERS</code>: Corner vertices are pinned to their location during subdivision.</p></li>
<li><p><code>RTC_SUBDIVISION_MODE_PIN_BOUNDARY</code>: All vertices at the border are pinned to their location during subdivision. This way the boundary is interpolated linearly. This mode is typically used for texturing to also map texels at the border of the texture to the mesh.</p></li>
<li><p><code>RTC_SUBDIVISION_MODE_PIN_ALL</code>: All vertices at the border are pinned to their location during subdivision. This way all patches are linearly interpolated.</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a></p>
<p></p>
<h2 id="rtcsetgeometryvertexattributetopology">rtcSetGeometryVertexAttributeTopology</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryVertexAttributeTopology - binds a vertex
  attribute to a topology of the geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryVertexAttributeTopology(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> vertexAttributeID,
  <span class="dt">unsigned</span> <span class="dt">int</span> topologyID
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryVertexAttributeTopology</code> function binds a vertex attribute buffer slot (<code>vertexAttributeID</code> argument) to a topology (<code>topologyID</code> argument) for the specified subdivision geometry (<code>geometry</code> argument). Standard vertex buffers are always bound to the default topology (topology 0) and cannot be bound differently. A vertex attribute buffer always uses the topology it is bound to when used in the <code>rtcInterpolate</code> and <code>rtcInterpolateN</code> calls.</p>
<p>A topology with ID <code>i</code> consists of a subdivision mode set through <code>rtcSetGeometrySubdivisionMode</code> and the index buffer bound to the index buffer slot <code>i</code>. This index buffer can assign indices for each face of the subdivision geometry that are different to the indices of the default topology. These new indices can for example be used to introduce additional borders into the subdivision mesh to map multiple textures onto one subdivision geometry.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrysubdivisionmode">rtcSetGeometrySubdivisionMode</a>, <a href="#rtcinterpolate">rtcInterpolate</a>, <a href="#rtcinterpolaten">rtcInterpolateN</a></p>
<p></p>
<h2 id="rtcsetgeometrydisplacementfunction">rtcSetGeometryDisplacementFunction</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryDisplacementFunction - sets the displacement function
  <span class="kw">for</span> a subdivision geometry</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCDisplacementFunctionNArguments
{
  <span class="dt">void</span>* geometryUserPtr;
  RTCGeometry geometry;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="dt">unsigned</span> <span class="dt">int</span> timeStep;
  <span class="dt">const</span> <span class="dt">float</span>* u;
  <span class="dt">const</span> <span class="dt">float</span>* v;
  <span class="dt">const</span> <span class="dt">float</span>* Ng_x;
  <span class="dt">const</span> <span class="dt">float</span>* Ng_y;
  <span class="dt">const</span> <span class="dt">float</span>* Ng_z;
  <span class="dt">float</span>* P_x;
  <span class="dt">float</span>* P_y;
  <span class="dt">float</span>* P_z;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCDisplacementFunctionN)(
   <span class="dt">const</span> <span class="kw">struct</span> RTCDisplacementFunctionNArguments* args
);

<span class="dt">void</span> rtcSetGeometryDisplacementFunction(
  RTCGeometry geometry,
  RTCDisplacementFunctionN displacement
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryDisplacementFunction</code> function registers a displacement callback function (<code>displacement</code> argument) for the specified subdivision geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered displacement callback function is invoked to displace points on the subdivision geometry during spatial acceleration structure construction, during the <code>rtcCommitScene</code> call.</p>
<p>The callback function of type <code>RTCDisplacementFunctionN</code> is invoked with a number of arguments stored inside the <code>RTCDisplacementFunctionNArguments</code> structure. The provided user data pointer of the geometry (<code>geometryUserPtr</code> member) can be used to point to the application’s representation of the subdivision mesh. A number <code>N</code> of points to displace are specified in a structure of array layout. For each point to displace, the local patch UV coordinates (<code>u</code> and <code>v</code> arrays), the normalized geometry normal (<code>Ng_x</code>, <code>Ng_y</code>, and <code>Ng_z</code> arrays), and the position (<code>P_x</code>, <code>P_y</code>, and <code>P_z</code> arrays) are provided. The task of the displacement function is to use this information and change the position data.</p>
<p>The geometry handle (<code>geometry</code> member) and primitive ID (<code>primID</code> member) of the patch to displace are additionally provided as well as the time step <code>timeStep</code>, which can be important if the displacement is time-dependent and motion blur is used.</p>
<p>All passed arrays must be aligned to 64 bytes and properly padded to make wide vector processing inside the displacement function easily possible.</p>
<p>Also see tutorial [Displacement Geometry] for an example of how to use the displacement mapping functions.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a></p>
<p></p>
<h2 id="rtcinterpolate">rtcInterpolate</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInterpolate - interpolates vertex attributes</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCInterpolateArguments
{
  RTCGeometry geometry;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="dt">float</span> u;
  <span class="dt">float</span> v;
  <span class="kw">enum</span> RTCBufferType bufferType;
  <span class="dt">unsigned</span> <span class="dt">int</span> bufferSlot;
  <span class="dt">float</span>* P;
  <span class="dt">float</span>* dPdu;
  <span class="dt">float</span>* dPdv;
  <span class="dt">float</span>* ddPdudu;
  <span class="dt">float</span>* ddPdvdv;
  <span class="dt">float</span>* ddPdudv;
  <span class="dt">unsigned</span> <span class="dt">int</span> valueCount;
};

<span class="dt">void</span> rtcInterpolate(
  <span class="dt">const</span> <span class="kw">struct</span> RTCInterpolateArguments* args
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcInterpolate</code> function smoothly interpolates per-vertex data over the geometry. This interpolation is supported for triangle meshes, quad meshes, curve geometries, and subdivision geometries. Apart from interpolating the vertex attribute itself, it is also possible to get the first and second order derivatives of that value. This interpolation ignores displacements of subdivision surfaces and always interpolates the underlying base surface.</p>
<p>The <code>rtcInterpolate</code> call gets passed a number of arguments inside a structure of type <code>RTCInterpolateArguments</code>. For some geometry (<code>geometry</code> parameter) this function smoothly interpolates the per-vertex data stored inside the specified geometry buffer (<code>bufferType</code> and <code>bufferSlot</code> parameters) to the u/v location (<code>u</code> and <code>v</code> parameters) of the primitive (<code>primID</code> parameter). The number of floating point values to interpolate and store to the destination arrays can be specified using the <code>valueCount</code> parameter. As interpolation buffer, one can specify vertex buffers (<code>RTC_BUFFER_TYPE_VERTEX</code>) and vertex attribute buffers (<code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>) as well.</p>
<p>The <code>rtcInterpolate</code> call stores <code>valueCount</code> number of interpolated floating point values to the memory location pointed to by <code>P</code>. One can avoid storing the interpolated value by setting <code>P</code> to <code>NULL</code>.</p>
<p>The first order derivative of the interpolation by u and v are stored at the <code>dPdu</code> and <code>dPdv</code> memory locations. One can avoid storing first order derivatives by setting both <code>dPdu</code> and <code>dPdv</code> to <code>NULL</code>.</p>
<p>The second order derivatives are stored at the <code>ddPdudu</code>, <code>ddPdvdv</code>, and <code>ddPdudv</code> memory locations. One can avoid storing second order derivatives by setting these three pointers to <code>NULL</code>.</p>
<p>To use <code>rtcInterpolate</code> for a geometry, all changes to that geometry must be properly committed using <code>rtcCommitGeometry</code>.</p>
<p>All input buffers and output arrays must be padded to 16 bytes, as the implementation uses 16-byte SSE instructions to read and write into these buffers.</p>
<p>See tutorial [Interpolation] for an example of using the <code>rtcInterpolate</code> function.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcinterpolaten">rtcInterpolateN</a></p>
<p></p>
<h2 id="rtcinterpolaten">rtcInterpolateN</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInterpolateN - performs N interpolations of vertex attribute data</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCInterpolateNArguments
{
  RTCGeometry geometry;
  <span class="dt">const</span> <span class="dt">void</span>* valid;
  <span class="dt">const</span> <span class="dt">unsigned</span> <span class="dt">int</span>* primIDs;
  <span class="dt">const</span> <span class="dt">float</span>* u;
  <span class="dt">const</span> <span class="dt">float</span>* v;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
  <span class="kw">enum</span> RTCBufferType bufferType;
  <span class="dt">unsigned</span> <span class="dt">int</span> bufferSlot;
  <span class="dt">float</span>* P;
  <span class="dt">float</span>* dPdu;
  <span class="dt">float</span>* dPdv;
  <span class="dt">float</span>* ddPdudu;
  <span class="dt">float</span>* ddPdvdv;
  <span class="dt">float</span>* ddPdudv;
  <span class="dt">unsigned</span> <span class="dt">int</span> valueCount;
};

<span class="dt">void</span> rtcInterpolateN(
  <span class="dt">const</span> <span class="kw">struct</span> RTCInterpolateNArguments* args
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcInterpolateN</code> is similar to <code>rtcInterpolate</code>, but performs <code>N</code> many interpolations at once. It additionally gets an array of u/v coordinates and a valid mask (<code>valid</code> parameter) that specifies which of these coordinates are valid. The valid mask points to <code>N</code> integers, and a value of -1 denotes valid and 0 invalid. If the valid pointer is <code>NULL</code> all elements are considers valid. The destination arrays are filled in structure of array (SOA) layout. The value <code>N</code> must be divisible by 4.</p>
<p>To use <code>rtcInterpolateN</code> for a geometry, all changes to that geometry must be properly committed using <code>rtcCommitGeometry</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcinterpolate">rtcInterpolate</a></p>
<p></p>
<h2 id="rtcnewbuffer">rtcNewBuffer</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewBuffer - creates a <span class="kw">new</span> data buffer</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCBuffer rtcNewBuffer(
  RTCDevice device,
  size_t byteSize
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcNewBuffer</code> function creates a new data buffer object of specified size in bytes (<code>byteSize</code> argument) that is bound to the specified device (<code>device</code> argument). The buffer object is reference counted with an initial reference count of 1. The returned buffer object can be released using the <code>rtcReleaseBuffer</code> API call. The specified number of bytes are allocated at buffer construction time and deallocated when the buffer is destroyed.</p>
<p>When the buffer will be used as a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> and <code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>), the last buffer element must be readable using 16-byte SSE load instructions, thus padding the last element is required for certain layouts. E.g. a standard <code>float3</code> vertex buffer layout should add storage for at least one more float to the end of the buffer.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretainbuffer">rtcRetainBuffer</a>, <a href="#rtcreleasebuffer">rtcReleaseBuffer</a></p>
<p></p>
<h2 id="rtcnewsharedbuffer">rtcNewSharedBuffer</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewSharedBuffer - creates a <span class="kw">new</span> shared data buffer</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCBuffer rtcNewSharedBuffer(
  RTCDevice device,
  <span class="dt">void</span>* ptr,
  size_t byteSize
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcNewSharedBuffer</code> function creates a new shared data buffer object bound to the specified device (<code>device</code> argument). The buffer object is reference counted with an initial reference count of 1. The buffer can be released using the <code>rtcReleaseBuffer</code> function.</p>
<p>At construction time, the pointer to the user-managed buffer data (<code>ptr</code> argument) including its size in bytes (<code>byteSize</code> argument) is provided to create the buffer. At buffer construction time no buffer data is allocated, but the buffer data provided be the application is used. The buffer data must remain valid for as long as the buffer may be used, and the user is responsible to free the buffer data when no longer required.</p>
<p>When the buffer will be used as a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> and <code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>), the last buffer element must be readable using 16-byte SSE load instructions, thus padding the last element is required for certain layouts. E.g. a standard <code>float3</code> vertex buffer layout should add storage for at least one more float to the end of the buffer.</p>
<p>The data pointer (<code>ptr</code> argument) must be aligned to 4 bytes; otherwise the <code>rtcNewSharedBuffer</code> function will fail.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretainbuffer">rtcRetainBuffer</a>, <a href="#rtcreleasebuffer">rtcReleaseBuffer</a></p>
<p></p>
<h2 id="rtcretainbuffer">rtcRetainBuffer</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainBuffer - increments the buffer reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainBuffer(RTCBuffer buffer);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Buffer objects are reference counted. The <code>rtcRetainBuffer</code> function increments the reference count of the passed buffer object (<code>buffer</code> argument). This function together with <code>rtcReleaseBuffer</code> allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbuffer">rtcNewBuffer</a>, <a href="#rtcreleasebuffer">rtcReleaseBuffer</a></p>
<p></p>
<h2 id="rtcreleasebuffer">rtcReleaseBuffer</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseBuffer - decrements the buffer reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseBuffer(RTCBuffer buffer);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>Buffer objects are reference counted. The <code>rtcReleaseBuffer</code> function decrements the reference count of the passed buffer object (<code>buffer</code> argument). When the reference count falls to 0, the buffer gets destroyed.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbuffer">rtcNewBuffer</a>, <a href="#rtcretainbuffer">rtcRetainBuffer</a></p>
<p></p>
<h2 id="rtcgetbufferdata">rtcGetBufferData</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetBufferData - gets a pointer to the buffer data</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span>* rtcGetBufferData(RTCBuffer buffer);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetBufferData</code> function returns a pointer to the buffer data of the specified buffer object (<code>buffer</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbuffer">rtcNewBuffer</a></p>
<p></p>
<h2 id="rtcray">RTCRay</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRay - single ray structure</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore_ray.h&gt;</span>

<span class="kw">struct</span> RTC_ALIGN(<span class="dv">16</span>) RTCRay
{
  <span class="dt">float</span> org_x;        <span class="co">// x coordinate of ray origin</span>
  <span class="dt">float</span> org_y;        <span class="co">// y coordinate of ray origin</span>
  <span class="dt">float</span> org_z;        <span class="co">// z coordinate of ray origin</span>
  <span class="dt">float</span> tnear;        <span class="co">// start of ray segment</span>

  <span class="dt">float</span> dir_x;        <span class="co">// x coordinate of ray direction</span>
  <span class="dt">float</span> dir_y;        <span class="co">// y coordinate of ray direction</span>
  <span class="dt">float</span> dir_z;        <span class="co">// z coordinate of ray direction</span>
  <span class="dt">float</span> time;         <span class="co">// time of this ray for motion blur</span>

  <span class="dt">float</span> tfar;         <span class="co">// end of ray segment (set to hit distance)</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> mask;  <span class="co">// ray mask</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> id;    <span class="co">// ray ID</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> flags; <span class="co">// ray flags</span>
};</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>RTCRay</code> structure defines the ray layout for a single ray. The ray contains the origin (<code>org_x</code>, <code>org_y</code>, <code>org_z</code> members), direction vector (<code>dir_x</code>, <code>dir_y</code>, <code>dir_z</code> members), and ray segment (<code>tnear</code> and <code>tfar</code> members). The ray direction does not have to be normalized, and only the parameter range specified by the <code>tnear</code>/<code>tfar</code> interval is considered valid.</p>
<p>The ray segment must be in the range <span class="math">[0, ∞]</span>, thus ranges that start behind the ray origin are not allowed, but ranges can reach to infinity. For rays inside a ray stream, <code>tfar</code> &lt; <code>tnear</code> identifies an inactive ray.</p>
<p>The ray further contains a motion blur time in the range <span class="math">[0, 1]</span> (<code>time</code> member), a ray mask (<code>mask</code> member), a ray ID (<code>id</code> member), and ray flags (<code>flags</code> member). The ray mask can be used to mask out some geometries for some rays (see <code>rtcSetGeometryMask</code> for more details). The ray ID can be used to identify a ray inside a callback function, even if the order of rays inside a ray packet or stream has changed. The ray flags are reserved.</p>
<p>The <code>embree3/rtcore_ray.h</code> header additionally defines the same ray structure in structure of array (SOA) layout for API functions accepting ray packets of size 4 (<code>RTCRay4</code> type), size 8 (<code>RTCRay8</code> type), and size 16 (<code>RTCRay16</code> type). The header additionally defines an <code>RTCRayNt</code> template for ray packets of an arbitrary compile-time size.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtchit">RTCHit</a></p>
<p></p>
<h2 id="rtchit">RTCHit</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCHit - single hit structure</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCHit
{
  <span class="dt">float</span> Ng_x;          <span class="co">// x coordinate of geometry normal</span>
  <span class="dt">float</span> Ng_y;          <span class="co">// y coordinate of geometry normal</span>
  <span class="dt">float</span> Ng_z;          <span class="co">// z coordinate of geometry normal</span>

  <span class="dt">float</span> u;             <span class="co">// barycentric u coordinate of hit</span>
  <span class="dt">float</span> v;             <span class="co">// barycentric v coordinate of hit</span>

  <span class="dt">unsigned</span> <span class="dt">int</span> primID; <span class="co">// geometry ID</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID; <span class="co">// primitive ID</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> instID[RTC_MAX_INSTANCE_LEVEL_COUNT]; <span class="co">// instance ID</span>
};</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>RTCHit</code> type defines the type of a ray/primitive intersection result. The hit contains the unnormalized geometric normal in object space at the hit location (<code>Ng_x</code>, <code>Ng_y</code>, <code>Ng_z</code> members), the barycentric u/v coordinates of the hit (<code>u</code> and <code>v</code> members), as well as the primitive ID (<code>primID</code> member), geometry ID (<code>geomID</code> member), and instance ID (<code>instID</code> member) of the hit. The parametric intersection distance is not stored inside the hit, but stored inside the <code>tfar</code> member of the ray.</p>
<p>The <code>embree3/rtcore_ray.h</code> header additionally defines the same hit structure in structure of array (SOA) layout for hit packets of size 4 (<code>RTCHit4</code> type), size 8 (<code>RTCHit8</code> type), and size 16 (<code>RTCHit16</code> type). The header additionally defines an <code>RTCHitNt</code> template for hit packets of an arbitrary compile-time size.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcray">RTCRay</a></p>
<p></p>
<h2 id="rtcrayhit">RTCRayHit</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRayHit - combined single ray/hit structure</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore_ray.h&gt;</span>

<span class="kw">struct</span> RTCORE_ALIGN(<span class="dv">16</span>) RTCRayHit
{
  <span class="kw">struct</span> RTCRay ray;
  <span class="kw">struct</span> RTCHit hit;
};</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>RTCRayHit</code> structure is used as input for the <code>rtcIntersect</code>-type functions and stores the ray to intersect and some hit fields that hold the intersection result afterwards.</p>
<p>The <code>embree3/rtcore_ray.h</code> header additionally defines the same ray/hit structure in structure of array (SOA) layout for API functions accepting ray packets of size 4 (<code>RTCRayHit4</code> type), size 8 (<code>RTCRayHit8</code> type), and size 16 (<code>RTCRayHit16</code> type). The header additionally defines an <code>RTCRayHitNt</code> template to generate ray/hit packets of an arbitrary compile-time size.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcray">RTCRay</a>, <a href="#rtchit">RTCHit</a></p>
<p></p>
<h2 id="rtcrayn">RTCRayN</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRayN - ray packet of runtime size</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore_ray.h&gt;</span>

<span class="kw">struct</span> RTCRayN;

<span class="dt">float</span>&amp; RTCRayN_org_x(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_org_y(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_org_z(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_tnear(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);

<span class="dt">float</span>&amp; RTCRayN_dir_x(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_dir_y(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_dir_z(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_time (RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);

<span class="dt">float</span>&amp;        RTCRayN_tfar (RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span> <span class="dt">int</span>&amp; RTCRayN_mask (RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span> <span class="dt">int</span>&amp; RTCRayN_id   (RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span> <span class="dt">int</span>&amp; RTCRayN_flags(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>When the ray packet size is not known at compile time (e.g. when Embree returns a ray packet in the <code>RTCFilterFuncN</code> callback function), Embree uses the <code>RTCRayN</code> type for ray packets. These ray packets can only have sizes of 1, 4, 8, or 16. No other packet size will be used.</p>
<p>You can either implement different special code paths for each of these possible packet sizes and cast the ray to the appropriate ray packet type, or implement one general code path that uses the <code>RTCRayN_XXX</code> helper functions to access the ray packet components.</p>
<p>These helper functions get a pointer to the ray packet (<code>ray</code> argument), the packet size (<code>N</code> argument), and returns a reference to a component (e.g. x-component of origin) of the the i-th ray of the packet (<code>i</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtchitn">RTCHitN</a></p>
<p></p>
<h2 id="rtchitn">RTCHitN</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCHitN - hit packet of runtime size</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> HitN;

<span class="dt">float</span>&amp; RTCHitN_Ng_x(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCHitN_Ng_y(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCHitN_Ng_z(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);

<span class="dt">float</span>&amp; RTCHitN_u(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCHitN_v(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);

<span class="dt">unsigned</span>&amp; RTCHitN_primID(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span>&amp; RTCHitN_geomID(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span>&amp; RTCHitN_instID(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i, <span class="dt">unsigned</span> <span class="dt">int</span> l);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>When the hit packet size is not known at compile time (e.g. when Embree returns a hit packet in the <code>RTCFilterFuncN</code> callback function), Embree uses the <code>RTCHitN</code> type for hit packets. These hit packets can only have sizes of 1, 4, 8, or 16. No other packet size will be used.</p>
<p>You can either implement different special code paths for each of these possible packet sizes and cast the hit to the appropriate hit packet type, or implement one general code path that uses the <code>RTCHitN_XXX</code> helper functions to access hit packet components.</p>
<p>These helper functions get a pointer to the hit packet (<code>hit</code> argument), the packet size (<code>N</code> argument), and returns a reference to a component (e.g. x component of <code>Ng</code>) of the the i-th hit of the packet (<code>i</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcrayn">RTCRayN</a></p>
<p></p>
<h2 id="rtcrayhitn">RTCRayHitN</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRayHitN - combined ray/hit packet of runtime size</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore_ray.h&gt;</span>

<span class="kw">struct</span> RTCRayHitN;

<span class="kw">struct</span> RTCRayN* RTCRayHitN_RayN(<span class="kw">struct</span> RTCRayHitN* rayhit, <span class="dt">unsigned</span> <span class="dt">int</span> N);
<span class="kw">struct</span> RTCHitN* RTCRayHitN_HitN(<span class="kw">struct</span> RTCRayHitN* rayhit, <span class="dt">unsigned</span> <span class="dt">int</span> N);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>When the packet size of a ray/hit structure is not known at compile time (e.g. when Embree returns a ray/hit packet in the <code>RTCIntersectFunctionN</code> callback function), Embree uses the <code>RTCRayHitN</code> type for ray packets. These ray/hit packets can only have sizes of 1, 4, 8, or 16. No other packet size will be used.</p>
<p>You can either implement different special code paths for each of these possible packet sizes and cast the ray/hit to the appropriate ray/hit packet type, or extract the <code>RTCRayN</code> and <code>RTCHitN</code> components using the <code>rtcGetRayN</code> and <code>rtcGetHitN</code> helper functions and use the <code>RTCRayN_XXX</code> and <code>RTCHitN_XXX</code> functions to access the ray and hit parts of the structure.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtchitn">RTCHitN</a></p>
<p></p>
<h2 id="rtcinitintersectcontext">rtcInitIntersectContext</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInitIntersectContext - initializes the intersection context</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">enum</span> RTCIntersectContextFlags
{
  RTC_INTERSECT_CONTEXT_FLAG_NONE,
  RTC_INTERSECT_CONTEXT_FLAG_INCOHERENT,
  RTC_INTERSECT_CONTEXT_FLAG_COHERENT,
};

<span class="kw">struct</span> RTCIntersectContext
{
  <span class="kw">enum</span> RTCIntersectContextFlags flags;
  RTCFilterFunctionN filter;
  <span class="dt">unsigned</span> <span class="dt">int</span> instID[RTC_MAX_INSTANCE_LEVEL_COUNT];
};

<span class="dt">void</span> rtcInitIntersectContext(
  <span class="kw">struct</span> RTCIntersectContext* context
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>A per ray-query intersection context (<code>RTCIntersectContext</code> type) is supported that can be used to configure intersection flags (<code>flags</code> member), specify a filter callback function (<code>filter</code> member), specify the ID of the current instance (<code>instID</code> member), and to attach arbitrary data to the query (e.g. per ray data).</p>
<p>The <code>rtcInitIntersectContext</code> function initializes the context to default values and should be called to initialize every intersection context. This function gets inlined, which minimizes overhead and allows for compiler optimizations.</p>
<p>The intersection context flag can be used to tune the behavior of the traversal algorithm. Using the <code>RTC_INTERSECT_CONTEXT_FLAG_INCOHERENT</code> flags uses an optimized traversal algorithm for incoherent rays (default), while <code>RTC_INTERSECT_CONTEXT_FLAG_COHERENT</code> uses an optimized traversal algorithm for coherent rays (e.g. primary camera rays).</p>
<p>Best primary ray performance can be obtained by using the ray stream API and setting the intersect context flag to <code>RTC_INTERSECT_CONTEXT_FLAG_COHERENT</code>. For secondary rays, it is typically better to use the <code>RTC_INTERSECT_CONTEXT_FLAG_INCOHERENT</code> flag, unless the rays are known to be very coherent too (e.g. for primary transparency rays).</p>
<p>A filter function can be specified inside the context. This filter function is invoked as a second filter stage after the per-geometry intersect or occluded filter function is invoked. Only rays that passed the first filter stage are valid in this second filter stage. Having such a per ray-query filter function can be useful to implement modifications of the behavior of the query, such as collecting all hits or accumulating transparencies. The support for the context filter function must be enabled for a scene by using the <code>RTC_SCENE_FLAG_CONTEXT_FILTER_FUNCTION</code> scene flag.</p>
<p>It is guaranteed that the pointer to the intersection context passed to a ray query is directly passed to the registered callback functions. This way it is possible to attach arbitrary data to the end of the intersection context, such as a per-ray payload.</p>
<p>Please note that the ray pointer is not guaranteed to be passed to the callback functions, thus reading additional data from the ray pointer passed to callbacks is not possible.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>No error code is set by this function.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersect1">rtcIntersect1</a>, <a href="#rtcoccluded1">rtcOccluded1</a></p>
<p></p>
<h2 id="rtcintersect1">rtcIntersect1</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersect1 - finds the closest hit <span class="kw">for</span> a single ray</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersect1(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit* rayhit
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersect1</code> function finds the closest hit of a single ray with the scene (<code>scene</code> argument). The provided ray/hit structure (<code>rayhit</code> argument) contains the ray to intersect and some hit output fields that are filled when a hit is found.</p>
<p>The user has to initialize the ray origin (<code>org</code> ray member), ray direction (<code>dir</code> ray member), ray segment (<code>tnear</code>, <code>tfar</code> ray members), and set the ray flags to <code>0</code> (<code>flags</code> ray member). If the scene contains motion blur geometries, also the ray time (<code>time</code> ray member) must be initialized to a value in the range <span class="math">[0, 1]</span>. If ray masks are enabled at compile time, the ray mask (<code>mask</code> ray member) must be initialized as well. The ray segment has to be in the range <span class="math">[0, ∞]</span>, thus ranges that start behind the ray origin are not valid, but ranges can reach to infinity. See Section <a href="#rtcray">RTCRay</a> for the ray layout description.</p>
<p>The instance ID (<code>instID</code> hit member) and geometry ID (<code>geomID</code> hit member) of the hit data must be initialized to <code>RTC_INVALID_GEOMETRY_ID</code> (-1).</p>
<p>Further, an intersection context for the ray query function must be created and initialized (see <code>rtcInitIntersectContext</code>).</p>
<p>When no intersection is found, the ray/hit data is not updated. When an intersection is found, the hit distance is written into the <code>tfar</code> member of the ray and all hit data is set, such as unnormalized geometry normal in object space (<code>Ng</code> hit member), local hit coordinates (<code>u</code>, <code>v</code> hit member), instance ID (<code>instID</code> hit member), geometry ID (<code>geomID</code> hit member), and primitive ID (<code>primID</code> hit member). See Section <a href="#rtchit">RTCHit</a> for the hit layout description.</p>
<p>If the instance ID was set (thus it is not equal to <code>RTC_INVALID_GEOMETRY_ID</code>), the instance ID corresponds to the geometry ID of the hit instance of the top-level scene, the geometry ID corresponds to the hit geometry inside the hit instanced scene, and the primitive ID corresponds to the n-th primitive of that geometry.</p>
<p>If the instance ID was not set (thus it is still equal to <code>RTC_INVALID_GEOMETRY_ID</code>), the geometry ID corresponds to the hit geometry inside the scene, and the primitive ID corresponds to the n-th primitive of that geometry.</p>
<p>The implementation makes no guarantees that primitives whose hit distance is exactly at (or very close to) <code>tnear</code> or <code>tfar</code> are hit or missed. If you want to exclude intersections at <code>tnear</code> just pass a slightly enlarged <code>tnear</code>, and if you want to include intersections at <code>tfar</code> pass a slightly enlarged <code>tfar</code>.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the intersection context.</p>
<p>The ray/hit structure must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded1">rtcOccluded1</a>, <a href="#rtcrayhit">RTCRayHit</a>, <a href="#rtcray">RTCRay</a>, <a href="#rtchit">RTCHit</a></p>
<p></p>
<h2 id="rtcoccluded1">rtcOccluded1</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccluded1 - finds any hit <span class="kw">for</span> a single ray</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccluded1(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay* ray
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccluded1</code> function checks for a single ray (<code>ray</code> argument) whether there is any hit with the scene (<code>scene</code> argument).</p>
<p>The user must initialize the ray origin (<code>org</code> ray member), ray direction (<code>dir</code> ray member), ray segment (<code>tnear</code>, <code>tfar</code> ray members), and must set the ray flags to <code>0</code> (<code>flags</code> ray member). If the scene contains motion blur geometries, also the ray time (<code>time</code> ray member) must be initialized to a value in the range <span class="math">[0, 1]</span>. If ray masks are enabled at compile time, the ray mask (<code>mask</code> ray member) must be initialized as well. The ray segment must be in the range <span class="math">[0, ∞]</span>, thus ranges that start behind the ray origin are not valid, but ranges can reach to infinity. See Section <a href="#rtcray">RTCRay</a> for the ray layout description.</p>
<p>When no intersection is found, the ray data is not updated. In case a hit was found, the <code>tfar</code> component of the ray is set to <code>-inf</code>.</p>
<p>The implementation makes no guarantees that primitives whose hit distance is exactly at (or very close to) <code>tnear</code> or <code>tfar</code> are hit or missed. If you want to exclude intersections at <code>tnear</code> just pass a slightly enlarged <code>tnear</code>, and if you want to include intersections at <code>tfar</code> pass a slightly enlarged <code>tfar</code>.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the intersection context.</p>
<p>The ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded1">rtcOccluded1</a>, <a href="#rtcray">RTCRay</a></p>
<p></p>
<h2 id="rtcintersect4816">rtcIntersect4/8/16</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersect4/<span class="dv">8</span>/<span class="dv">16</span> - finds the closest hits <span class="kw">for</span> a ray packet</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersect4(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit4* rayhit
);

<span class="dt">void</span> rtcIntersect8(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit8* rayhit
);

<span class="dt">void</span> rtcIntersect16(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit16* rayhit
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersect4/8/16</code> functions finds the closest hits for a ray packet of size 4, 8, or 16 (<code>rayhit</code> argument) with the scene (<code>scene</code> argument). The ray/hit input contains a ray packet and hit packet. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace rays.</p>
<p>A ray valid mask must be provided (<code>valid</code> argument) which stores one 32-bit integer (<code>-1</code> means valid and <code>0</code> invalid) per ray in the packet. Only active rays are processed, and hit data of inactive rays is not changed.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the intersection context.</p>
<p>The implementation of these functions is guaranteed to invoke callback functions always with the same ray packet size and ordering of rays as specified initially.</p>
<p>For <code>rtcIntersect4</code> the ray packet must be aligned to 16 bytes, for <code>rtcIntersect8</code> the alignment must be 32 bytes, and for <code>rtcIntersect16</code> the alignment must be 64 bytes.</p>
<p>Further, <code>rtcIntersect4</code> is only available when Embree was compiled with <code>EMBREE_RAY_PACKETS</code> turned on in CMake (which is the default). Further, the <code>rtcIntersect8</code> function works only if Embree was compiled with <code>AVX</code> or <code>AVX2</code>, and if the CPU it is running on supports the enabled ISA. Similar, the <code>rtcIntersect16</code> function works only if Embree was compiled with <code>AVX512SKX</code> or <code>AVX512KNL</code> and the CPU it is running on supports the enabled ISA. For this reason, use these functions only after checking whether they are available by using an <code>rtcGetDeviceParameter</code> query.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded4816">rtcOccluded4/8/16</a></p>
<p></p>
<h2 id="rtcoccluded4816">rtcOccluded4/8/16</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccluded4/<span class="dv">8</span>/<span class="dv">16</span> - finds any hits <span class="kw">for</span> a ray packet</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccluded4(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay4* ray
);

<span class="dt">void</span> rtcOccluded8(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay8* ray
);

<span class="dt">void</span> rtcOccluded16(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay16* ray
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccluded4/8/16</code> functions checks for each active ray of the ray packet of size 4, 8, or 16 (<code>ray</code> argument) whether there is any hit with the scene (<code>scene</code> argument). See Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace occlusion rays.</p>
<p>A ray valid mask must be provided (<code>valid</code> argument) which stores one 32-bit integer (<code>-1</code> means valid and <code>0</code> invalid) per ray in the packet. Only active rays are processed, and hit data of inactive rays is not changed.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the intersection context.</p>
<p>The implementation of these functions is guaranteed to invoke callback functions always with the same ray packet size and ordering of rays as specified initially.</p>
<p>For <code>rtcOccluded4</code> the ray packet must be aligned to 16 bytes, for <code>rtcOccluded8</code> the alignment must be 32 bytes, and for <code>rtcOccluded16</code> the alignment must be 64 bytes.</p>
<p>Further, <code>rtcOccluded4</code> is only available when Embree was compiled with <code>EMBREE_RAY_PACKETS</code> turned on in CMake (which is the default). Further, the <code>rtcOccluded8</code> function is works only if Embree was compiled with <code>AVX</code> or <code>AVX2</code> and the CPU it is running on supports the enabled ISA. Similar, the <code>rtcOccluded16</code> function works only if Embree was compiled with <code>AVX512SKX</code> or <code>AVX512KNL</code> and the CPU it is running on supports the enabled ISA. For this reason, use these functions only after checking whether they are available by using an <code>rtcGetDeviceParameter</code> query.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded4816">rtcOccluded4/8/16</a></p>
<p></p>
<h2 id="rtcintersect1m">rtcIntersect1M</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersect1M - finds the closest hits <span class="kw">for</span> a stream of M single
  rays</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersect1M(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit* rayhit,
  <span class="dt">unsigned</span> <span class="dt">int</span> M,
  size_t byteStride
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersect1M</code> function finds the closest hits for a stream of <code>M</code> single rays (<code>rayhit</code> argument) with the scene (<code>scene</code> argument). The <code>rayhit</code> argument points to an array of ray and hit data with specified byte stride (<code>byteStride</code> argument) between the ray/hit structures. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded1m">rtcOccluded1M</a></p>
<p></p>
<h2 id="rtcoccluded1m">rtcOccluded1M</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccluded1M - finds any hits <span class="kw">for</span> a stream of M single rays</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccluded1M(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay* ray,
  <span class="dt">unsigned</span> <span class="dt">int</span> M,
  size_t byteStride
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccluded1M</code> function checks whether there are any hits for a stream of <code>M</code> single rays (<code>ray</code> argument) with the scene (<code>scene</code> argument). The <code>ray</code> argument points to an array of rays with specified byte stride (<code>byteStride</code> argument) between the rays. See Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace occlusion rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersect1m">rtcIntersect1M</a></p>
<p></p>
<h2 id="rtcintersect1mp">rtcIntersect1Mp</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersect1Mp - finds the closest hits <span class="kw">for</span> a stream of M pointers
  to single rays</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersect1Mp(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit** rayhit,
  <span class="dt">unsigned</span> <span class="dt">int</span> M
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersect1Mp</code> function finds the closest hits for a stream of <code>M</code> single rays (<code>rayhit</code> argument) with the scene (<code>scene</code> argument). The <code>rayhit</code> argument points to an array of pointers to the individual ray/hit structures. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace a ray.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded1mp">rtcOccluded1Mp</a></p>
<p></p>
<h2 id="rtcoccluded1mp">rtcOccluded1Mp</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccluded1Mp - find any hits <span class="kw">for</span> a stream of M pointers to
  single rays</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccluded1M(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay** ray,
  <span class="dt">unsigned</span> <span class="dt">int</span> M
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccluded1Mp</code> function checks whether there are any hits for a stream of <code>M</code> single rays (<code>ray</code> argument) with the scene (<code>scene</code> argument). The <code>ray</code> argument points to an array of pointers to rays. Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace a occlusion rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersect1mp">rtcIntersect1Mp</a></p>
<p></p>
<h2 id="rtcintersectnm">rtcIntersectNM</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersectNM - finds the closest hits <span class="kw">for</span> a stream of M
  ray packets of size N</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersectNM(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHitN* rayhit,
  <span class="dt">unsigned</span> <span class="dt">int</span> N,
  <span class="dt">unsigned</span> <span class="dt">int</span> M,
  size_t byteStride
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersectNM</code> function finds the closest hits for a stream of <code>M</code> ray packets (<code>rayhit</code> argument) of size <code>N</code> with the scene (<code>scene</code> argument). The <code>rays</code> argument points to an array of ray and hit packets with specified byte stride (<code>byteStride</code> argument) between the ray/hit packets. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The packet size <code>N</code> must be larger than 0, and the stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccludednm">rtcOccludedNM</a></p>
<p></p>
<h2 id="rtcoccludednm">rtcOccludedNM</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccludedNM - finds any hits <span class="kw">for</span> a stream of M ray packets of
  size N</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccludedNM(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayN* ray,
  <span class="dt">unsigned</span> <span class="dt">int</span> N,
  <span class="dt">unsigned</span> <span class="dt">int</span> M,
  size_t byteStride
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccludedNM</code> function checks whether there are any hits for a stream of <code>M</code> ray packets (<code>ray</code> argument) of size <code>N</code> with the scene (<code>scene</code> argument). The <code>ray</code> argument points to an array of ray packets with specified byte stride (<code>byteStride</code> argument) between the ray packets. See Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace occlusion rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The packet size <code>N</code> must be larger than 0, and the stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersectnm">rtcIntersectNM</a></p>
<p></p>
<h2 id="rtcintersectnp">rtcIntersectNp</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersectNp - finds the closest hits <span class="kw">for</span> a SOA ray stream of
  size N</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersectNp(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHitNp* rayhit,
  <span class="dt">unsigned</span> <span class="dt">int</span> N
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersectNp</code> function finds the closest hits for a SOA ray stream (<code>rays</code> argument) of size <code>N</code> (basically a large ray packet) with the scene (<code>scene</code> argument). The <code>rayhit</code> argument points to two structures of pointers with one pointer for each ray and hit component. Each of these pointers points to an array with the ray or hit component data for each ray or hit. This way the individual components of the SOA ray stream do not need to be stored sequentially in memory, which makes it possible to have large varying size ray packets in SOA layout. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>N</code> can be an arbitrary positive integer including 0. Each ray component array must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccludednp">rtcOccludedNp</a></p>
<p></p>
<h2 id="rtcoccludednp">rtcOccludedNp</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccludedNp - finds any hits <span class="kw">for</span> a SOA ray stream of size N</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccludedNp(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayNp* ray,
  <span class="dt">unsigned</span> <span class="dt">int</span> N
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccludedNp</code> function checks whether there are any hits for a SOA ray stream (<code>ray</code> argument) of size <code>N</code> (basically a large ray packet) with the scene (<code>scene</code> argument). The <code>ray</code> argument points to a structure of pointers with one pointer for each ray component. Each of these pointers points to an array with the ray component data for each ray. This way the individual components of the SOA ray stream do not need to be stored sequentially in memory, which makes it possible to have large varying size ray packets in SOA layout. See Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace occlusion rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>N</code> can be an arbitrary positive integer including 0. Each ray component array must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersectnp">rtcIntersectNp</a></p>
<p></p>
<h2 id="rtcnewbvh">rtcNewBVH</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewBVH - creates a <span class="kw">new</span> BVH object</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCBVH rtcNewBVH(RTCDevice device);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>This function creates a new BVH object and returns a handle to this BVH. The BVH object is reference counted with an initial reference count of 1. The handle can be released using the <code>rtcReleaseBVH</code> API call.</p>
<p>The BVH object can be used to build a BVH in a user-specified format over user-specified primitives. See the documentation of the <code>rtcBuildBVH</code> call for more details.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretainbvh">rtcRetainBVH</a>, <a href="#rtcreleasebvh">rtcReleaseBVH</a>, <a href="#rtcbuildbvh">rtcBuildBVH</a></p>
<p></p>
<h2 id="rtcretainbvh">rtcRetainBVH</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainBVH - increments the BVH reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainBVH(RTCBVH bvh);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>BVH objects are reference counted. The <code>rtcRetainBVH</code> function increments the reference count of the passed BVH object (<code>bvh</code> argument). This function together with <code>rtcReleaseBVH</code> allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbvh">rtcNewBVH</a>, <a href="#rtcreleasebvh">rtcReleaseBVH</a></p>
<p></p>
<h2 id="rtcreleasebvh">rtcReleaseBVH</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseBVH - decrements the BVH reference count</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseBVH(RTCBVH bvh);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>BVH objects are reference counted. The <code>rtcReleaseBVH</code> function decrements the reference count of the passed BVH object (<code>bvh</code> argument). When the reference count falls to 0, the BVH gets destroyed.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbvh">rtcNewBVH</a>, <a href="#rtcretainbvh">rtcRetainBVH</a></p>
<p></p>
<h2 id="rtcbuildbvh">rtcBuildBVH</h2>
<h4 id="name">NAME</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcBuildBVH - builds a BVH</code></pre>
<h4 id="synopsis">SYNOPSIS</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTC_ALIGN(<span class="dv">32</span>) RTCBuildPrimitive
{
  <span class="dt">float</span> lower_x, lower_y, lower_z; 
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID;
  <span class="dt">float</span> upper_x, upper_y, upper_z;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
};

<span class="kw">typedef</span> <span class="dt">void</span>* (*RTCCreateNodeFunction) (
  RTCThreadLocalAllocator allocator,
  <span class="dt">unsigned</span> <span class="dt">int</span> childCount,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCSetNodeChildrenFunction) (
  <span class="dt">void</span>* nodePtr,
  <span class="dt">void</span>** children,
  <span class="dt">unsigned</span> <span class="dt">int</span> childCount,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCSetNodeBoundsFunction) (
  <span class="dt">void</span>* nodePtr,
  <span class="dt">const</span> <span class="kw">struct</span> RTCBounds** bounds,
  <span class="dt">unsigned</span> <span class="dt">int</span> childCount,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">void</span>* (*RTCCreateLeafFunction) (
  RTCThreadLocalAllocator allocator,
  <span class="dt">const</span> <span class="kw">struct</span> RTCBuildPrimitive* primitives,
  size_t primitiveCount,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCSplitPrimitiveFunction) (
  <span class="dt">const</span> <span class="kw">struct</span> RTCBuildPrimitive* primitive,
  <span class="dt">unsigned</span> <span class="dt">int</span> dimension,
  <span class="dt">float</span> position,
  <span class="kw">struct</span> RTCBounds* leftBounds,
  <span class="kw">struct</span> RTCBounds* rightBounds,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">bool</span> (*RTCProgressMonitorFunction)(
  <span class="dt">void</span>* userPtr, <span class="dt">double</span> n
);

<span class="kw">enum</span> RTCBuildFlags
{
  RTC_BUILD_FLAG_NONE,
  RTC_BUILD_FLAG_DYNAMIC
};

<span class="kw">struct</span> RTCBuildArguments
{
  size_t byteSize;

  <span class="kw">enum</span> RTCBuildQuality buildQuality;
  <span class="kw">enum</span> RTCBuildFlags buildFlags;
  <span class="dt">unsigned</span> <span class="dt">int</span> maxBranchingFactor;
  <span class="dt">unsigned</span> <span class="dt">int</span> maxDepth;
  <span class="dt">unsigned</span> <span class="dt">int</span> sahBlockSize;
  <span class="dt">unsigned</span> <span class="dt">int</span> minLeafSize;
  <span class="dt">unsigned</span> <span class="dt">int</span> maxLeafSize;
  <span class="dt">float</span> traversalCost;
  <span class="dt">float</span> intersectionCost;

  RTCBVH bvh;
  <span class="kw">struct</span> RTCBuildPrimitive* primitives;
  size_t primitiveCount;
  size_t primitiveArrayCapacity;
  
  RTCCreateNodeFunction createNode;
  RTCSetNodeChildrenFunction setNodeChildren;
  RTCSetNodeBoundsFunction setNodeBounds;
  RTCCreateLeafFunction createLeaf;
  RTCSplitPrimitiveFunction splitPrimitive;
  RTCProgressMonitorFunction buildProgress;
  <span class="dt">void</span>* userPtr;
};

<span class="kw">struct</span> RTCBuildArguments rtcDefaultBuildArguments();

<span class="dt">void</span>* rtcBuildBVH(
  <span class="dt">const</span> <span class="kw">struct</span> RTCBuildArguments* args
);</code></pre>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcBuildBVH</code> function can be used to build a BVH in a user-defined format over arbitrary primitives. All arguments to the function are provided through the <code>RTCBuildArguments</code> structure. The first member of that structure must be set to the size of the structure in bytes (<code>bytesSize</code> member) which allows future extensions of the structure. It is recommended to initialize the build arguments structure using the <code>rtcDefaultBuildArguments</code> function.</p>
<p>The <code>rtcBuildBVH</code> function gets passed the BVH to build (<code>bvh</code> member), the array of primitives (<code>primitives</code> member), the capacity of that array (<code>primitiveArrayCapacity</code> member), the number of primitives stored inside the array (<code>primitiveCount</code> member), callback function pointers, and a user-defined pointer (<code>userPtr</code> member) that is passed to all callback functions when invoked. The <code>primitives</code> array can be freed by the application after the BVH is built. All callback functions are typically called from multiple threads, thus their implementation must be thread-safe.</p>
<p>Four callback functions must be registered, which are invoked during build to create BVH nodes (<code>createNode</code> member), to set the pointers to all children (<code>setNodeChildren</code> member), to set the bounding boxes of all children (<code>setNodeBounds</code> member), and to create a leaf node (<code>createLeaf</code> member).</p>
<p>The function pointer to the primitive split function (<code>splitPrimitive</code> member) may be <code>NULL</code>, however, then no spatial splitting in high quality mode is possible. The function pointer used to report the build progress (<code>buildProgress</code> member) is optional and may also be <code>NULL</code>.</p>
<p>Further, some build settings are passed to configure the BVH build. Using the build quality settings (<code>buildQuality</code> member), one can select between a faster, low quality build which is good for dynamic scenes, and a standard quality build for static scenes. One can also specify the desired maximum branching factor of the BVH (<code>maxBranchingFactor</code> member), the maximum depth the BVH should have (<code>maxDepth</code> member), the block size for the SAH heuristic (<code>sahBlockSize</code> member), the minimum and maximum leaf size (<code>minLeafSize</code> and <code>maxLeafSize</code> member), and the estimated costs of one traversal step and one primitive intersection (<code>traversalCost</code> and <code>intersectionCost</code> members). When enabling the <code>RTC_BUILD_FLAG_DYNAMIC</code> build flags (<code>buildFlags</code> member), re-build performance for dynamic scenes is improved at the cost of higher memory requirements.</p>
<p>To spatially split primitives in high quality mode, the builder needs extra space at the end of the build primitive array to store splitted primitives. The total capacity of the build primitive array is passed using the <code>primitiveArrayCapacity</code> member, and should be about twice the number of primitives when using spatial splits.</p>
<p>The <code>RTCCreateNodeFunc</code> and <code>RTCCreateLeafFunc</code> callbacks are passed a thread local allocator object that should be used for fast allocation of nodes using the <code>rtcThreadLocalAlloc</code> function. We strongly recommend using this allocation mechanism, as alternative approaches like standard <code>malloc</code> can be over 10× slower. The allocator object passed to the create callbacks may be used only inside the current thread. Memory allocated using <code>rtcThreadLocalAlloc</code> is automatically freed when the <code>RTCBVH</code> object is deleted. If you use your own memory allocation scheme you have to free the memory yourself when the <code>RTCBVH</code> object is no longer used.</p>
<p>The <code>RTCCreateNodeFunc</code> callback additionally gets the number of children for this node in the range from 2 to <code>maxBranchingFactor</code> (<code>childCount</code> argument).</p>
<p>The <code>RTCSetNodeChildFunc</code> callback function gets a pointer to the node as input (<code>nodePtr</code> argument), an array of pointers to the children (<code>childPtrs</code> argument), and the size of this array (<code>childCount</code> argument).</p>
<p>The <code>RTCSetNodeBoundsFunc</code> callback function gets a pointer to the node as input (<code>nodePtr</code> argument), an array of pointers to the bounding boxes of the children (<code>bounds</code> argument), and the size of this array (<code>childCount</code> argument).</p>
<p>The <code>RTCCreateLeafFunc</code> callback additionally gets an array of primitives as input (<code>primitives</code> argument), and the size of this array (<code>primitiveCount</code> argument). The callback should read the <code>geomID</code> and <code>primID</code> members from the passed primitives to construct the leaf.</p>
<p>The <code>RTCSplitPrimitiveFunc</code> callback is invoked in high quality mode to split a primitive (<code>primitive</code> argument) at the specified position (<code>position</code> argument) and dimension (<code>dimension</code> argument). The callback should return bounds of the clipped left and right parts of the primitive (<code>leftBounds</code> and <code>rightBounds</code> arguments).</p>
<p>The <code>RTCProgressMonitorFunction</code> callback function is called with the estimated completion rate <code>n</code> in the range <span class="math">[0, 1]</span>. Returning <code>true</code> from the callback lets the build continue; returning <code>false</code> cancels the build.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcDeviceGetError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbvh">rtcNewBVH</a></p>
<p></p>
<h1 id="performance-recommendations">Performance Recommendations</h1>
<h2 id="mxcsr-control-and-status-register">MXCSR control and status register</h2>
<p>It is strongly recommended to have the <code>Flush to Zero</code> and <code>Denormals are Zero</code> mode of the MXCSR control and status register enabled for each thread before calling the <code>rtcIntersect</code>-type and <code>rtcOccluded</code>-type functions. Otherwise, under some circumstances special handling of denormalized floating point numbers can significantly reduce application and Embree performance. When using Embree together with the Intel® Threading Building Blocks, it is sufficient to execute the following code at the beginning of the application main thread (before the creation of the <code>tbb::task_scheduler_init</code> object):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;xmmintrin.h&gt;</span>
<span class="ot">#include &lt;pmmintrin.h&gt;</span>
...
_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
_MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);</code></pre>
<p>If using a different tasking system, make sure each rendering thread has the proper mode set.</p>
<h2 id="thread-creation-and-affinity-settings">Thread Creation and Affinity Settings</h2>
<p>Tasking systems like TBB create worker threads on demand, which will add a runtime overhead for the very first <code>rtcCommitScene</code> call. In case you want to benchmark the scene build time, you should start the threads at application startup. You can let Embree start TBB threads by passing <code>start_threads=1</code> to the <code>cfg</code> parameter of <code>rtcNewDevice</code>.</p>
<p>On machines with a high thread count (e.g. dual-socket Xeon or Xeon Phi machines), affinitizing TBB worker threads increases build and rendering performance. You can let Embree affinitize TBB worker threads by passing <code>set_affinity=1</code> to the <code>cfg</code> parameter of <code>rtcNewDevice</code>. By default, threads are not affinitized by Embree with the exception of Xeon Phi Processors where they are affinitized by default.</p>
<p>All Embree tutorials automatically start and affinitize TBB worker threads by passing <code>start_threads=1,set_affinity=1</code> to <code>rtcNewDevice</code>.</p>
<h2 id="fast-coherent-rays">Fast Coherent Rays</h2>
<p>For getting the highest performance for highly coherent rays, e.g. primary or hard shadow rays, it is recommended to use packets or streams of single rays/packets with setting the <code>RTC_INTERSECT_CONTEXT_FLAG_COHERENT</code> flag in the <code>RTCIntersectContext</code> passed to the <code>rtcIntersect</code>/<code>rtcOccluded</code> calls. The total number of rays in a coherent stream of ray packets should be around 64, e.g. 8 times 8-wide packets, or 4 times 16-wide packets. The rays inside each packet should be grouped as coherent as possible.</p>
<h2 id="huge-page-support">Huge Page Support</h2>
<p>It is recommended to use huge pages under Linux to increase rendering performance. Embree supports 2MB huge pages under Windows, Linux, and macOS. Under Linux huge page support is enabled by default, and under Windows and macOS disabled by default. Huge page support can be enabled in Embree by passing <code>hugepages=1</code> to <code>rtcNewDevice</code> or disabled by passing <code>hugepages=0</code> to <code>rtcNewDevice</code>.</p>
<p>We recommend using 2MB huge pages with Embree under Linux as this improves ray tracing performance by about 5-10%. Under Windows using huge pages requires the application to run in elevated mode which is a security issue, thus likely not an option for most use cases. Under macOS huge pages are rarely available as memory tends to get quickly fragmented, thus we do not recommend using huge pages on macOS.</p>
<h3 id="huge-pages-under-linux">Huge Pages under Linux</h3>
<p>Linux supports transparent huge pages and explicit huge pages. To enable transparent huge page support under Linux, execute the following as root:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">echo always &gt; /sys/kernel/mm/transparent_hugepage/enabled</code></pre>
<p>When transparent huge pages are enabled, the kernel tries to merge 4KB pages to 2MB pages when possible as a background job. Many Linux distributions have transparent huge pages enabled by default. See the following webpage for more information on <a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt">transparent huge pages under Linux</a>. In this mode each application, including your rendering application based on Embree, will automatically tend to use huge pages.</p>
<p>Using transparent huge pages, the transitioning from 4KB to 2MB pages might take some time. For that reason Embree also supports allocating 2MB pages directly when a huge page pool is configured. Such a pool can be configured by writing some number of huge pages to allocate to <code>/proc/sys/vm/nr_overcommit_hugepages</code> as root user. E.g. to configure 2GB of address space for huge page allocation, execute the following as root:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">echo <span class="dv">1000</span> &gt; /proc/sys/vm/nr_overcommit_hugepages</code></pre>
<p>See the following webpage for more information on <a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">huge pages under Linux</a>.</p>
<h3 id="huge-pages-under-windows">Huge Pages under Windows</h3>
<p>To use huge pages under Windows, the current user must have the “Lock pages in memory” (SeLockMemoryPrivilege) assigned. This can be configured through the “Local Security Policy” application, by adding a user to “Local Policies” -&gt; “User Rights Assignment” -&gt; “Lock pages in memory”. You have to log out and in again for this change to take effect.</p>
<p>Further, your application must be executed as an elevated process (“Run as administrator”) and the “SeLockMemoryPrivilege” must be explicitly enabled by your application. Example code on how to enable this privilege can be found in the “common/sys/alloc.cpp” file of Embree. Alternatively, Embree will try to enable this privilege when passing <code>enable_selockmemoryprivilege=1</code> to <code>rtcNewDevice</code>. Further, huge pages should be enabled in Embree by passing <code>hugepages=1</code> to <code>rtcNewDevice</code>.</p>
<p>When the system has been running for a while, physical memory gets fragmented, which can slow down the allocation of huge pages significantly under Windows.</p>
<h3 id="huge-pages-under-macos">Huge Pages under macOS</h3>
<p>To use huge pages under macOS you have to pass <code>hugepages=1</code> to <code>rtcNewDevice</code> to enable that feature in Embree.</p>
<p>When the system has been running for a while, physical memory gets quickly fragmented, and causes huge page allocations to fail. For this reason, huge pages are not very useful under macOS in practice.</p>
<h2 id="avoid-store-to-load-forwarding-issues-with-single-rays">Avoid store-to-load forwarding issues with single rays</h2>
<p>We recommend to use a single SSE store to set up the <code>org</code> and <code>tnear</code> components, and a single SSE store to set up the <code>dir</code> and <code>time</code> components of a single ray (<code>RTCRay</code> type). Storing these values using scalar stores causes a store-to-load forwarding penalty because Embree is reading these components using SSE loads later on.</p>
      </div>

      <div id="footer">
        © 2009–2017 Intel Corporation <a href="legal.html">Disclaimer and Legal Information</a>
      </div>
    </div>
  </body>
</html>
