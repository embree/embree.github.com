<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Embree: High Performance Ray Tracing Kernels" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <title>Embree</title>
    <link rel="icon" type="image/png" href="images/icon192.png" sizes="192x192">
    <link rel="SHORTCUT ICON" HREF="images/icon32.ico">
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
div.sourceCode { overflow-x: initial; }
    </style>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-64541910-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <div class="inner">
        <a id="forkme_banner" href="https://github.com/embree">View on GitHub</a>
        <h1 id="project_title">Embree</h1>
        <h2 id="project_tagline">High Performance Ray Tracing Kernels</h2>
      </div>

      <div id="nav">
      <div id="nbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
          <li><a href="downloads.html">Downloads</a></li>
          <li id="selected"><a href="api.html">API</a></li>
          <li><a href="tutorials.html">Tutorials</a></li>
          <li><a href="gallery.html">Gallery</a></li>
          <li><a href="related.html">Related Projects</a></li>
        </ul>
      </div>
      </div>

    </div>

    <a id="news_banner" href="https://github.com/embree/embree/releases">
      We recently released Embree v2.17.0!
    </a>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <div id="main_content" class="inner">
<h1 id="embree-api">Embree API</h1>
<p>The Embree API is a low level ray tracing API that supports defining and committing of geometry and performing ray queries of different types. Static and dynamic scenes are supported, that may contain triangle geometries, quad geometries, line segment geometries, hair geometries, analytic bezier curves, subdivision meshes, instanced geometries, and user defined geometries. For each geometry type multi-segment motion blur is supported, including support for transformation motion blur of instances. Supported ray queries are, finding the closest scene intersection along a ray, and testing a ray segment for any intersection with the scene. Single rays, as well as packets of rays in a struct of array layout can be used for packet sizes of 1, 4, 8, and 16 rays. Using the ray stream interface a stream of an arbitrary number <code>M</code> of ray packets of arbitrary size <code>N</code> can be processed. Filter callback functions are supported, that get invoked for every intersection encountered during traversal.</p>
<p>The Embree API exists in a C++ and ISPC version. This document describes the C++ version of the API, the ISPC version is almost identical. The only differences are that the ISPC version needs some ISPC specific <code>uniform</code> type modifiers, and has special functions that operate on ray packets of the native SIMD size the ISPC code is compiled for.</p>
<p>Embree supports two modes for a scene, the <code>normal mode</code> and <code>stream mode</code>, which require different ray queries and callbacks to be used. The <code>normal mode</code> is the default, but we will switch entirely to the ray <code>stream mode</code> in a later release.</p>
<p>The user is supposed to include the <code>embree2/rtcore.h</code>, and the <code>embree2/rtcore_ray.h</code> file, but none of the other header files. If using the ISPC version of the API, the user should include <code>embree2/rtcore.isph</code> and <code>embree2/rtcore_ray.isph</code>.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree2/rtcore.h&gt;</span>
<span class="ot">#include &lt;embree2/rtcore_ray.h&gt;</span></code></pre>
<p>All API calls carry the prefix <code>rtc</code> which stands for <strong>r</strong>ay <strong>t</strong>racing <strong>c</strong>ore. Embree supports a device concept, which allows different components of the application to use the API without interfering with each other. You have to create at least one Embree device through the <code>rtcNewDevice</code> call. Before the application exits it should delete all devices by invoking <code>rtcDeleteDevice</code>. An application typically creates a single device only, and should create only a small number of devices.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCDevice device = rtcNewDevice(NULL);
...
rtcDeleteDevice(device);</code></pre>
<p>It is strongly recommended to have the <code>Flush to Zero</code> and <code>Denormals are Zero</code> mode of the MXCSR control and status register enabled for each thread before calling the <code>rtcIntersect</code> and <code>rtcOccluded</code> functions. Otherwise, under some circumstances special handling of denormalized floating point numbers can significantly reduce application and Embree performance. When using Embree together with the Intel® Threading Building Blocks, it is sufficient to execute the following code at the beginning of the application main thread (before the creation of the <code>tbb::task_scheduler_init</code> object):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;xmmintrin.h&gt;</span>
<span class="ot">#include &lt;pmmintrin.h&gt;</span>
...
_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
_MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);</code></pre>
<p>Embree processes some implementation specific configuration from the following locations in the specified order:</p>
<ol style="list-style-type: decimal">
<li>configuration string passed to the <code>rtcNewDevice</code> function</li>
<li><code>.embree2</code> file in the application folder</li>
<li><code>.embree2</code> file in the home folder</li>
</ol>
<p>Settings performed later overwrite previous settings. This way the configuration for the application can be changed globally (either through the <code>rtcNewDevice</code> call or through the <code>.embree2</code> file in the application folder) and each user has the option to modify the configuration to fit its needs. Configuration files can be ignored by the application by passing <code>ignore_config_files=1</code> to <code>rtcNewDevice</code>.</p>
<p>API calls that access geometries are only thread safe as long as different geometries are accessed. Accesses to one geometry have to get sequenced by the application. All other API calls are thread safe. The API calls are re-entrant, it is thus safe to trace new rays and create new geometry when intersecting a user defined object.</p>
<p>Each user thread has its own error flag per device. If an error occurs when invoking some API function, this flag is set to an error code if it stores no previous error. The <code>rtcDeviceGetError</code> function reads and returns the currently stored error and clears the error flag again.</p>
<p>Possible error codes returned by <code>rtcDeviceGetError</code> are:</p>
<table>
<caption>Return values of <code>rtcDeviceGetError</code>.</caption>
<colgroup>
<col width="33%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Error Code</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_NO_ERROR</td>
<td align="left">No error occurred.</td>
</tr>
<tr class="even">
<td align="left">RTC_UNKNOWN_ERROR</td>
<td align="left">An unknown error has occurred.</td>
</tr>
<tr class="odd">
<td align="left">RTC_INVALID_ARGUMENT</td>
<td align="left">An invalid argument was specified.</td>
</tr>
<tr class="even">
<td align="left">RTC_INVALID_OPERATION</td>
<td align="left">The operation is not allowed for the specified object.</td>
</tr>
<tr class="odd">
<td align="left">RTC_OUT_OF_MEMORY</td>
<td align="left">There is not enough memory left to complete the operation.</td>
</tr>
<tr class="even">
<td align="left">RTC_UNSUPPORTED_CPU</td>
<td align="left">The CPU is not supported as it does not support SSE2.</td>
</tr>
<tr class="odd">
<td align="left">RTC_CANCELLED</td>
<td align="left">The operation got cancelled by an Memory Monitor Callback or Progress Monitor Callback function.</td>
</tr>
</tbody>
</table>
<p>When the device construction fails <code>rtcNewDevice</code> returns <code>NULL</code> as device. To detect the error code of a such a failed device construction pass <code>NULL</code> as device to the <code>rtcDeviceGetError</code> function. For all other invokations of <code>rtcDeviceGetError</code> a proper device pointer has to get specified.</p>
<p>Using the <code>rtcDeviceSetErrorFunction2</code> call, it is also possible to set a callback function that is called whenever an error occurs for a device.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*RTCErrorFunc2)(<span class="dt">void</span>* userPtr, <span class="dt">const</span> RTCError, <span class="dt">const</span> <span class="dt">char</span>* str);
<span class="dt">void</span> rtcDeviceSetErrorFunction2(RTCDevice, RTCErrorFunc2, <span class="dt">void</span>* userPtr);</code></pre>
<p>When invoked, the registered callback function gets passed a user defined pointer <code>userPtr</code>, the error code <code>code</code>, as well as some string <code>str</code> that describes the error further. Passing <code>NULL</code> as function pointer to <code>rtcDeviceSetErrorFunction2</code> disables the set callback function again. The previously described error flags are also set if an error callback function is present.</p>
<p>Arrays and buffers passed to Embree in most cases have strict alignment and padding requirements to facilitate efficient SIMD processing. The required alignment and padding vary between 16 and 64 bytes, depending on the actual function and data type.</p>
<h2 id="scene">Scene</h2>
<p>A scene is a container for a set of geometries of potentially different types. A scene is created using the <code>rtcDeviceNewScene</code> function call, and destroyed using the <code>rtcDeleteScene</code> function call. Two types of scenes are supported, dynamic and static scenes. Different flags specify the type of scene to create and the type of ray query operations that can later be performed on the scene. The following example creates a scene that supports dynamic updates and the single ray <code>rtcIntersect</code> and <code>rtcOccluded</code> calls.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCScene scene = rtcDeviceNewScene(device, RTC_SCENE_DYNAMIC, RTC_INTERSECT1);
...
rtcDeleteScene(scene);</code></pre>
<p>Using the following scene flags the user can select between creating a static or dynamic scene.</p>
<table>
<caption>Dynamic type flags for <code>rtcDeviceNewScene</code>.</caption>
<thead>
<tr class="header">
<th align="left">Scene Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SCENE_STATIC</td>
<td align="left">Scene is optimized for static geometry.</td>
</tr>
<tr class="even">
<td align="left">RTC_SCENE_DYNAMIC</td>
<td align="left">Scene is optimized for dynamic geometry.</td>
</tr>
</tbody>
</table>
<p>A dynamic scene is created by invoking <code>rtcDeviceNewScene</code> with the <code>RTC_SCENE_DYNAMIC</code> flag. Different geometries can now be created inside that scene. Geometries are enabled by default. Once the scene geometry is specified, an <code>rtcCommit</code> call will finish the scene description and trigger building of internal data structures. After the <code>rtcCommit</code> call it is safe to perform ray queries of the type specified at scene construction time. Geometries can get disabled (<code>rtcDisable</code> call), enabled again (<code>rtcEnable</code> call), and deleted (<code>rtcDeleteGeometry</code> call). Geometries can also get modified, including their vertex and index arrays. After the modification of some geometry, <code>rtcUpdate</code> or <code>rtcUpdateBuffer</code> has to get called for that geometry to specify which buffers got modified. Each modified buffer can be specified separately using the <code>rtcUpdateBuffer</code> function. In contrast the <code>rtcUpdate</code> function simply tags each buffer of some geometry as modified. If geometries got enabled, disabled, deleted, or modified an <code>rtcCommit</code> call has to get invoked before performing any ray queries for the scene, otherwise the effect of the ray query is undefined. During an <code>rtcCommit</code> call modifications to the scene are not allowed.</p>
<p>A static scene is created by the <code>rtcDeviceNewScene</code> call with the <code>RTC_SCENE_STATIC</code> flag. Geometries can only get created, enabled, disabled and modified until the first <code>rtcCommit</code> call. After the <code>rtcCommit</code> call, each access to any geometry of that static scene is invalid. Geometries that got created inside a static scene can only get deleted by deleting the entire scene.</p>
<p>The modification of geometry, building of hierarchies using <code>rtcCommit</code>, and tracing of rays have always to happen separately, never at the same time.</p>
<p>Embree silently ignores primitives that would cause numerical issues, e.g. primitives containing NaNs, INFs, or values greater than 1.844E18f.</p>
<p>The following flags can be used to tune the used acceleration structure. These flags are only hints and may be ignored by the implementation.</p>
<table>
<caption>Acceleration structure flags for <code>rtcDeviceNewScene</code>.</caption>
<colgroup>
<col width="34%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Scene Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SCENE_COMPACT</td>
<td align="left">Creates a compact data structure and avoids algorithms that consume much memory.</td>
</tr>
<tr class="even">
<td align="left">RTC_SCENE_COHERENT</td>
<td align="left">Optimize for coherent rays (e.g. primary rays).</td>
</tr>
<tr class="odd">
<td align="left">RTC_SCENE_INCOHERENT</td>
<td align="left">Optimize for in-coherent rays (e.g. diffuse reflection rays).</td>
</tr>
<tr class="even">
<td align="left">RTC_SCENE_HIGH_QUALITY</td>
<td align="left">Build higher quality spatial data structures.</td>
</tr>
</tbody>
</table>
<p>The following flags can be used to tune the traversal algorithm that is used by Embree. These flags are only hints and may be ignored by the implementation.</p>
<table>
<caption>Traversal algorithm flags for <code>rtcDeviceNewScene</code>.</caption>
<thead>
<tr class="header">
<th align="left">Scene Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SCENE_ROBUST</td>
<td align="left">Avoid optimizations that reduce arithmetic accuracy.</td>
</tr>
</tbody>
</table>
<p>The second argument of the <code>rtcDeviceNewScene</code> function are algorithm flags, that allow to specify which ray queries are required by the application. Calling a ray query API function for a scene that is different to the ones specified at scene creation time is not allowed. Further, the application should only pass ray query requirements that are really needed, to give Embree most freedom in choosing the best algorithm. E.g. in case Embree implements no packet traversers for some highly optimized data structure for single rays, then this data structure cannot be used if the user enables any ray packet query.</p>
<table>
<caption>Enabled algorithm flags for <code>rtcDeviceNewScene</code>.</caption>
<colgroup>
<col width="28%" />
<col width="68%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Algorithm Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_INTERSECT1</td>
<td align="left">Enables the <code>rtcIntersect</code> and <code>rtcOccluded</code> functions (single ray interface) for this scene.</td>
</tr>
<tr class="even">
<td align="left">RTC_INTERSECT4</td>
<td align="left">Enables the <code>rtcIntersect4</code> and <code>rtcOccluded4</code> functions (4-wide packet interface) for this scene.</td>
</tr>
<tr class="odd">
<td align="left">RTC_INTERSECT8</td>
<td align="left">Enables the <code>rtcIntersect8</code> and <code>rtcOccluded8</code> functions (8-wide packet interface) for this scene.</td>
</tr>
<tr class="even">
<td align="left">RTC_INTERSECT16</td>
<td align="left">Enables the <code>rtcIntersect16</code> and <code>rtcOccluded16</code> functions (16-wide packet interface) for this scene.</td>
</tr>
<tr class="odd">
<td align="left">RTC_INTERSECT_STREAM</td>
<td align="left">Enables the <code>rtcIntersect1M</code>, <code>rtcOccluded1M</code>, <code>rtcIntersect1Mp</code>, <code>rtcOccluded1Mp</code>, <code>rtcIntersectNM</code>, <code>rtcOccludedNM</code>, <code>rtcIntersectNp</code>, and <code>rtcOccludedNp</code> functions for this scene.</td>
</tr>
<tr class="even">
<td align="left">RTC_INTERPOLATE</td>
<td align="left">Enables the <code>rtcInterpolate</code> and <code>rtcInterpolateN</code> interpolation functions.</td>
</tr>
</tbody>
</table>
<p>Embree supports two modes for a scene, the <code>normal mode</code> and <code>stream mode</code>. These modes mainly differ in the kind of callbacks invoked and how rays are extended with user data. The normal mode is enabled by default, the ray stream mode can be enabled using the <code>RTC_INTERSECT_STREAM</code> algorithm flag for a scene. Only in ray stream mode, the stream API functions <code>rtcIntersect1M</code>, <code>rtcIntersect1Mp</code>, <code>rtcIntersectNM</code>, and <code>rtcIntersectNp</code> as well as their occlusion variants can be used.</p>
<p>The scene bounding box can get read by the function <code>rtcGetBounds(RTCScene scene, RTCBounds&amp; bounds_o)</code>. This function will write the AABB of the scene to <code>bounds_o</code>. Time varying bounds can be obtained usin the <code>rtcGetLinearBounds(RTCScene scene, RTCBounds* bounds_o)</code> function. This function will write two AABBs to <code>bounds_o</code>. Linearly interpolating these bounds to a specific time <code>t</code> yields bounds that bound the geometry at that time. Invoking these functions is only valid when all scene changes got committed using <code>rtcCommit</code>.</p>
<h2 id="geometries">Geometries</h2>
<p>Geometries are always contained in the scene they are created in. Each geometry is assigned an integer ID at creation time, which is unique for that scene. The current version of the API supports triangle meshes (<code>rtcNewTriangleMesh2</code>), quad meshes (<code>rtcNewQuadMesh2</code>), Catmull-Clark subdivision surfaces (<code>rtcNewSubdivisionMesh2</code>), curve geometries (<code>rtcNewBezierCurveGeometry2</code>), hair geometries (<code>rtcNewBezierHairGeometry2</code>), single level instances of other scenes (<code>rtcNewInstance3</code>), and user defined geometries (<code>rtcNewUserGeometry3</code>). The API is designed in a way that easily allows adding new geometry types in later releases.</p>
<p>The application can manage geometry IDs itself, or let Embree allocate geometry IDs. Therefore all geometry creation functions have a <code>geomID</code> parameter. This parameter can be set to <code>RTC_INVALID_GEOMETRY_ID</code> to let Embree allocate a geometry ID (default) or to some geometry ID allocated by the application.</p>
<p>If the application allocates a geometry ID, then this geometry ID has to be unused in the scene, otherwise the creation of the geometry will fail. Further, the geometry IDs allocated by the application should be compact, as Embree internally created a vector which size is equal to the largest geometry ID used. Creating very large geometry IDs for small scenes would thus cause a memory consumption and performance overhead.</p>
<p>If Embree allocates a geometry ID then the following properties hold. For dynamic scenes, all IDs are assigned sequentially, starting from 0, as long as no geometry got deleted. If geometries got deleted, the implementation will reuse IDs later on in an implementation dependent way. Consequently sequential assignment is no longer guaranteed, but a compact range of IDs. These rules allow the application to manage a dynamic array to efficiently map from geometry IDs to its own geometry representation. For static scenes, geometry IDs are assigned sequentially starting at 0. This allows the application to use a fixed size array to map from geometry IDs to its own geometry representation.</p>
<p>Alternatively the application can also use the <code>void rtcSetUserData (RTCScene scene, unsigned geomID, void* ptr)</code> function to set a user data pointer <code>ptr</code> to its own geometry representation, and later read out this pointer again using the <code>void* rtcGetUserData (RTCScene scene, unsigned geomID)</code> function.</p>
<p>The following geometry flags can be specified at construction time of geometries:</p>
<table>
<caption>Flags for the creation of new geometries.</caption>
<colgroup>
<col width="34%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Geometry Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_GEOMETRY_STATIC</td>
<td align="left">The geometry is considered static and should get modified rarely by the application. This flag has to get used in static scenes.</td>
</tr>
<tr class="even">
<td align="left">RTC_GEOMETRY_DEFORMABLE</td>
<td align="left">The geometry is considered to deform in a coherent way, e.g. a skinned character. The connectivity of the geometry has to stay constant, thus modifying the index array is not allowed. The implementation is free to choose a BVH refitting approach for handling meshes tagged with that flag.</td>
</tr>
<tr class="odd">
<td align="left">RTC_GEOMETRY_DYNAMIC</td>
<td align="left">The geometry is considered highly dynamic and changes frequently, possibly in an unstructured way. Embree will rebuild data structures from scratch for this type of geometry.</td>
</tr>
</tbody>
</table>
<h3 id="triangle-meshes">Triangle Meshes</h3>
<p>Triangle meshes are created using the <code>rtcNewTriangleMesh2</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>The number of triangles, number of vertices, and optionally the number of time steps for multi-segment motion blur have to get specified at construction time of the mesh. The user can also specify additional flags that choose the strategy to handle that mesh in dynamic scenes. The following example demonstrates how to create a triangle mesh without motion blur:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewTriangleMesh2(scene, geomFlags,
                                      numTriangles, numVertices, <span class="dv">1</span>);</code></pre>
<p>The triangle indices can be set by mapping and writing to the index buffer (<code>RTC_INDEX_BUFFER</code>) and the triangle vertices can be set by mapping and writing into the vertex buffer (<code>RTC_VERTEX_BUFFER</code>). The index buffer contains an array of three 32-bit indices, while the vertex buffer contains an array of three float values. The vertex buffer can be at most 16GB large. When the vertex buffer is managed internally the stride between vertices is 16 bytes. For multi segment motion blur, for each time step a vertex buffer has to be specified, and all these buffers have to have the same stride. All buffers have to get unmapped before an <code>rtcCommit</code> call to the scene.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Vertex   { <span class="dt">float</span> x, y, z, a; };
<span class="kw">struct</span> Triangle { <span class="dt">int</span> v0, v1, v2; };

Vertex* vertices = (Vertex*) rtcMapBuffer(scene, geomID, RTC_VERTEX_BUFFER);
<span class="co">// fill vertices here</span>
rtcUnmapBuffer(scene, geomID, RTC_VERTEX_BUFFER);

Triangle* triangles = (Triangle*) rtcMapBuffer(scene, geomID, RTC_INDEX_BUFFER);
<span class="co">// fill triangle indices here</span>
rtcUnmapBuffer(scene, geomID, RTC_INDEX_BUFFER);</code></pre>
<p>Also see tutorial <a href="tutorials.html#triangle-geometry">Triangle Geometry</a> for an example of how to create triangle meshes.</p>
<p>The parametrization of a triangle uses the first vertex <code>p0</code> as base point, and the vector <code>p1 - p0</code> as u-direction and <code>p2 - p0</code> as v-direction. The following picture additionally illustrates the direction the geometry normal is pointing into.</p>
<div class="figure">
<img src="images/triangle_uv.png" />

</div>
<p>Some texture coordinates <code>t0,t1,t2</code> can be linearly interpolated over the triangle the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">t_uv = (<span class="dv">1</span>-u-v)*t0 + u*t1 + v*t2</code></pre>
<h3 id="quad-meshes">Quad Meshes</h3>
<p>Quad meshes are created using the <code>rtcNewQuadMesh2</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>The number of quads, number of vertices, and optionally the number of time steps for multi-segment motion blur have to get specified at construction time of the mesh. The user can also specify additional flags that choose the strategy to handle that mesh in dynamic scenes. The following example demonstrates how to create a quad mesh without motion blur:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewQuadMesh2(scene, geomFlags,
                                  numQuads, numVertices, <span class="dv">1</span>);</code></pre>
<p>The quad indices can be set by mapping and writing to the index buffer (<code>RTC_INDEX_BUFFER</code>) and the quad vertices can be set by mapping and writing into the vertex buffer (<code>RTC_VERTEX_BUFFER</code>). The index buffer contains an array of four 32-bit indices, while the vertex buffer contains an array of three float values. The vertex buffer can be at most 16GB large. When the vertex buffer is managed internally the stride between vertices is 16 bytes. For multi segment motion blur, for each time step a vertex buffer has to be specified, and all these buffers have to have the same stride. All buffers have to get unmapped before an <code>rtcCommit</code> call to the scene.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Vertex { <span class="dt">float</span> x, y, z, a; };
<span class="kw">struct</span> Quad   { <span class="dt">int</span> v0, v1, v2, v3; };

Vertex* vertices = (Vertex*) rtcMapBuffer(scene, geomID, RTC_VERTEX_BUFFER);
<span class="co">// fill vertices here</span>
rtcUnmapBuffer(scene, geomID, RTC_VERTEX_BUFFER);

Quad* quads = (Quad*) rtcMapBuffer(scene, geomID, RTC_INDEX_BUFFER);
<span class="co">// fill quad indices here</span>
rtcUnmapBuffer(scene, geomID, RTC_INDEX_BUFFER);</code></pre>
<p>A quad is internally handled as a pair of two triangles <code>v0,v1,v3</code> and <code>v2,v3,v1</code>, with the u’/v’ coordinates of the second triangle corrected by <code>u = 1-u'</code> and <code>v = 1-v'</code> to produce a quad parametrization where u and v go from 0 to 1.</p>
<p>To encode a triangle as a quad just replicate the last triangle vertex (<code>v0,v1,v2</code> -&gt; <code>v0,v1,v2,v2</code>). This way the quad mesh can be used to represent a mixed mesh which contains triangles and quads.</p>
<h3 id="subdivision-surfaces">Subdivision Surfaces</h3>
<p>Catmull-Clark subdivision surfaces for meshes consisting of faces of up to 15 vertices (e.g. triangles, quadrilateral, pentagons, etc.) are supported, including support for edge creases, vertex creases, holes, non-manifold geometry, and face-varying interpolation.</p>
<p>A subdivision surface is created using the <code>rtcNewSubdivisionMesh2</code> function call, and deleted again using the <code>rtcDeleteGeometry</code> function call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"> <span class="dt">unsigned</span> rtcNewSubdivisionMesh2(RTCScene scene,
                                 RTCGeometryFlags flags,
                                 size_t numFaces,
                                 size_t numEdges,
                                 size_t numVertices,
                                 size_t numEdgeCreases,
                                 size_t numVertexCreases,
                                 size_t numCorners,
                                 size_t numHoles,
                                 size_t numTimeSteps,
                                 <span class="dt">unsigned</span> <span class="dt">int</span> geomID);</code></pre>
<p>The number of faces (<code>numFaces</code>), edges/indices (<code>numEdges</code>), vertices (<code>numVertices</code>), edge creases (<code>numEdgeCreases</code>), vertex creases (<code>numVertexCreases</code>), holes (<code>numHoles</code>), and time steps (<code>numTimeSteps</code>) have to get specified at construction time.</p>
<p>The following buffers have to get setup by the application: the face buffer (<code>RTC_FACE_BUFFER</code>) contains the number edges/indices (3 to 15) of each of the <code>numFaces</code> faces, the index buffer (<code>RTC_INDEX_BUFFER</code>) contains multiple (3 to 15) 32-bit vertex indices for each face and <code>numEdges</code> indices in total, the vertex buffer (<code>RTC_VERTEX_BUFFER</code>) stores <code>numVertices</code> vertices as single precision <code>x</code>, <code>y</code>, <code>z</code> floating point coordinates aligned to 16 bytes. The value of the 4th float used for alignment can be arbitrary.</p>
<p>Optionally the application may fill additional index buffers if multiple topologies are required for face-varying interpolation. The standard vertex buffers <code>RTC_VERTEX_BUFFER</code> are always bound to the geometry topology (topology 0) thus use <code>RTC_INDEX_BUFFER0</code>. Data interpolation may use different topologies as described later.</p>
<p>Optionally, the application can setup the hole buffer (<code>RTC_HOLE_BUFFER</code>) with <code>numHoles</code> many 32-bit indices of faces that should be considered non-existing in all topologies.</p>
<p>Optionally, the application can fill the level buffer (<code>RTC_LEVEL_BUFFER</code>) with a tessellation rate for each or the edges of each face, making a total of <code>numEdges</code> values. The tessellation level is a positive floating point value, that specifies how many quads along the edge should get generated during tessellation. If no level buffer is specified a level of 1 is used. The maximally supported edge level is 4096 and larger levels get clamped to that value. Note that some edge may be shared between (typically 2) faces. To guarantee a watertight tessellation, the level of these shared edges has to be exactly identical. A uniform tessellation rate for an entire subdivision mesh can be set by using the <code>rtcSetTessellationRate(RTCScene scene, unsigned geomID, float rate)</code> function. The existance of a level buffer has preference over the uniform tessellation rate.</p>
<p>Optionally, the application can fill the sparse edge crease buffers to make some edges appear sharper. The edge crease index buffer (<code>RTC_EDGE_CREASE_INDEX_BUFFER</code>) contains <code>numEdgeCreases</code> many pairs of 32-bit vertex indices that specify unoriented edges in the geometry topology. The edge crease weight buffer (<code>RTC_EDGE_CREASE_WEIGHT_BUFFER</code>) stores for each of theses crease edges a positive floating point weight. The larger this weight, the sharper the edge. Specifying a weight of infinity is supported and marks an edge as infinitely sharp. Storing an edge multiple times with the same crease weight is allowed, but has lower performance. Storing an edge multiple times with different crease weights results in undefined behavior. For a stored edge (i,j), the reverse direction edges (j,i) does not have to get stored, as both are considered the same edge. Edge crease features are specified for the geomtetry topology, but copied to all other topologies automatically.</p>
<p>Optionally, the application can fill the sparse vertex crease buffers to make some vertices appear sharper. The vertex crease index buffer (<code>RTC_VERTEX_CREASE_INDEX_BUFFER</code>), contains <code>numVertexCreases</code> many 32-bit vertex indices to specify a set of vertices from the geometry topology. The vertex crease weight buffer (<code>RTC_VERTEX_CREASE_WEIGHT_BUFFER</code>) specifies for each of these vertices a positive floating point weight. The larger this weight, the sharper the vertex. Specifying a weight of infinity is supported and makes the vertex infinitely sharp. Storing a vertex multiple times with the same crease weight is allowed, but has lower performance. Storing a vertex multiple times with different crease weights results in undefined behavior. Vertex crease features are specified for the geomtetry topology, but copied to all other topologies automatically.</p>
<p>Faces with 3 to 15 vertices are supported (triangles, quadrilateral, pentagons, etc).</p>
<p>The user can also specify a geometry mask and additional flags that choose the strategy to handle that subdivision mesh in dynamic scenes.</p>
<p>The implementation of subdivision surfaces uses an internal software cache, which can get configured to some desired size (see <a href="#configuring-embree">Configuring Embree</a>).</p>
<h4 id="parametrization">Parametrization</h4>
<p>The parametrization of a regular quadrilateral uses the first vertex <code>p0</code> as base point, and the vector <code>p1 - p0</code> as u-direction and <code>p3 - p0</code> as v-direction. The following picture additionally illustrates the direction the geometry normal is pointing into.</p>
<div class="figure">
<img src="images/quad_uv.png" />

</div>
<p>Some texture coordinates <code>t0,t1,t2,t3</code> can be bi-linearly interpolated over the quadrilateral the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">t_uv = (<span class="dv">1</span>-v)((<span class="dv">1</span>-u)*t0 + u*t1) + v*((<span class="dv">1</span>-u)*t3 + u*t2)</code></pre>
<p>The parametrization for all other face types where the number of vertices is not equal to 4, have a special parametrization where the n’th quadrilateral (that would be obtained by a single subdivision step) and the local hit location inside this quadrilateral are encoded in the UV coordinates. The following piece of code extracts the sub-patch ID i and UVs of this subpatch:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">unsigned</span> l = floorf(<span class="fl">0.</span><span class="er">5f</span>*U);
<span class="dt">const</span> <span class="dt">unsigned</span> h = floorf(<span class="fl">0.</span><span class="er">5f</span>*V);
<span class="dt">const</span> <span class="dt">unsigned</span> i = <span class="dv">4</span>*h+l;
<span class="dt">const</span> <span class="dt">float</span> u = <span class="fl">2.</span><span class="er">0f</span>*fracf(<span class="fl">0.</span><span class="er">5f</span>*U)<span class="fl">-0.</span><span class="er">5f</span>;
<span class="dt">const</span> <span class="dt">float</span> v = <span class="fl">2.</span><span class="er">0f</span>*fracf(<span class="fl">0.</span><span class="er">5f</span>*V)<span class="fl">-0.</span><span class="er">5f</span>;</code></pre>
<p>This encoding allows local subpatch UVs to be in the range <code>[-0.5,1.5[</code> thus negative subpatch UVs can get passed to <code>rtcInterpolate</code> to sample subpatches slightly out of bounds. This can be useful to calculate derivatives using finite differences if required. The encoding further has the property that you can just move some value du (or dv) on a subpatch by adding du (or dv) to the special UV encoding as long as you are not falling out of the <code>[-0.5,1.5[</code> range. Further, derivatives calculated using finite differences are compatible with derivatives calculated using <code>rtcInterpolate</code> when using the standard formula:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">dF(u)/du = (F(u+du)-F(u))/du</code></pre>
<p>To smoothly interpolate texture coordinates over the subdivision surface we recommend using the <code>rtcInterpolate</code> function, which will apply the standard subdivision rules for interpolation and automatically take care of the special UV encoding for non-quadrilaterals.</p>
<h4 id="face-varing-data">Face-Varing Data</h4>
<p>Face-varying interpolation is supported through multiple topologies per subdivision mesh and binding such topologies to user vertex buffers to interpolate. This way texture coordinates may use a different topology with additional boundaries to construct separate UV regions inside one subdivision mesh.</p>
<p>Each such topology consists of an index buffer and subdivision mode. Up to 16 topologies are supported, with corresponding index buffers <code>RTC_INDEX_BUFFER0+i</code>, with i in the range 0 to 15.</p>
<p>Each of the 16 supported user vertex buffers <code>RTC_USER_VERTEX_BUFFER0+j</code> (j in the range 0 to 15) can be assigned to some topology using the <code>rtcSetIndexBuffer</code> call:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetIndexBuffer(RTCScene scene, <span class="dt">unsigned</span> geomID,
                       RTCBufferType vertexBuffer, RTCBufferType indexBuffer);</code></pre>
<p>The face buffer (<code>RTC_FACE_BUFFER</code>) is shared between all topologies, which means that the n’th primitive always has the same number of vertices (e.g. being a triangle or a quad) for each topology. However, the indices of the topologies themselves may be different.</p>
<h4 id="subdivision-mode">Subdivision Mode</h4>
<p>The subdivision modes can be used to force linear interpolation for some parts of the subdivision mesh.</p>
<table>
<caption>Subdivision modes supported by Embree.</caption>
<colgroup>
<col width="36%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Boundary Mode</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SUBDIV_NO_BOUNDARY</td>
<td align="left">Boundary patches are ignored. This way each rendered patch has a full set of control vertices.</td>
</tr>
<tr class="even">
<td align="left">RTC_SUBDIV_SMOOTH_BOUNDARY</td>
<td align="left">The sequence of boundary control points are used to generate a smooth B-spline boundary curve (default mode).</td>
</tr>
<tr class="odd">
<td align="left">RTC_SUBDIV_PIN_CORNERS</td>
<td align="left">Corner vertices are pinned to their location during subdivision.</td>
</tr>
<tr class="even">
<td align="left">RTC_SUBDIV_PIN_BOUNDARY</td>
<td align="left">All vertices at the border are pinned to their location during subdivision. This way the boundary is interpolated linearly.</td>
</tr>
<tr class="odd">
<td align="left">RTC_SUBDIV_PIN_ALL</td>
<td align="left">All vertices at the border are binned to their location during subdivision. This way all patches are linearly interpolated.</td>
</tr>
</tbody>
</table>
<p>These modes can be set to each topology separately using the <code>rtcSetSubdivisionMode</code> API call with the following signature:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetSubdivisionMode(RTCScene scene, <span class="dt">unsigned</span> geomID,
                           <span class="dt">unsigned</span> topologyID, RTCSubdivisionMode mode);</code></pre>
<p>These modes are typically used to interpolate face-varying data properly. E.g. the topology used to interpolate texture coordinaces are typically assigned the <code>RTC_SUBDIV_PIN_BOUNDARY</code> mode, to also map texels at the border of the texture to the mesh.</p>
<p>Also see tutorial <a href="tutorials.html#subdivision-geometry">Subdivision Geometry</a> for an example of how to create subdivision surfaces.</p>
<h3 id="line-segment-hair-geometry">Line Segment Hair Geometry</h3>
<p>Line segments are supported to render hair geometry. A line segment consists of a start and end point, and start and end radius. Individual line segments are considered to be subpixel sized which allows the implementation to approximate the intersection calculation. This in particular means that zooming onto one line segment might show geometric artifacts.</p>
<p>Line segments are created using the <code>rtcNewLineSegments2</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>The number of line segments, the number of vertices, and optionally the number of time steps for multi-segment motion blur have to get specified at construction time of the line segment geometry.</p>
<p>The segment indices can be set by mapping and writing to the index buffer (<code>RTC_INDEX_BUFFER</code>) and the vertices can be set by mapping and writing into the vertex buffer (<code>RTC_VERTEX_BUFFER</code>). In case of motion blur, the vertex buffers (<code>RTC_VERTEX_BUFFER0+t</code>) have to get filled for each time step <code>t</code>.</p>
<p>The index buffer contains an array of 32-bit indices pointing to the ID of the first of two vertices, while the vertex buffer stores all control points in the form of a single precision position and radius stored in <code>x</code>, <code>y</code>, <code>z</code>, <code>r</code> order in memory. The radii have to be greater or equal zero. All buffers have to get unmapped before an <code>rtcCommit</code> call to the scene.</p>
<p>The intersection with the line segment primitive stores the parametric hit location along the line segment as <code>u</code>-coordinate (range <span class="math">[0, 1]</span>; <code>v</code> is always set to zero). The geometry normal <code>Ng</code> is filled with the the tangent, i.e. the vector from start to end vertex.</p>
<p>Like for triangle meshes, the user can also specify a geometry mask and additional flags that choose the strategy to handle that mesh in dynamic scenes.</p>
<p>The following example demonstrates how to create some line segment geometry:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewLineSegments2(scene, geomFlags, numCurves,
                                      numVertices, <span class="dv">1</span>);

<span class="kw">struct</span> Vertex { <span class="dt">float</span> x, y, z, r; };

Vertex* vertices = (Vertex*) rtcMapBuffer(scene, geomID, RTC_VERTEX_BUFFER);
<span class="co">// fill vertices here</span>
rtcUnmapBuffer(scene, geomID, RTC_VERTEX_BUFFER);

<span class="dt">int</span>* curves = (<span class="dt">int</span>*) rtcMapBuffer(scene, geomID, RTC_INDEX_BUFFER);
<span class="co">// fill indices here</span>
rtcUnmapBuffer(scene, geomID, RTC_INDEX_BUFFER);</code></pre>
<h3 id="spline-hair-geometry">Spline Hair Geometry</h3>
<p>Hair geometries are supported, which consist of multiple hairs represented as cubic spline curves with varying radius per control point. As spline basis we currently support Bézier splines and B-splines. Individual hairs are considered to be subpixel sized which allows the implementation to approximate the intersection calculation. This in particular means that zooming onto one hair might show geometric artifacts.</p>
<p>Hair geometries are created using the <code>rtcNewBezierHairGeometry2</code> or <code>rtcNewBSplineHairGeometry2</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>The number of hair curves, the number of vertices, and optionally the number of time steps for multi-segment motion blur have to get specified at construction time of the hair geometry.</p>
<p>The curve indices can be set by mapping and writing to the index buffer (<code>RTC_INDEX_BUFFER</code>) and the control vertices can be set by mapping and writing into the vertex buffer (<code>RTC_VERTEX_BUFFER</code>). In case of motion blur, the vertex buffers <code>RTC_VERTEX_BUFFER0+t</code> have to get filled for each time step.</p>
<p>The index buffer contains an array of 32-bit indices pointing to the ID of the first of four control vertices, while the vertex buffer stores all control points in the form of a single precision position and radius stored in <code>x</code>, <code>y</code>, <code>z</code>, <code>r</code> order in memory. The hair radii have to be greater or equal zero. All buffers have to get unmapped before an <code>rtcCommit</code> call to the scene.</p>
<p>The intersection with the hair primitive stores the parametric hit location along the hair as <code>u</code>-coordinate (range 0 to +1), and the normalized distance as the <code>v</code>-coordinate (range -1 to +1). The geometry normal <code>Ng</code> is filled with the the tangent of the bezier curve at the hit location on the curve (dPdu).</p>
<p>The implementation may choose to subdivide the Bézier curve into multiple cylinders-like primitives. The number of cylinders the curve gets subdivided into can be specified per hair geometry through the <code>rtcSetTessellationRate(RTCScene scene, unsigned geomID, float rate)</code> function. By default the tessellation rate for hair curves is 4.</p>
<p>Like for triangle meshes, the user can also specify a geometry mask and additional flags that choose the strategy to handle that mesh in dynamic scenes.</p>
<p>The following example demonstrates how to create some hair geometry:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewBezierHairGeometry2(scene, geomFlags, numCurves, numVertices);

<span class="kw">struct</span> Vertex { <span class="dt">float</span> x, y, z, r; };

Vertex* vertices = (Vertex*) rtcMapBuffer(scene, geomID, RTC_VERTEX_BUFFER);
<span class="co">// fill vertices here</span>
rtcUnmapBuffer(scene, geomID, RTC_VERTEX_BUFFER);

<span class="dt">int</span>* curves = (<span class="dt">int</span>*) rtcMapBuffer(scene, geomID, RTC_INDEX_BUFFER);
<span class="co">// fill indices here</span>
rtcUnmapBuffer(scene, geomID, RTC_INDEX_BUFFER);</code></pre>
<p>Also see tutorial <a href="tutorials.html#hair">Hair</a> for an example of how to create and use hair geometry.</p>
<h3 id="spline-curve-geometry">Spline Curve Geometry</h3>
<p>The spline curve geometry consists of multiple cubic spline curves with varying radius per control point. As spline basis we currently support Bézier splines and B-splines. The cuve surface is defined as the sweep surface of sweeping a varying radius circle tangential along the Bézier curve. As a limitation, the radius of the curve has to be smaller than the curvature radius of the Bézier curve at each location on the curve. In contrast to hair geometry, the curve geometry is rendered properly even in closeups.</p>
<p>Curve geometries are created using the <code>rtcNewBezierCurveGeometry2</code> or <code>rtcNewBSplineCurveGeometry2</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>The number of Bézier curves, the number of vertices, and optionally the number of time steps for multi-segment motion blur have to get specified at construction time of the curve geometry.</p>
<p>The curve indices can be set by mapping and writing to the index buffer (<code>RTC_INDEX_BUFFER</code>) and the control vertices can be set by mapping and writing into the vertex buffer (<code>RTC_VERTEX_BUFFER</code>). In case of motion blur, the vertex buffers <code>RTC_VERTEX_BUFFER0+t</code> have to get filled for each time step.</p>
<p>The index buffer contains an array of 32-bit indices pointing to the ID of the first of four control vertices, while the vertex buffer stores all control points in the form of a single precision position and radius stored in <code>x</code>, <code>y</code>, <code>z</code>, <code>r</code> order in memory. The curve radii have to be greater or equal zero. All buffers have to get unmapped before an <code>rtcCommit</code> call to the scene.</p>
<p>Like for triangle meshes, the user can also specify a geometry mask and additional flags that choose the strategy to handle the curves in dynamic scenes.</p>
<p>Also see tutorial <a href="tutorials.html#bézier-curves">Curves</a> for an example of how to create and use Bézier curve geometries.</p>
<h3 id="user-defined-geometry">User Defined Geometry</h3>
<p>User defined geometries make it possible to extend Embree with arbitrary types of user defined primitives. This is achieved by introducing arrays of user primitives as a special geometry type.</p>
<p>User geometries are created using the <code>rtcNewUserGeometry3</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>When creating a user defined geometry, the user has to set a data pointer, a bounding function closure (function and user pointer) as well as user defined intersect and occluded callback function pointers. The bounding function is used to query the bounds of all timesteps of a user primitive, while the intersect and occluded callback functions are called to intersect the primitive with a ray.</p>
<p>The bounding function to register has the following signature</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*RTCBoundsFunc3)(<span class="dt">void</span>* userPtr, <span class="dt">void</span>* geomUserPtr, size_t id, size_t timeStep, RTCBounds&amp; bounds_o);</code></pre>
<p>and can be registered using the <code>rtcSetBoundsFunction3</code> API function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetBoundsFunction3(scene, geomID, userBoundsFunction, userPtr);</code></pre>
<p>When the bounding callback is called, it is passed a user defined pointer specified at registration time of the bounds function (<code>userPtr</code> parameter), the per geometry user data pointer (<code>geomUserPtr</code> parameter), the ID of the primitive to calculate the bounds for (<code>id</code> parameter), the time step at which to calculate the bounds (<code>timeStep</code> parameter) and a memory location to write the calculated bound to (<code>bounds_o</code> parameter).</p>
<p>The signature of supported user defined intersect and occluded function in normal mode is as follows:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*RTCIntersectFunc  ) (                   <span class="dt">void</span>* userDataPtr, RTCRay&amp; ray, size_t item);
<span class="kw">typedef</span> <span class="dt">void</span> (*RTCIntersectFunc4 ) (<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userDataPtr, RTCRay4&amp; ray, size_t item);
<span class="kw">typedef</span> <span class="dt">void</span> (*RTCIntersectFunc8 ) (<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userDataPtr, RTCRay8&amp; ray, size_t item);
<span class="kw">typedef</span> <span class="dt">void</span> (*RTCIntersectFunc16) (<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userDataPtr, RTCRay16&amp; ray, size_t item);</code></pre>
<p>The <code>RTCIntersectFunc</code> callback function operates on single rays and gets passed the user data pointer of the user geometry (<code>userDataPtr</code> parameter), the ray to intersect (<code>ray</code> parameter), and the ID of the primitive to intersect (<code>item</code> parameter). The <code>RTCIntersectFunc4/8/16</code> callback functions operate on ray packets of size 4, 8 and 16 and additionally get an integer valid mask as input (<code>valid</code> parameter). The callback functions should not modify any ray that is disabled by that valid mask.</p>
<p>In stream mode the following callback function has to get used:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*RTCIntersectFuncN ) (<span class="dt">const</span> <span class="dt">int</span>*  valid, <span class="dt">void</span>* userDataPtr, <span class="dt">const</span> RTCIntersectContext* context, RTCRayN* rays, size_t N, size_t item);
<span class="kw">typedef</span> <span class="dt">void</span> (*RTCIntersectFunc1Mp)(                   <span class="dt">void</span>* userDataPtr, <span class="dt">const</span> RTCIntersectContext* context, RTCRay** rays, size_t M, size_t item);</code></pre>
<p>The <code>RTCIntersectFuncN</code> callback function supports ray packets of arbitrary size <code>N</code>. The <code>RTCIntersectFunc1Mp</code> callback function get an array of <code>M</code> pointers to single rays as input.</p>
<p>The user intersect function should return without modifying the ray structure if the user geometry is missed. Whereas, if an intersection of the user primitive with the ray segment was found, the intersect function has to update the hit information of the ray (<code>tfar</code>, <code>u</code>, <code>v</code>, <code>Ng</code>, <code>geomID</code>, <code>primID</code> components).</p>
<p>The user occluded function should also return without modifying the ray structure if the user geometry is missed. If the geometry is hit, it should set the <code>geomID</code> member of the ray to 0.</p>
<p>When performing ray queries using the <code>rtcIntersect</code> and <code>rtcOccluded</code> function, callbacks of type <code>RTCIntersectFunc</code> are invoked for user geometries. Consequently, an application only operating on single rays only has to provide the single ray intersect and occluded callbacks. Similar when calling the <code>rtcIntersect4/8/16</code> and <code>rtcOccluded4/8/16</code> functions, the <code>RTCIntersectFunc4/8/16</code> callbacks of matching packet size and type are called.</p>
<p>If ray stream mode is enabled for the scene only the <code>RTCIntersectFuncN</code> and <code>RTCIntersectFunc1Mp</code> callback can be used. In this case specifying an <code>RTCIntersectFuncN</code> callback is mandatory and the <code>RTCIntersectFunc1Mp</code> callback is optional. Trying to set a different type of user callback function results in an error.</p>
<p>The following example illustrates creating an array with two user geometries:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> numTimeSteps = <span class="dv">2</span>;
<span class="kw">struct</span> UserObject { ... };

<span class="dt">void</span> userBoundsFunction(<span class="dt">void</span>* userPtr, UserObject* userGeomPtr, size_t i, size_t t, RTCBounds&amp; bounds)
{
    bounds = &lt;bounds of userGeomPtr[i] at time t&gt;;
}

<span class="dt">void</span> userIntersectFunction(UserObject* userGeomPtr, RTCRay&amp; ray, size_t i)
{
  <span class="kw">if</span> (&lt;ray misses userGeomPtr[i] at time ray.time&gt;)
    <span class="kw">return</span>;
  &lt;update ray hit information&gt;;
}

<span class="dt">void</span> userOccludedFunction(UserObject* userGeomPtr, RTCRay&amp; ray, size_t i)
{
  <span class="kw">if</span> (&lt;ray misses userGeomPtr[i] at time ray.time&gt;)
    <span class="kw">return</span>;
  geomID = <span class="dv">0</span>;
}

...

UserObject* userGeomPtr = <span class="kw">new</span> UserObject[<span class="dv">2</span>];
userGeomPtr[<span class="dv">0</span>] = ...
userGeomPtr[<span class="dv">1</span>] = ...
<span class="dt">unsigned</span> geomID = rtcNewUserGeometry3(scene, <span class="dv">2</span>, numTimeSteps);
rtcSetUserData(scene, geomID, userGeomPtr);
rtcSetBoundsFunction3(scene, geomID, userBoundsFunction, userPtr);
rtcSetIntersectFunction(scene, geomID, userIntersectFunction);
rtcSetOccludedFunction(scene, geomID, userOccludedFunction);</code></pre>
<p>See tutorial <a href="tutorials.html#user-geometry">User Geometry</a> for an example of how to use the user defined geometries.</p>
<h3 id="instances">Instances</h3>
<p>Embree supports instancing of scenes inside another scene by some transformation. As the instanced scene is stored only a single time, even if instanced to multiple locations, this feature can be used to create very large scenes. Only single level instancing is supported by Embree natively, however, multi-level instancing can be implemented through user geometries.</p>
<p>Instances are created using the <code>rtcNewInstance3 (RTCScene target, RTCScene source, size_t numTimeSteps)</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call. To instantiate a scene, one first has to generate the scene <code>B</code> to instantiate. Now one can add an instance of this scene inside a scene <code>A</code> the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> instID = rtcNewInstance3(sceneA, sceneB, <span class="dv">1</span>);
rtcSetTransform2(sceneA, instID, RTC_MATRIX_COLUMN_MAJOR, &amp;column_matrix_3x4, <span class="dv">0</span>);</code></pre>
<p>To create some motion blurred instance just pass the number of time steps and specify one matrix for each time step:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> instID = rtcNewInstance3(sceneA, sceneB, <span class="dv">3</span>);
rtcSetTransform2(sceneA, instID, RTC_MATRIX_COLUMN_MAJOR, &amp;column_matrix_t0_3x4, <span class="dv">0</span>);
rtcSetTransform2(sceneA, instID, RTC_MATRIX_COLUMN_MAJOR, &amp;column_matrix_t1_3x4, <span class="dv">1</span>);
rtcSetTransform2(sceneA, instID, RTC_MATRIX_COLUMN_MAJOR, &amp;column_matrix_t2_3x4, <span class="dv">2</span>);</code></pre>
<p>Both scenes have to belong to the same device. One has to call <code>rtcCommit</code> on scene <code>B</code> before one calls <code>rtcCommit</code> on scene <code>A</code>. When modifying scene <code>B</code> one has to call <code>rtcUpdate</code> for all instances of that scene. If a ray hits the instance, then the <code>geomID</code> and <code>primID</code> members of the ray are set to the geometry ID and primitive ID of the primitive hit in scene <code>B</code>, and the <code>instID</code> member of the ray is set to the instance ID returned from the <code>rtcNewInstance3</code> function.</p>
<p>Some special care has to be taken when using user geometries and instances in the same scene. Instantiated user geometries should not set the <code>instID</code> field of the ray as this field is managed by the instancing already. However, non-instantiated user geometries should clear the <code>instID</code> field to <code>RTC_INVALID_GEOMETRY_ID</code>, to later distinguish them from instantiated geometries that have the <code>instID</code> field set.</p>
<p>The <code>rtcSetTransform2</code> call can be passed an affine transformation matrix with different data layouts:</p>
<table>
<caption>Matrix layouts for <code>rtcSetTransform2</code>.</caption>
<colgroup>
<col width="48%" />
<col width="48%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Layout</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_MATRIX_ROW_MAJOR</td>
<td align="left">The 3×4 float matrix is laid out in row major form.</td>
</tr>
<tr class="even">
<td align="left">RTC_MATRIX_COLUMN_MAJOR</td>
<td align="left">The 3×4 float matrix is laid out in column major form.</td>
</tr>
<tr class="odd">
<td align="left">RTC_MATRIX_COLUMN_MAJOR_ALIGNED16</td>
<td align="left">The 3×4 float matrix is laid out in column major form, with each column padded by an additional 4th component.</td>
</tr>
</tbody>
</table>
<p>Passing homogeneous 4×4 matrices is possible as long as the last row is (0, 0, 0, 1). If this homogeneous matrix is laid out in row major form, use the <code>RTC_MATRIX_ROW_MAJOR</code> layout. If this homogeneous matrix is laid out in column major form, use the <code>RTC_MATRIX_COLUMN_MAJOR_ALIGNED16</code> mode. In both cases, Embree will ignore the last row of the matrix.</p>
<p>The transformation passed to <code>rtcSetTransform2</code> transforms from the local space of the instantiated scene to world space.</p>
<p>See tutorial <a href="tutorials.html#instanced-geometry">Instanced Geometry</a> for an example of how to use instances.</p>
<h2 id="ray-layout">Ray Layout</h2>
<p>The ray layout to be passed to the ray tracing core is defined in the <code>embree2/rtcore_ray.h</code> header file. It is up to the user to use the ray structures defined in that file, or resemble the exact same binary data layout with their own vector classes. The ray layout might change with new Embree releases as new features get added, however, will stay constant as long as the major Embree release number does not change. The ray contains the following data members:</p>
<table>
<caption>Data fields of a ray.</caption>
<thead>
<tr class="header">
<th align="left">Member</th>
<th align="left">In/Out</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">org</td>
<td align="left">in</td>
<td align="left">ray origin</td>
</tr>
<tr class="even">
<td align="left">dir</td>
<td align="left">in</td>
<td align="left">ray direction (can be unnormalized)</td>
</tr>
<tr class="odd">
<td align="left">tnear</td>
<td align="left">in</td>
<td align="left">start of ray segment</td>
</tr>
<tr class="even">
<td align="left">tfar</td>
<td align="left">in/out</td>
<td align="left">end of ray segment, set to hit distance after intersection</td>
</tr>
<tr class="odd">
<td align="left">time</td>
<td align="left">in</td>
<td align="left">time used for multi-segment motion blur [0,1]</td>
</tr>
<tr class="even">
<td align="left">mask</td>
<td align="left">in</td>
<td align="left">ray mask to mask out geometries</td>
</tr>
<tr class="odd">
<td align="left">Ng</td>
<td align="left">out</td>
<td align="left">unnormalized geometry normal in object space</td>
</tr>
<tr class="even">
<td align="left">u</td>
<td align="left">out</td>
<td align="left">barycentric u-coordinate of hit</td>
</tr>
<tr class="odd">
<td align="left">v</td>
<td align="left">out</td>
<td align="left">barycentric v-coordinate of hit</td>
</tr>
<tr class="even">
<td align="left">geomID</td>
<td align="left">out</td>
<td align="left">geometry ID of hit geometry</td>
</tr>
<tr class="odd">
<td align="left">primID</td>
<td align="left">out</td>
<td align="left">primitive ID of hit primitive</td>
</tr>
<tr class="even">
<td align="left">instID</td>
<td align="left">out</td>
<td align="left">instance ID of hit instance</td>
</tr>
</tbody>
</table>
<p>This structure is in struct of array layout (SOA) for API functions accepting ray packets.</p>
<p>To create a single ray you can use the <code>RTCRay</code> ray type defined in <code>embree2/rtcore_ray.h</code>. To generate a ray packet of size 4, 8, or 16 you can use the <code>RTCRay4</code>, <code>RTCRay8</code>, or <code>RTCRay16</code> types. Alternatively you can also use the <code>RTCRayNt</code> template to generate ray packets of an arbitrary compile time known size.</p>
<p>When the ray packet size is not known at compile time (e.g. when Embree returns a ray packet in the <code>RTCFilterFuncN</code> callback function), then you can use the helper functions defined in <code>embree2/rtcore_ray.h</code> to access ray packet components:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span>&amp; RTCRayN_org_x(RTCRayN* rays, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCRayN_org_y(RTCRayN* rays, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCRayN_org_z(RTCRayN* rays, size_t N, size_t i);

<span class="dt">float</span>&amp; RTCRayN_dir_x(RTCRayN* rays, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCRayN_dir_y(RTCRayN* rays, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCRayN_dir_z(RTCRayN* rays, size_t N, size_t i);

<span class="dt">float</span>&amp; RTCRayN_tnear(RTCRayN* rays, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCRayN_tnear(RTCRayN* rays, size_t N, size_t i);

<span class="dt">float</span>&amp;    RTCRayN_time(RTCRayN* ptr, size_t N, size_t i);
<span class="dt">unsigned</span>&amp; RTCRayN_mask(RTCRayN* ptr, size_t N, size_t i);

<span class="dt">float</span>&amp; RTCRayN_Ng_x(RTCRayN* ptr, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCRayN_Ng_y(RTCRayN* ptr, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCRayN_Ng_z(RTCRayN* ptr, size_t N, size_t i);

<span class="dt">float</span>&amp; RTCRayN_u   (RTCRayN* ptr, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCRayN_v   (RTCRayN* ptr, size_t N, size_t i);

<span class="dt">unsigned</span>&amp; RTCRayN_instID(RTCRayN* ptr, size_t N, size_t i);
<span class="dt">unsigned</span>&amp; RTCRayN_geomID(RTCRayN* ptr, size_t N, size_t i);
<span class="dt">unsigned</span>&amp; RTCRayN_primID(RTCRayN* ptr, size_t N, size_t i);</code></pre>
<p>These helper functions get a pointer to the ray packet (<code>rays</code> parameter), the packet size <code>N</code>, and returns a reference to some component (e.g. x-component of origin) of the the ith ray of the packet.</p>
<p>Please note that there is some incompatibility in the layout of a single ray (<code>RTCRay</code> type) and a ray packet of size 1 (<code>RTCRayNt&lt;1&gt;</code> type) as the <code>org</code> and <code>dir</code> component are aligned to 16 bytes for single rays (see <code>embree2/rtcore_ray.h</code>). This incompatibility will get resolved in a future release, but has to be maintained for compatibility currently. Until then, the ray stream API will always use the single ray layout <code>RTCRay</code> for rays packets of size <code>N=1</code>, and the <code>RTCRayNt</code> layout for ray packets of size not equal 1. The helper functions above to access a ray packet of size <code>N</code> take care of this incompatibility.</p>
<p>Some callback functions get passed a hit structure with the following data members:</p>
<table>
<caption>Data fields of a hit.</caption>
<thead>
<tr class="header">
<th align="left">Member</th>
<th align="left">In/Out</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">instID</td>
<td align="left">in</td>
<td align="left">instance ID of hit instance</td>
</tr>
<tr class="even">
<td align="left">geomID</td>
<td align="left">in</td>
<td align="left">geometry ID of hit geometry</td>
</tr>
<tr class="odd">
<td align="left">primID</td>
<td align="left">in</td>
<td align="left">primitive ID of hit primitive</td>
</tr>
<tr class="even">
<td align="left">u</td>
<td align="left">in</td>
<td align="left">barycentric u-coordinate of hit</td>
</tr>
<tr class="odd">
<td align="left">v</td>
<td align="left">in</td>
<td align="left">barycentric v-coordinate of hit</td>
</tr>
<tr class="even">
<td align="left">t</td>
<td align="left">in</td>
<td align="left">hit distance</td>
</tr>
<tr class="odd">
<td align="left">Ng</td>
<td align="left">in</td>
<td align="left">unnormalized geometry normal in object space</td>
</tr>
</tbody>
</table>
<p>This structure is in struct of array layout (SOA) for hit packets of size <code>N</code>. The layout of a hit packet of size <code>N</code> is defined by the <code>RTCHitNt</code> template in <code>embree2/rtcore_ray.h</code>.</p>
<p>When the hit packet size is not known at compile time (e.g. when Embree returns a hit packet in the <code>RTCFilterFuncN</code> callback function), you can use the helper functions defined in <code>embree2/rtcore_ray.h</code> to access hit packet components:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span>&amp; RTCHitN_instID(RTCHitN* hits, size_t N, size_t i);
<span class="dt">unsigned</span>&amp; RTCHitN_geomID(RTCHitN* hits, size_t N, size_t i);
<span class="dt">unsigned</span>&amp; RTCHitN_primID(RTCHitN* hits, size_t N, size_t i);

<span class="dt">float</span>&amp; RTCHitN_u   (RTCHitN* hits, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCHitN_v   (RTCHitN* hits, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCHitN_t   (RTCHitN* hits, size_t N, size_t i);

<span class="dt">float</span>&amp; RTCHitN_Ng_x(RTCHitN* hits, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCHitN_Ng_y(RTCHitN* hits, size_t N, size_t i);
<span class="dt">float</span>&amp; RTCHitN_Ng_z(RTCHitN* hits, size_t N, size_t i);</code></pre>
<p>These helper functions get a pointer to the hit packet (<code>hits</code> parameter), the packet size <code>N</code>, and returns a reference to some component (e.g. u-component) of the the ith hit of the packet.</p>
<h2 id="ray-queries">Ray Queries</h2>
<p>The API supports finding the closest hit of a ray segment with the scene (<code>rtcIntersect</code> functions), and determining if any hit between a ray segment and the scene exists (<code>rtcOccluded</code> functions).</p>
<h3 id="normal-mode">Normal Mode</h3>
<p>In normal mode the following API functions should be used to trace rays:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcIntersect  (                   RTCScene scene, RTCRay&amp;    ray);
<span class="dt">void</span> rtcIntersect4 (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay4&amp;   ray);
<span class="dt">void</span> rtcIntersect8 (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay8&amp;   ray);
<span class="dt">void</span> rtcIntersect16(<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay16&amp;  ray);
<span class="dt">void</span> rtcOccluded   (                   RTCScene scene, RTCRay&amp;    ray);
<span class="dt">void</span> rtcOccluded4  (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay4&amp;   ray);
<span class="dt">void</span> rtcOccluded8  (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay8&amp;   ray);
<span class="dt">void</span> rtcOccluded16 (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay16&amp;  ray);</code></pre>
<p>The <code>rtcIntersect</code> and <code>rtcOccluded</code> function operate on single rays. The <code>rtcIntersect4</code> and <code>rtcOccluded4</code> functions operate on ray packets of size 4. The <code>rtcIntersect8</code> and <code>rtcOccluded8</code> functions operate on ray packets of size 8, and the <code>rtcIntersect16</code> and <code>rtcOccluded16</code> functions operate on ray packets of size 16.</p>
<p>For the ray packet mode with packet size of 4, 8, or 16, the user has to provide a pointer to 4, 8, or 16 of 32-bit integers that act as a ray activity mask (<code>valid</code> argument). If one of these integers is set to <code>0x00000000</code> the corresponding ray is considered inactive and if the integer is set to <code>0xFFFFFFFF</code>, the ray is considered active. Rays that are inactive will not update any hit information.</p>
<p>Finding the closest hit distance is done through the <code>rtcIntersect</code> type functions. These get the activity mask (<code>valid</code> parameter), the scene (<code>scene</code> parameter), and a ray as input (<code>ray</code> parameter). The layout of the ray structure is described in Section <a href="api.html#ray-layout">Ray Layout</a>. The user has to initialize the ray origin (<code>org</code>), ray direction (<code>dir</code>), and ray segment (<code>tnear</code>, <code>tfar</code>). The ray segment has to be in the range <span class="math">[0, ∞]</span>, thus ranges that start behind the ray origin are not valid, but ranges can reach to infinity. The implementation makes no guarantees if primitives whose hit distance is exactly at (or very close to) <code>tnear</code> or <code>tfar</code> are hit or missed. If you want to exclude intersections at <code>tnear</code> just pass a slighly enlarged <code>tnear</code> and if you want to include intersections at <code>tfar</code> pass a slighly enlarged <code>tfar</code> to Embree. The geometry ID (<code>geomID</code> member) has to get initialized to <code>RTC_INVALID_GEOMETRY_ID</code> (-1). If the scene contains instances, also the instance ID (<code>instID</code>) has to get initialized to <code>RTC_INVALID_GEOMETRY_ID</code> (-1). If the scene contains motion blur geometries, also the ray time (<code>time</code>) has to get initialized to a value in the range <span class="math">[0, 1]</span>. If ray masks are enabled at compile time, also the ray mask (<code>mask</code>) has to get initialized. After tracing the ray, the hit distance (<code>tfar</code>), geometry normal (<code>Ng</code>)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, local hit coordinates (<code>u</code>, <code>v</code>), geometry ID (<code>geomID</code>), and primitive ID (<code>primID</code>) are set. If the scene contains instances, also the instance ID (<code>instID</code>) is set, if an instance is hit. The geometry ID corresponds to the ID returned at creation time of the hit geometry, and the primitive ID corresponds to the <span class="math"><em>n</em></span>th primitive of that geometry, e.g. <span class="math"><em>n</em></span>th triangle. The instance ID corresponds to the ID returned at creation time of the instance.</p>
<p>Testing if any geometry intersects with the ray segment is done through the <code>rtcOccluded</code> functions. Initialization has to be done as for <code>rtcIntersect</code>. If some geometry got found along the ray segment, the geometry ID (<code>geomID</code>) will get set to 0. Other hit information of the ray is undefined after calling <code>rtcOccluded</code>.</p>
<p>In normal mode, data alignment requirements for ray query functions operating on single rays is 16 bytes for the ray. Data alignment requirements for query functions operating on AOS packets of 4, 8, or 16 rays, is 16, 32, and 64 bytes respectively, for the valid mask and the ray. To operate on packets of 4 rays, the CPU has to support SSE, to operate on packets of 8 rays, the CPU has to support AVX, and to operate on packets of 16 rays, the CPU has to support AVX-512 instructions. Additionally, the required ISA has to be enabled in Embree at compile time to use the desired packet size.</p>
<p>The following code shows an example of setting up a single ray and traces it through the scene:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRay ray;
ray.org = ray_origin;
ray.dir = ray_direction;
ray.tnear = <span class="fl">0.</span><span class="er">0f</span>;
ray.tfar = inf;
ray.instID = RTC_INVALID_GEOMETRY_ID;
ray.geomID = RTC_INVALID_GEOMETRY_ID;
ray.primID = RTC_INVALID_GEOMETRY_ID;
ray.mask = <span class="bn">0xFFFFFFFF</span>;
ray.time = <span class="fl">0.</span><span class="er">0f</span>;
rtcIntersect(scene, ray);</code></pre>
<p>See tutorial <a href="tutorials.html#triangle-geometry">Triangle Geometry</a> for a complete example of how to trace rays.</p>
<h3 id="ray-stream-mode">Ray Stream Mode</h3>
<p>For the stream mode new functions got introduced that operate on streams of rays:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcIntersect1M    (RTCScene scene, <span class="dt">const</span> RTCIntersectContext* context,
                        RTCRay* rays, size_t M, size_t stride);
<span class="dt">void</span> rtcIntersect1Mp   (RTCScene scene, <span class="dt">const</span> RTCIntersectContext* context,
                        RTCRay**rays, size_t M);
<span class="dt">void</span> rtcIntersectNM    (RTCScene scene, <span class="dt">const</span> RTCIntersectContext* context,
                        RTCRayN* rays, size_t N, size_t M, size_t stride);
<span class="dt">void</span> rtcIntersectNp    (RTCScene scene, <span class="dt">const</span> RTCIntersectContext* context,
                        RTCRayNp&amp; rays, size_t N);

<span class="dt">void</span> rtcOccluded1M     (RTCScene scene, <span class="dt">const</span> RTCIntersectContext* context,
                        RTCRay* rays, size_t M, size_t stride);
<span class="dt">void</span> rtcOccluded1Mp    (RTCScene scene, <span class="dt">const</span> RTCIntersectContext* context,
                        RTCRay** rays, size_t M);
<span class="dt">void</span> rtcOccludedNM     (RTCScene scene, <span class="dt">const</span> RTCIntersectContext* context,
                        RTCRayN* rays, size_t N, size_t M, size_t stride);
<span class="dt">void</span> rtcOccludedNp     (RTCScene scene, <span class="dt">const</span> RTCIntersectContext* context,
                        RTCRayNp&amp; rays, size_t N, size_t flags);</code></pre>
<p>The <code>rtcIntersectNM</code> and <code>rtcOccludedNM</code> ray stream functions operate on an array of <code>M</code> ray packets of packet size <code>N</code>. The offset in bytes between consecutive ray packets can be specified by the <code>stride</code> parameter. The required data alignment and padding for ray streams is 16 bytes, but for maximum performance, streams should be aligned to the native SIMD size (e.g. 64 bytes for AVX-512). The packet size <code>N</code> has to be larger than 0 and the stream size <code>M</code> can be an arbitrary positive integer including 0. Tracing for example a ray stream consisting of four 8-wide SOA ray packets just requires to set the parameters <code>N</code> to 8, <code>M</code> to 4 and the <code>stride</code> to <code>sizeof(RTCRay8)</code>. A ray in a ray stream is considered inactive during traversal/intersection if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The ray streams functions <code>rtcIntersect1M</code> and <code>rtcOccluded1M</code> are just a shortcut for single ray streams with a packet size of <code>N=1</code>. <code>rtcIntersect1Mp</code> and <code>rtcOccluded1Mp</code> are similar to <code>rtcIntersect1M</code> and <code>rtcOccluded1M</code> while taking a stream of pointers to single rays as input. The <code>rtcIntersectNp</code> and <code>rtcOccludedNp</code> functions do not require the individual components of the SOA ray packets to be stored sequentially in memory, but at different addresses as specified in the <code>RTCRayNp</code> structure.</p>
<p>The intersection context passed to the stream version of the ray query functions, can specify some intersection flags to optimize traversal and a <code>userRayExt</code> pointer that can be used to extent the ray with additional data as described in Section <a href="api.html#extending-the-ray-structure">Extending the Ray Structure</a>. The intersection context is propagated to each stream user callback function invoked.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> RTCIntersectContext
{
  RTCIntersectFlags flags; <span class="co">// intersection flags</span>
  <span class="dt">void</span>* userRayExt;        <span class="co">// can be used to pass extended ray data to callbacks</span>
};</code></pre>
<p>As intersection flag the user can currently specify if Embree should optimize traversal for coherent or incoherent ray distributions.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> RTCIntersectFlags
{
  RTC_INTERSECT_COHERENT   = <span class="dv">0</span>, <span class="co">// optimize for coherent rays</span>
  RTC_INTERSECT_INCOHERENT = <span class="dv">1</span>  <span class="co">// optimize for incoherent rays</span>
};</code></pre>
<p>The following code shows an example of setting up a stream of single rays and tracing it through the scene:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRay rays[<span class="dv">128</span>];

<span class="co">/* first setup all rays */</span>
<span class="kw">for</span> (size_t i=<span class="dv">0</span>; i&lt;<span class="dv">128</span>; i++)
{
  rays[i].org = calculate_ray_org(i);
  rays[i].dir = calculate_ray_dir(i);
  rays[i].tnear = <span class="fl">0.</span><span class="er">0f</span>;
  rays[i].tfar = inf;
  rays[i].instID = RTC_INVALID_GEOMETRY_ID;
  rays[i].geomID = RTC_INVALID_GEOMETRY_ID;
  rays[i].primID = RTC_INVALID_GEOMETRY_ID;
  rays[i].mask = <span class="bn">0xFFFFFFFF</span>;
  rays[i].time = <span class="fl">0.</span><span class="er">0f</span>;
}

<span class="co">/* now create a context and trace the ray stream */</span>
RTCIntersectContext context;
context.flags = RTC_INTERSECT_INCOHERENT;
context.userRayExt = <span class="kw">nullptr</span>;
rtcIntersectNM(scene, &amp;context, &amp;rays, <span class="dv">1</span>, <span class="dv">128</span>, <span class="kw">sizeof</span>(RTCRay));</code></pre>
<p>See tutorial <a href="tutorials.html#stream-viewer">Stream Viewer</a> for a complete example of how to trace ray streams.</p>
<h2 id="interpolation-of-vertex-data">Interpolation of Vertex Data</h2>
<p>Smooth interpolation of per-vertex data is supported for triangle meshes, quad meshs, hair geometry, line segment geometry, and subdivision geometry using the <code>rtcInterpolate2</code> API call. This interpolation function does ignore displacements and always interpolates the underlying base surface.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcInterpolate2(RTCScene scene,
                     <span class="dt">unsigned</span> geomID, <span class="dt">unsigned</span> primID,
                     <span class="dt">float</span> u, <span class="dt">float</span> v,
                     RTCBufferType buffer,
                     <span class="dt">float</span>* P,
                     <span class="dt">float</span>* dPdu, <span class="dt">float</span>* dPdv,
                     <span class="dt">float</span>* ddPdudu, <span class="dt">float</span>* ddPdvdv, <span class="dt">float</span>* ddPdudv,
                     size_t numFloats);</code></pre>
<p>This call smoothly interpolates the per-vertex data stored in the specified geometry buffer (<code>buffer</code> parameter) to the u/v location (<code>u</code> and <code>v</code> parameters) of the primitive (<code>primID</code> parameter) of the geometry (<code>geomID</code> parameter) of the specified scene (<code>scene</code> parameter). The interpolation buffer (<code>buffer</code> parameter) has to contain (at least) <code>numFloats</code> floating point values per vertex to interpolate. As interpolation buffer one can specify the <code>RTC_VERTEX_BUFFER0</code> and <code>RTC_VERTEX_BUFFER1</code> as well as one of two special user vertex buffers <code>RTC_USER_VERTEX_BUFFER0</code> and <code>RTC_USER_VERTEX_BUFFER1</code>. These user vertex buffers can only get set using the <code>rtcSetBuffer2</code> call, they cannot get managed internally by Embree as they have no default layout. The last element of the buffer has to be padded to 16 bytes, such that it can be read safely using SSE instructions.</p>
<p>The <code>rtcInterpolate</code> call stores <code>numFloats</code> interpolated floating point values to the memory location pointed to by <code>P</code>. One can avoid storing the interpolated value by setting <code>P</code> to NULL.</p>
<p>The first order derivative of the interpolation by u and v are stored at the <code>dPdu</code> and <code>dPdv</code> memory locations. One can avoid storing first order derivatives by setting both <code>dPdu</code> and <code>dPdv</code> to NULL.</p>
<p>The second order derivatives are stored at the <code>ddPdudu</code>, <code>ddPdvdv</code>, and <code>ddPdudv</code> memory locations. One can avoid storing second order derivatives by setting these three pointers to NULL.</p>
<p>All output arrays must be padded to 16 bytes. The <code>RTC_INTERPOLATE</code> algorithm flag of a scene has to be enabled to perform interpolations.</p>
<p>It is explicitly allowed to call this function on disabled geometries. This makes it possible to use a separate subdivision mesh with different vertex creases, edge creases, and boundary handling for interpolation of texture coordinates if that is necessary.</p>
<p>The applied interpolation will do linear interpolation for triangle and quad meshes, linear interpolation for line segments, cubic Bézier interpolation for hair, and apply the full subdivision rules for subdivision geometry.</p>
<p>There is also a second interpolate call <code>rtcInterpolateN2</code> that can be used for ray packets.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcInterpolateN2(RTCScene scene, <span class="dt">unsigned</span> geomID,
                      <span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">const</span> <span class="dt">unsigned</span>* primIDs,
                      <span class="dt">const</span> <span class="dt">float</span>* u, <span class="dt">const</span> <span class="dt">float</span>* v, size_t numUVs,
                      RTCBufferType buffer,
                      <span class="dt">float</span>* dP,
                      <span class="dt">float</span>* dPdu, <span class="dt">float</span>* dPdv,
                      <span class="dt">float</span>* ddPdudu, <span class="dt">float</span>* ddPdvdv, <span class="dt">float</span>* ddPdudv,
                      size_t numFloats);</code></pre>
<p>This call is similar to the first version, but gets passed <code>numUVs</code> many u/v coordinates and a valid mask (<code>valid</code> parameter) that specifies which of these coordinates are valid. The valid mask points to <code>numUVs</code> integers and a value of -1 denotes valid and 0 invalid. If the valid pointer is NULL all elements are considers valid. The destination arrays are filled in structure of array (SoA) layout. The value <code>numUVs</code> has to be divisible by 4 and the destination buffer has to be at least <code>numFloats*numUVs</code> elements large.</p>
<p>See tutorial <a href="tutorials.html#interpolation">Interpolation</a> for an example of using the <code>rtcInterpolate2</code> function.</p>
<h2 id="buffer-sharing">Buffer Sharing</h2>
<p>Embree supports sharing of buffers with the application. Each buffer that can be mapped for a specific geometry can also be shared with the application, by passing a pointer, offset, stride, and number of elements of the application side buffer using the <code>rtcSetBuffer2</code> API function.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetBuffer2(RTCScene scene, <span class="dt">unsigned</span> geomID, RTCBufferType type,
                  <span class="dt">void</span>* ptr, size_t offset, size_t stride, size_t size);</code></pre>
<p>The <code>rtcSetBuffer2</code> function has to get called before any call to <code>rtcMapBuffer</code> for that buffer, otherwise the buffer will get allocated internally and the call to <code>rtcSetBuffer2</code> will fail. The buffer has to remain valid as long as the geometry exists, and the user is responsible to free the buffer when the geometry gets deleted. When a buffer is shared, it is safe to modify that buffer without mapping and unmapping it. However, for dynamic scenes one still has to call <code>rtcUpdate</code> for modified geometries and the buffer data has to stay constant from the <code>rtcCommit</code> call to after the last ray query invocation.</p>
<p>The <code>offset</code> parameter specifies a byte offset to the start of the first element, the <code>stride</code> parameter specifies a byte stride between the different elements of the shared buffer and the <code>size</code> parameter specified the number of elements stored inside the buffer. This support for offset and stride allows the application quite some freedom in the data layout of these buffers, however, some restrictions apply. Index buffers always store 32-bit indices and vertex buffers always store single precision floating point data. The start address <code>ptr+offset</code> and <code>stride</code> always have to be aligned to 4 bytes, otherwise the <code>rtcSetBuffer2</code> function will fail. The <code>size</code> parameter can be used to change the size of a buffer, which makes it possible to change the number of elements inside a mesh (by changing the size of the <code>RTC_INDEX_BUFFER</code>).</p>
<p>For vertex buffers (<code>RTC_VERTEX_BUFFER</code> and <code>RTC_USER_VERTEX_BUFFER</code>), the last element must be readable using SSE instructions, thus padding the last element to 16 bytes size is required for some layouts.</p>
<p>The following is an example of how to create a mesh with shared index and vertex buffers:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewTriangleMesh(scene, geomFlags, numTriangles, numVertices);
rtcSetBuffer2(scene, geomID, RTC_VERTEX_BUFFER, vertexPtr, <span class="dv">0</span>, <span class="dv">3</span>*<span class="kw">sizeof</span>(<span class="dt">float</span>), numVertices);
rtcSetBuffer2(scene, geomID, RTC_INDEX_BUFFER, indexPtr, <span class="dv">0</span>, <span class="dv">3</span>*<span class="kw">sizeof</span>(<span class="dt">int</span>), numTriangles);</code></pre>
<p>Sharing buffers can significantly reduce the memory required by the application, thus we recommend using this feature. When enabling the <code>RTC_COMPACT</code> scene flag, the spatial index structures of Embree might also share the vertex buffer, resulting in even higher memory savings.</p>
<h2 id="multi-segment-motion-blur">Multi-Segment Motion Blur</h2>
<p>All geometry types support multi-segment motion blur with equidistant time steps and arbitrary number of time steps in the range of 2 to 129. Each geometry can have a different number of time steps. Some motion blur geometry is constructed by passing the number of time steps to the geometry construction function and setting the vertex arrays <code>RTC_VERTEX_BUFFER0+t</code> for each time step <code>t</code>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewTriangleMesh(scene, geomFlags, numTris, numVertices, <span class="dv">3</span>);
rtcSetBuffer2(scene, geomID, RTC_VERTEX_BUFFER0<span class="dv">+0</span>, vertex0Ptr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Vertex), numVertices);
rtcSetBuffer2(scene, geomID, RTC_VERTEX_BUFFER0<span class="dv">+1</span>, vertex1Ptr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Vertex), numVertices);
rtcSetBuffer2(scene, geomID, RTC_VERTEX_BUFFER0<span class="dv">+2</span>, vertex2Ptr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Vertex), numVertices);
rtcSetBuffer2(scene, geomID, RTC_INDEX_BUFFER, indexPtr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Triangle), numTris);</code></pre>
<p>If a scene contains geometries with motion blur, the user has to set the <code>time</code> member of the ray to a value in the range <span class="math">[0, 1]</span>. The motion blur geometry is defined by linearly interpolating the geometries of neighboring time steps. Each ray can specify a different time, even inside a ray packet.</p>
<h2 id="user-data-pointer">User Data Pointer</h2>
<p>A user data pointer can be specified and queried per geometry, to efficiently map from the geometry ID returned by ray queries to the application representation for that geometry.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span>  rtcSetUserData (RTCScene scene, <span class="dt">unsigned</span> geomID, <span class="dt">void</span>* ptr);
<span class="dt">void</span>* rtcGetUserData (RTCScene scene, <span class="dt">unsigned</span> geomID);</code></pre>
<p>The user data pointer of some user defined geometry get additionally passed to the intersect and occluded callback functions of that user geometry. Further, the user data pointer is also passed to intersection filter callback functions attached to some geometry.</p>
<p>The <code>rtcGetUserData</code> function is on purpose not thread safe with respect to other API calls that modify the scene. Consequently, this function can be used to efficiently query the user data pointer during rendering (also by multiple threads), but should not get called while modifying the scene with other threads.</p>
<h2 id="geometry-mask">Geometry Mask</h2>
<p>A 32-bit geometry mask can be assigned to triangle meshes and hair geometries using the <code>rtcSetMask</code> call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetMask(scene, geomID, mask);</code></pre>
<p>Only if the bitwise <code>and</code> operation of this mask with the mask stored inside the ray is not 0, primitives of this geometry are hit by a ray. This feature can be used to disable selected triangle mesh or hair geometries for specifically tagged rays, e.g. to disable shadow casting for some geometry. This API feature is disabled in Embree by default at compile time, and can be enabled in CMake through the <code>EMBREE_RAY_MASK</code> parameter.</p>
<h2 id="filter-functions">Filter Functions</h2>
<p>The API supports per geometry filter callback functions that are invoked for each intersection found during the <code>rtcIntersect</code> or <code>rtcOccluded</code> calls. The former ones are called intersection filter functions, the latter ones occlusion filter functions. The filter functions can be used to implement various useful features, such as accumulating opacity for transparent shadows, counting the number of surfaces along a ray, collecting all hits along a ray, etc. Filter functions can also be used to selectively reject hits to enable backface culling for some geometries. If the backfaces should be culled in general for all geometries then it is faster to enable <code>EMBREE_BACKFACE_CULLING</code> during compilation of Embree instead of using filter functions.</p>
<p>If the <code>RTC_SCENE_HIGH_QUALITY</code> mode is set, the intersection and occlusion filter functions may be called multiple times for the same hit. For some usage scenarios, the application may have to work around this by collecting already reported hits (geomID/primID pairs) and ignoring duplicates for some usage scenarios.</p>
<h3 id="normal-mode-1">Normal Mode</h3>
<p>In normal mode the filter functions provided by the user need to have the following signature:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> RTCFilterFunc  (                   <span class="dt">void</span>* userDataPtr, RTCRay&amp;   ray);
<span class="dt">void</span> RTCFilterFunc4 (<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userDataPtr, RTCRay4&amp;  ray);
<span class="dt">void</span> RTCFilterFunc8 (<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userDataPtr, RTCRay8&amp;  ray);
<span class="dt">void</span> RTCFilterFunc16(<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userDataPtr, RTCRay16&amp; ray);</code></pre>
<p>The <code>valid</code> pointer points to an integer valid mask (0 means invalid and -1 means valid). The <code>userDataPtr</code> is a user pointer optionally set per geometry through the <code>rtcSetUserData</code> function. All hit information inside the ray is valid. If the hit geometry is instanced, the <code>instID</code> member of the ray is valid and the ray origin, direction, and geometry normal visible through the ray are in object space.</p>
<p>The filter function can reject a hit by setting the <code>geomID</code> member of the ray to <code>RTC_INVALID_GEOMETRY_ID</code>, otherwise the hit is accepted. The filter function is not allowed to modify the ray input data (<code>org</code>, <code>dir</code>, <code>time</code>, <code>mask</code>, and <code>tnear</code> members), but can modify the hit data of the ray (<code>u</code>, <code>v</code>, <code>Ng</code>, <code>tfar</code>, <code>geomID</code>, <code>primID</code>, and <code>instID</code> members). Updating the <code>tfar</code> distance to a smaller value is possible without limitation. However, increasing the <code>tfar</code> distance of the ray to a larger value <code>tfar'</code> , does not guarantee intersections between <code>tfar</code> and <code>tfar'</code> to be reported later, as the corresponding subtrees might have gotten culled already.</p>
<p>The intersection and occlusion filter functions for different ray types are set for some geometry of a scene using the following API functions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetIntersectionFilterFunction  (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc   filter);
<span class="dt">void</span> rtcSetIntersectionFilterFunction4 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc4  filter);
<span class="dt">void</span> rtcSetIntersectionFilterFunction8 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc8  filter);
<span class="dt">void</span> rtcSetIntersectionFilterFunction16(RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc16 filter);

<span class="dt">void</span> rtcSetOcclusionFilterFunction  (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc   filter);
<span class="dt">void</span> rtcSetOcclusionFilterFunction4 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc4  filter);
<span class="dt">void</span> rtcSetOcclusionFilterFunction8 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc8  filter);
<span class="dt">void</span> rtcSetOcclusionFilterFunction16(RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc16 filter);</code></pre>
<p>The intersection and occlusion filter functions of type <code>RTCFilterFunc</code> are only called by the <code>rtcIntersect</code> and <code>rtcOccluded</code> functions. Similar the filter functions of type <code>FilterFunc4</code>, <code>FilterFunc8</code>, and <code>FilterFunc16</code> are called by <code>rtcIntersect4/8/16</code> and <code>rtcOccluded4/8/16</code> of matching width.</p>
<h3 id="stream-mode">Stream Mode</h3>
<p>For ray stream mode a new type of filter function <code>RTCFilterFuncN</code> got introduced:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> RTCFilterFuncN (<span class="dt">int</span>* valid,
                     <span class="dt">void</span>* userDataPtr,
                     <span class="dt">const</span> RTCIntersectContext* context,
                     RTCRayN* ray,
                     <span class="dt">const</span> RTCHitN* potentialHit,
                     <span class="dt">const</span> size_t N);</code></pre>
<p>The stream intersection and occlusion filter functions of this new type are set for some geometry of a scene using the following API functions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetIntersectionFilterFunctionN (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFuncN filter);
<span class="dt">void</span> rtcSetOcclusionFilterFunctionN    (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFuncN filter);</code></pre>
<p>For the callback <code>RTCFilterFuncN</code>, the <code>valid</code> parameter points to an integer valid mask (0 means invalid and -1 means valid). The <code>userDataPtr</code> is a user pointer optionally set per geometry through the <code>rtcSetUserData</code> function. The <code>context</code> parameter points to the intersection context passed to the ray query function. The <code>ray</code> parameter contains the current ray. All hit data inside the <code>ray</code> are undefined, except the <code>tfar</code> value. The <code>potentialHit</code> parameter points to the new hit to test and update. The <code>N</code> parameter is the number of rays and hits found in the <code>ray</code> and <code>potentialHit</code>. If the hit geometry is instanced, the <code>instID</code> member of the ray is valid and the ray as well as the potential hit are in object space.</p>
<p>As the ray packet size <code>N</code> can be arbitrary, the ray and hit should get accessed through the helper functions as describe in Section <a href="api.html#ray-layout">Ray Layout</a>.</p>
<p>The callback function has the task to check for each valid ray whether it wants to accept or reject the corresponding hit. To reject a hit, the filter callback function just has to write <code>0</code> to the integer valid mask of the corresponding ray. The filter function is not allowed to modify the ray input data (<code>org</code>, <code>dir</code>, <code>time</code>, <code>mask</code>, and <code>tnear</code> members), nor the potential hit, nor inactive components.</p>
<p>An intersection filter callback function can accept a hit by updating all hit data members of the ray (<code>u</code>, <code>v</code>, <code>Ng</code>, <code>tfar</code>, <code>geomID</code>, <code>primID</code>, and <code>instID</code> members) and keep the valid mask set to <code>-1</code>.</p>
<p>An occlusion filter callback function can accept a hit by setting the <code>geomID</code> member of the ray to <code>0</code> and keep the valid mask set to <code>-1</code>.</p>
<p>The intersection filter callback of most applications will just copy the <code>potentialHit</code> into the appropiate fields of the ray, but this is not a requirement and the hit data of the ray can get modified arbitrarily. Updating the <code>tfar</code> distance to a smaller value (e.g. the <code>t</code> distance of the potential hit) is possible without limitation. However, increasing the <code>tfar</code> distance of the ray to a larger value <code>tfar'</code> , does not guarantee intersections between <code>tfar</code> and <code>tfar'</code> to be reported later, as the corresponding subtrees might have gotten culled already.</p>
<h2 id="displacement-mapping-functions">Displacement Mapping Functions</h2>
<p>The API supports displacement mapping for subdivision meshes. A displacement function can be set for some subdivision mesh using the <code>rtcSetDisplacementFunction</code> API call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetDisplacementFunction2(RTCScene, <span class="dt">unsigned</span> geomID, RTCDisplacementFunc, RTCBounds*);</code></pre>
<p>A displacement function of <code>NULL</code> will delete an already set displacement function. The bounds parameter is optional. If <code>NULL</code> is passed as bounds, then the displacement shader will get evaluated during the build process to properly bound displaced geometry. If a pointer to some bounds of the displacement are passed, then the implementation can choose to use these bounds to bound displaced geometry. When bounds are specified, then these bounds have to be conservative and should be tight for best performance.</p>
<p>The displacement function has to have the following type:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*RTCDisplacementFunc2)(<span class="dt">void</span>* ptr,
                                     <span class="dt">unsigned</span> geomID, <span class="dt">unsigned</span> primID, <span class="dt">unsigned</span> timeStep,
                                     <span class="dt">const</span> <span class="dt">float</span>* u,  <span class="dt">const</span> <span class="dt">float</span>* v,
                                     <span class="dt">const</span> <span class="dt">float</span>* nx, <span class="dt">const</span> <span class="dt">float</span>* ny, <span class="dt">const</span> <span class="dt">float</span>* nz,
                                     <span class="dt">float</span>* px, <span class="dt">float</span>* py, <span class="dt">float</span>* pz,
                                     size_t N);</code></pre>
<p>The displacement function is called with the user data pointer of the geometry (<code>ptr</code>), the geometry ID (<code>geomID</code>), and primitive ID (<code>primID</code>) of a patch to displace. For motion blur the time step <code>timeStep</code> is also specified, such that the function can be time varying. For the patch, a number N of points to displace are specified in a struct of array layout. For each point to displace the local patch UV coordinates (<code>u</code> and <code>v</code> arrays), the normalized geometry normal (<code>nx</code>, <code>ny</code>, and <code>nz</code> arrays), as well as world space position (<code>px</code>, <code>py</code>, and <code>pz</code> arrays) are provided. The task of the displacement function is to use this information and move the world space position inside the allowed specified bounds around the point.</p>
<p>All passed arrays are guaranteed to be 64 bytes aligned, and properly padded to make wide vector processing inside the displacement function possible.</p>
<p>The displacement mapping functions might get called during the <code>rtcCommit</code> call, or lazily during the <code>rtcIntersect</code> or <code>rtcOccluded</code> calls.</p>
<p>Also see tutorial <a href="tutorials.html#displacement-geometry">Displacement Geometry</a> for an example of how to use the displacement mapping functions.</p>
<h2 id="extending-the-ray-structure">Extending the Ray Structure</h2>
<h3 id="normal-mode-2">Normal Mode</h3>
<p>If Embree is used in normal mode, the ray passed to the filter callback functions and user geometry callback functions is guaranteed to be the same ray pointer initially provided to the ray query function by the user. For that reason, it is safe to extend the ray by additional data and access this data inside the filter callback functions (e.g. to accumulate opacity) and user geometry callback functions.</p>
<h3 id="stream-mode-1">Stream Mode</h3>
<p>If Embree is used in stream mode, the ray passed to the filter callback and user geometry callback functions is <code>not</code> guaranteed to be the same ray pointer initially passed to the ray query function, as the stream implementation may decide to copy rays around, reorder them, and change the data layout internally when appropiate (e.g. SOA to AOS conversion).</p>
<p>To identify specific rays in the callback functions, the user has to pass an ID with each ray and set the <code>userRayExt</code> member of the intersection context to point to its ray extensions. The ray extensions can be stored in a seprarate memory location but also just after the end of each ordinary ray (or ray packet). In the latter case, you can just point the <code>userRayExt</code> to the input rays.</p>
<p>To encode a ray ID the ray mask field can be used entirely when the ray mask feature is disabled, or unused bits of the ray mask can be used in case the ray mask feature is enabled (e.g. by using the lower 16 bits as ray ID, and the upper 16 bits as ray mask, and setting the lower 16 bits of each geometry mask always to 0).</p>
<p>The intersection context provided to the stream ray query functions is passed to each stream callback function (e.g. <code>RTCIntersectFuncN</code>, <code>RTCIntersectFunc1Mp</code>, or <code>RTCFilterFuncN</code>). Thus, in the callback function, the ray ID can get decoded, and the extended ray data accessed through the <code>userRayExt</code> pointer stored inside the intersection context. For SPMD type programs this access requires <code>gather</code> and <code>scatter</code> operations to access the user ray extensions.</p>
<p>Not that using the ray ID to access the ray extensions is necessary, as the ray IDs might have changed from the IDs passed to the ray query function. E.g. if you trace a ray packet with 8 rays 0 to 8, then even if a callback gets called with a ray packet of 8 rays, they rays might have gotten reordered. Further, the callback might get called with a subpacket of a size smaller than 8 (e.g. <code>N=5</code>). However, optimizing for the common case in which Embree keeps such a packet intact (thus having a special codepath for <code>N=8</code> and unchanged IDs) can give higher performance.</p>
<h2 id="sharing-threads-with-embree">Sharing Threads with Embree</h2>
<p>On some implementations, Embree supports using the application threads when building internal data structures, by using the</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcCommitThread(RTCScene, <span class="dt">unsigned</span> threadIndex, <span class="dt">unsigned</span> threadCount);</code></pre>
<p>API call to commit the scene. This function has to get called by all threads that want to cooperate in the scene commit. Each call is provided the scene to commit, the index of the calling thread in the range [0, <code>threadCount</code>-1], and the number of threads that will call into this commit operation for the scene. All threads will return again from this function after the scene commit is finished.</p>
<p>Multiple such scene commit operations can also be running at the same time, e.g. it is possible to commit many small scenes in parallel using one thread per commit operation. Subsequent commit operations for the same scene can use different number of threads in the <code>rtcCommitThread</code> or use the Embree internal threads using the <code>rtcCommit</code> call.</p>
<p><em>Note:</em> When using Embree with the Intel® Threading Building Blocks (which is the default) you should not use the <code>rtcCommitThread</code> function. Sharing of your threads with TBB is not possible and TBB will always generate its own set of threads. We recommend to also use TBB inside your application to share threads with the Embree library. When using TBB inside your application do never use the <code>rtcCommitThread</code> function.</p>
<p><em>Note:</em> When enabling the Embree internal tasking system the <code>rtcCommitThread</code> feature will work as expected and use the application threads for hierarchy building.</p>
<h2 id="join-build-operation">Join Build Operation</h2>
<p>The special <code>rtcCommitJoin</code> function can be used from multiple threads to join a scene build operation. All thread have to consistently call <code>rtcCommitJoin</code> and no other commit variant.</p>
<p>This feature allows a flexible way to lazily create hierarchies during rendering. A thread reaching a not yet constructed sub-scene of a two-level scene, can generate the sub-scene geometry and call <code>rtcCommitJoin</code> on that just generated scene. During construction, further threads reaching the not-yet-built scene, can join the build operation by also invoking <code>rtcCommitJoin</code>. A thread that calls <code>rtcCommitJoin</code> after the build finishes, will directly return from the <code>rtcCommitJoin</code> call (even for static scenes).</p>
<p><em>Note:</em> When using Embree with the Intel® Threading Building Blocks, thread that call <code>rtcCommitJoin</code> will join the build operation, but other TBB worker threads might also participate in the build. To avoid thread oversubscription, we recommend using TBB also inside the application. Further, the join mode only works properly starting with TBB v4.4 Update 1. For earlier TBB versions threads that call <code>rtcCommitJoin</code> to join a running build will just wait for the build to finish.</p>
<p><em>Note:</em> When using Embree with the internal tasking system, exclusively threads that call <code>rtcCommitJoin</code> will perform the build operation, and no additional worker threads are scheduled.</p>
<h2 id="memory-monitor-callback">Memory Monitor Callback</h2>
<p>Using the memory monitor callback mechanism, the application can track the memory consumption of an Embree device, and optionally terminate API calls that consume too much memory.</p>
<p>The user provided memory monitor callback function must have the following signature:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> (*RTCMemoryMonitorFunc2)(<span class="dt">void</span>* userPtr, <span class="dt">const</span> ssize_t bytes, <span class="dt">const</span> <span class="dt">bool</span> post);</code></pre>
<p>A single such callback function per device can be registered by calling</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcDeviceSetMemoryMonitorFunction2(RTCDevice, RTCMemoryMonitorFunc2, <span class="dt">void</span>* userPtr);</code></pre>
<p>and deregistered again by calling it with <code>NULL</code> as function pointer. Once registered the Embree device will invoke the callback function before or after it allocates or frees important memory blocks. The <code>userPtr</code> value that is set at registration time is passed to each invokation of the callback function. The callback function might get called from multiple threads concurrently.</p>
<p>The application can track the current memory usage of the Embree device by atomically accumulating the provided <code>bytes</code> input parameter. This parameter will be &gt;0 for allocations and &lt;0 for deallocations. The <code>post</code> input parameter is true if the callback function was invoked after the allocation or deallocation, otherwise it is false.</p>
<p>Embree will continue its operation normally when returning true from the callback function. If false is returned, Embree will cancel the current operation with the RTC_OUT_OF_MEMORY error code. Cancelling will only happen when the callback was called for allocations (bytes &gt; 0), otherwise the cancel request will be ignored. If a callback that was invoked before the allocation happens (<code>post == false</code>) cancels the operation, then the <code>bytes</code> parameter should not get accumulated, as the allocation will never happen. If a callback that was called after the allocation happened (<code>post == true</code>) cancels the operation, then the <code>bytes</code> parameter should get accumulated, as the allocation properly happened. Issuing multiple cancel requests for the same operation is allowed.</p>
<h2 id="progress-monitor-callback">Progress Monitor Callback</h2>
<p>The progress monitor callback mechanism can be used to report progress of hierarchy build operations and to cancel long lasting build operations.</p>
<p>The user provided progress monitor callback function has to have the following signature:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> (*RTCProgressMonitorFunc)(<span class="dt">void</span>* userPtr, <span class="dt">const</span> <span class="dt">double</span> n);</code></pre>
<p>A single such callback function can be registered per scene by calling</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetProgressMonitorFunction(RTCScene, RTCProgressMonitorFunc, <span class="dt">void</span>* userPtr);</code></pre>
<p>and deregistered again by calling it with <code>NULL</code> for the callback function. Once registered Embree will invoke the callback function multiple times during hierarchy build operations of the scene, by providing the <code>userPtr</code> pointer that was set at registration time, and a double <code>n</code> in the range <span class="math">[0, 1]</span> estimating the completion amount of the operation. The callback function might get called from multiple threads concurrently.</p>
<p>When returning <code>true</code> from the callback function, Embree will continue the build operation normally. When returning <code>false</code> Embree will cancel the build operation with the RTC_CANCELLED error code. Issuing multiple cancel requests for the same build operation is allowed.</p>
<h2 id="configuring-embree">Configuring Embree</h2>
<p>Some internal device parameters can be set and queried using the <code>rtcDeviceSetParameter1i</code> and <code>rtcDeviceGetParameter1i</code> API call. The parameters from the following table are available to set/query:</p>
<table>
<caption>Parameters for <code>rtcDeviceSetParameter</code> and <code>rtcDeviceGetParameter</code>.</caption>
<colgroup>
<col width="42%" />
<col width="41%" />
<col width="13%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="left">Description</th>
<th align="left">Read/Write</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_CONFIG_VERSION_MAJOR</td>
<td align="left">returns Embree major version</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_VERSION_MINOR</td>
<td align="left">returns Embree minor version</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_VERSION_PATCH</td>
<td align="left">returns Embree patch version</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_VERSION</td>
<td align="left">returns Embree version as integer e.g. Embree v2.8.2 → 20802</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_INTERSECT1</td>
<td align="left">checks if <code>rtcIntersect1</code> is supported</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_INTERSECT4</td>
<td align="left">checks if <code>rtcIntersect4</code> is supported</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_INTERSECT8</td>
<td align="left">checks if <code>rtcIntersect8</code> is supported</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_INTERSECT16</td>
<td align="left">checks if <code>rtcIntersect16</code> is supported</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_INTERSECT_STREAM</td>
<td align="left">checks if <code>rtcIntersect1M</code>, <code>rtcIntersect1Mp</code>, <code>rtcIntersectNM</code>, and <code>rtcIntersectNp</code> are supported</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_TRIANGLE_GEOMETRY</td>
<td align="left">checks if triangle geometries are supported</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_QUAD_GEOMETRY</td>
<td align="left">checks if quad geometries are supported</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_LINE_GEOMETRY</td>
<td align="left">checks if line geometries are supported</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_HAIR_GEOMETRY</td>
<td align="left">checks if hair geometries are supported</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_SUBDIV_GEOMETRY</td>
<td align="left">checks if subdivision meshes are supported</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_USER_GEOMETRY</td>
<td align="left">checks if user geometries are supported</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_RAY_MASK</td>
<td align="left">checks if ray masks are supported</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_BACKFACE_CULLING</td>
<td align="left">checks if backface culling is supported</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_INTERSECTION_FILTER</td>
<td align="left">checks if intersection filters are enabled</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_INTERSECTION_FILTER_RESTORE</td>
<td align="left">checks if intersection filters restore previous hit</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_IGNORE_INVALID_RAYS</td>
<td align="left">checks if invalid rays are ignored</td>
<td align="left">Read only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_TASKING_SYSTEM</td>
<td align="left">return used tasking system (0 = INTERNAL, 1 = TBB, 2 = PPL)</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_SOFTWARE_CACHE_SIZE</td>
<td align="left">Configures the software cache size (used to cache subdivision surfaces for instance). The size is specified as an integer number of bytes. The software cache cannot be configured during rendering.</td>
<td align="left">Write only</td>
</tr>
<tr class="odd">
<td align="left">RTC_CONFIG_COMMIT_JOIN</td>
<td align="left">Checks if rtcCommit can be used to join build operation (not supported when Embree is compiled with some older TBB versions)</td>
<td align="left">Read only</td>
</tr>
<tr class="even">
<td align="left">RTC_CONFIG_COMMIT_THREAD</td>
<td align="left">Checks if rtcCommitThread is available (not supported when Embree is compiled with some older TBB versions)</td>
<td align="left">Read only</td>
</tr>
</tbody>
</table>
<p>For example, to configure the size of the internal software cache that is used to handle subdivision surfaces use the <code>RTC_SOFTWARE_CACHE_SIZE</code> parameter to set desired size of the cache in bytes:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcDeviceSetParameter1i(device, RTC_SOFTWARE_CACHE_SIZE, bytes);</code></pre>
<p>The software cache cannot get configured while any Embree API call is executed. Best configure the size of the cache only once at application start.</p>
<h2 id="limiting-number-of-build-threads">Limiting number of Build Threads</h2>
<p>You can use the TBB API to limit the number of threads used by Embree during hierarchy construction. Therefore just create a global taskscheduler_init object, initialized with the number of threads to use:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;tbb/tbb.h&gt;</span>

tbb::task_scheduler_init init(numThreads);</code></pre>
<h2 id="thread-creation-and-affinity-settings">Thread Creation and Affinity Settings</h2>
<p>Tasking systems like TBB create worker threads on demand which will add a runtime overhead for the very first <code>rtcCommit</code> call. In case you want to benchmark the scene build time, you should start threads at application startup. You can let Embree start TBB threads by passing <code>start_threads=1</code> to the init parameter of <code>rtcNewDevice</code>.</p>
<p>On machines with a high thread count (e.g. dual-socket Xeon or Xeon Phi machines), affinitizing TBB worker threads increases build and rendering performance. You can let Embree affinitize TBB worker threads by passing <code>set_affinity=1</code> to the init parameter of <code>rtcNewDevice</code>. By default threads are not affinitized by Embree with the exception of Xeon Phi Processors where they are affinitized by default.</p>
<p>All Embree tutorials automatically start and affinitize TBB worker threads by passing <code>start_threads=1,set_affinity=1</code> to <code>rtcNewDevice</code>.</p>
<h2 id="huge-page-support">Huge Page Support</h2>
<p>Embree supports 2MB huge pages under Windows, Linux, and MacOSX. Under Linux huge page support is enabled by default and under Windows and MacOSX disabled by default. Huge page support can get enabled in Embree by passing <code>hugepages=1</code> to <code>rtcNewDevice</code> or disabled by passing <code>hugepages=0</code> to <code>rtcNewDevice</code>.</p>
<p>We recommend using 2MB huge pages with Embree under Linux as this improves ray tracing performance by about 5 - 10%. Under Windows using huge pages requires the application to run in elavated mode which is a security issue. Under MacOSX huge pages are rarely available as memory tends to get quickly fragmented.</p>
<h3 id="huge-pages-under-windows">Huge Pages under Windows</h3>
<p>To use huge pages under Windows, the current user must have the “Lock pages in memory” (SeLockMemoryPrivilege) assigned. This can be configured through the “Local Security Policy” application, by adding a user to “Local Policies” -&gt; “User Rights Assignment” -&gt; “Lock pages in memory”. You have to log out and in again for this change to take effect.</p>
<p>Further, your application has to be executed as an elevated process (“Run as administrator”) and the “SeLockMemoryPrivilege” must explicitely be enabled by your application. Example code on how to enable this privilege can be found in the “common/sys/alloc.cpp” file of Embree. Alternatively, Embree will try to enable this privilege when passing <code>enable_selockmemoryprivilege=1</code> to <code>rtcNewDevice</code>. Further, huge pages have to get enabled in Embree by passing <code>hugepages=1</code> to <code>rtcNewDevice</code>.</p>
<p>When the system was running for a while, physical memory gets fragmented, which can slow down the allocation of huge pages significantly.</p>
<h3 id="huge-pages-under-linux">Huge Pages under Linux</h3>
<p>Linux supports transparent huge pages and explicit huge pages. To enable transparent huge page support under Linux execute the following as root:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">echo always &gt; /sys/kernel/mm/transparent_hugepage/enabled</code></pre>
<p>When transparent huge pages are enabled, the kernel tries to merge 4k pages to 2MB pages when possible as a background job. See the following webpage for more information on <a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt">transparent huge pages under Linux</a>. In this mode each application, including your rendering application building on Embree, will automatically tend to use huge pages.</p>
<p>Using transparent huge pages the transitioning from 4k to 2MB pages might take some time. For that reason Embree also supports allocating 2MB pages directly when a huge page pool is configured. Such a pool can get configured by writing some number of huge pages to alloacte to <code>/proc/sys/vm/nr_overcommit_hugepages</code> as root user. E.g. to configure 2GB of adress space for huge page allocation, execute the following as root:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">echo <span class="dv">1000</span> &gt; /proc/sys/vm/nr_overcommit_hugepages</code></pre>
<p>See the following webpage for more information on <a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">huge pages under Linux</a>.</p>
<h3 id="huge-pages-under-macosx">Huge Pages under MacOSX</h3>
<p>To use huge pages under MacOSX you have to pass <code>hugepages=1</code> to <code>rtcNewDevice</code> to enable that feature in Embree.</p>
<p>When the system was running for a while, physical memory gets quickly fragmented, and causes huge page allocations to fail. For this reason huge pages not very usefull under MacOSX in practise.</p>
<h2 id="bvh-builder-api">BVH Builder API</h2>
<p>The Embree API exposes internal BVH builders to build BVHs with any desired node and leaf layout. To invoke the BVH builder you have to create a BVH object using the <code>rtcNewBVH</code> function and deleted again using the <code>rtcDeleteBVH</code> function.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCBVH rtcNewBVH(RTCDevice);
<span class="dt">void</span> rtcDeleteBVH(RTCBVH);</code></pre>
<p>This BVH contains some builder state and fast node allocator. Some settings have to be passed to be BVH build function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> RTCBuildQuality
{
  RTC_BUILD_QUALITY_LOW = <span class="dv">0</span>,    <span class="co">// build low quality BVH (good for dynamic scenes)</span>
  RTC_BUILD_QUALITY_NORMAL = <span class="dv">1</span>, <span class="co">// build standard quality BVH</span>
  RTC_BUILD_QUALITY_HIGH = <span class="dv">2</span>,   <span class="co">// build high quality BVH</span>
};
  
<span class="kw">struct</span> RTCBuildSettings
{
  <span class="dt">unsigned</span> size;               <span class="co">// size of this structure in bytes</span>
  RTCBuildQuality quality;     <span class="co">// quality of BVH build</span>
  <span class="dt">unsigned</span> maxBranchingFactor; <span class="co">// branching factor of BVH to build</span>
  <span class="dt">unsigned</span> maxDepth;           <span class="co">// maximal depth of BVH to build</span>
  <span class="dt">unsigned</span> sahBlockSize;       <span class="co">// blocksize for SAH heuristic</span>
  <span class="dt">unsigned</span> minLeafSize;        <span class="co">// minimal size of a leaf</span>
  <span class="dt">unsigned</span> maxLeafSize;        <span class="co">// maximal size of a leaf</span>
  <span class="dt">float</span> travCost;              <span class="co">// estimated cost of one traversal step</span>
  <span class="dt">float</span> intCost;               <span class="co">// estimated cost of one primitive intersection</span>
  <span class="dt">unsigned</span> extraSpace;         <span class="co">// for spatial splitting we need extra space at end of primitive array</span>
};</code></pre>
<p>Some default values for the settings can be obtained using the <code>rtcDefaultBuildSettings</code> function. Using the <code>quality</code> setting, one can select between a faster low quality build which is good for dynamic scenes, and a standard quality build for static scenes. One can also specify the desired maximal branching factor of the BVH (<code>maxBranchingFactor</code> setting), the maximal depth the BVH should have (<code>maxDepth</code> setting), some power of 2 block size for the SAH heuristic (<code>sahBlockSize</code>), the minimal and maximal leaf size (<code>minLeafSize</code> and <code>maxLeafSize</code> setting), and the estimated cost of one traversal step and primitve intersection (<code>travCost</code> and <code>intCost</code> setting). To spatially split primitives in high quality mode, the builder needs some extra space at the end of the build primitive array. The amount of extra space can be passed using the <code>extraSpace</code> setting, and should be about the same size as there are primitives. The <code>size</code> member has always to be set to the size of the <code>RTCBuildSettings</code> structure in bytes.</p>
<p>Four callback functions have to get registered which are invoked during build to create BVH nodes (<code>RTCCreateNodeFunc</code>), set the pointers to all children (<code>RTCSetNodeChildrenFunc</code>), set the bounding boxes of all children (<code>RTCSetNodeBoundsFunc</code>), and to create a leaf node (<code>RTCCreateLeafFunc</code>).</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span>* (*RTCCreateNodeFunc) (RTCThreadLocalAllocator, size_t numChildren, <span class="dt">void</span>* userPtr);

<span class="kw">typedef</span> <span class="dt">void</span>  (*RTCSetNodeChildFunc) (<span class="dt">void</span>* nodePtr, <span class="dt">void</span>** childPtrs, size_t numChildren,
                                      <span class="dt">void</span>* userPtr);

<span class="kw">typedef</span> <span class="dt">void</span>  (*RTCSetNodeBoundsFunc) (<span class="dt">void</span>* nodePtr, <span class="dt">const</span> RTCBounds**, size_t numChildren,
                                       <span class="dt">void</span>* userPtr);

<span class="kw">typedef</span> <span class="dt">void</span>* (*RTCCreateLeafFunc) (RTCThreadLocalAllocator, <span class="dt">const</span> RTCBuildPrimitive* prims,
                                    size_t numPrimitives, <span class="dt">void</span>* userPtr);

<span class="kw">typedef</span> <span class="dt">void</span>  (*RTCSplitPrimitiveFunc) (<span class="dt">const</span> RTCBuildPrimitive&amp;, <span class="dt">unsigned</span> dim, <span class="dt">float</span> pos,
                                        RTCBounds&amp; lbounds, RTCBounds&amp; rbounds, <span class="dt">void</span>* userPtr);</code></pre>
<p>The <code>RTCCreateNodeFunc</code> and <code>RTCCreateLeafFunc</code> type callbacks are passed a thread local allocator object that should be used for fast allocation of nodes using the <code>rtcThreadLocalAlloc</code> function.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span>* rtcThreadLocalAlloc(RTCThreadLocalAllocator, size_t bytes, size_t align);</code></pre>
<p>We strongly recommend using this allocation mechanism, as alternative approaches like standard <code>malloc</code> can be over 10× slower. The allocator object passed to the create callbacks has to be used only inside the current thread.</p>
<p>The <code>RTCCreateNodeFunc</code> callback additionally gets passed the number of children for this node in the range from 2 to maxBranchingFactor (<code>numChildren</code> argument).</p>
<p>The <code>RTCSetNodeChildFunc</code> callback function, gets passed a pointer to the node as input (<code>nodePtr</code> argument), an array of pointers to the children (<code>childPtrs</code> argument), and the size of this array (<code>numChildren</code> argument).</p>
<p>The <code>RTCSetNodeBoundsFunc</code> callback function, get a pointer to the node as input (<code>nodePtr</code> argument), an array of pointers to the bounding boxes of the children (<code>bounds</code> argument), and the size of this array (<code>numChildren</code> argument).</p>
<p>The <code>RTCCreateLeafFunc</code> callback additionally get an array of primitives as input (<code>primitives</code> argument), and the size of this array (<code>numPrimitives</code> argument). The callback should read the <code>geomID</code> and <code>primID</code> members from the passed primitives to construct the leaf.</p>
<p>The <code>RTCSplitPrimitiveFunc</code> callback is invoked in high quality mode to split a primitive (<code>prim</code> argument) at some specified position (<code>pos</code> argument) and dimension (<code>dim</code> argument). The callback should return bounds of the clipped left and right part of the primitive (<code>lbounds</code> and <code>rbounds</code> arguments).</p>
<p>There is an optional progress callback function that can be used to get progress on the BVH build.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*RTCBuildProgressFunc) (size_t N, <span class="dt">void</span>* userPtr);</code></pre>
<p>This progress function is called with a number <code>N</code> of primitives the build is finished for. Accumulating over all invokations will sum up to the number of primitives passed to be BVH build function.</p>
<p>All callback functions are typically called from multiple threads, thus their implementation has to be thread safe.</p>
<p>All callback function get a user defined pointer (<code>userPtr</code> argument) as input which is provided to the <code>rtcBuildBVH</code> call. This pointer can be used to access the application scene object inside the callback functions.</p>
<p>The BVH build is invoked using the <code>rtcBuildBVH</code> function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span>* rtcBuildBVH(RTCBVH bvh,                             <span class="co">// BVH to build</span>
                  <span class="dt">const</span> RTCBuildSettings&amp; settings,       <span class="co">// settings for BVH builder</span>
                  RTCBuildPrimitive* primitives,          <span class="co">// list of input primitives</span>
                  size_t numPrimitives,                   <span class="co">// number of input primitives</span>
                  RTCCreateNodeFunc createNode,           <span class="co">// creates a node</span>
                  RTCSetNodeChildrenFunc setNodeChildren, <span class="co">// sets pointer to a child</span>
                  RTCSetNodeBoundsFunc setNodeBounds,     <span class="co">// sets bound of a child</span>
                  RTCCreateLeafFunc createLeaf,           <span class="co">// creates a leaf</span>
                  RTCSplitPrimitiveFunc splitPrimitive,   <span class="co">// splits a primitive into two halves</span>
                  RTCBuildProgressFunc buildProgress      <span class="co">// used to report build progress</span>
                  <span class="dt">void</span>* userPtr);                         <span class="co">// user pointer passed to callback functions</span></code></pre>
<p>The function gets passed the BVH objects (<code>bvh</code> argument), the build settings to use (<code>settings</code> argument), the array of primitives (<code>primitives</code> argument) and its size (<code>numPrimitives</code> argument), the previously described callback function pointers, and a user defined pointer (<code>userPtr</code> argument) that is passed to all callback functions. The function pointer to the primitive split function (<code>splitPrimitive</code> argument) may be <code>NULL</code>, however, then no spatial splitting in high quality mode is possible. The function pointer used to report the build progress (<code>buildProgress</code> argument) is optional and may also be <code>NULL</code>.</p>
<p>For static scenes that do not require a further <code>rtcBuildBVH</code> call one should use the <code>rtcMakeStatic</code> function after the build which clears some internal data.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcMakeStaticBVH(RTCBVH);</code></pre>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Note that <code>Ng</code> is in object space and needs to be transformed to world space for instanced scenes.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
      </div>

      <div id="footer">
        © 2009–2017 Intel Corporation <a href="legal.html">Disclaimer and Legal Information</a>
      </div>
    </div>
  </body>
</html>
