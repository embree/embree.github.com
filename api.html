<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Embree: High Performance Ray Tracing Kernels" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <title>Intel® Embree</title>
    <link rel="icon" type="image/png" href="images/icon192.png" sizes="192x192">
    <link rel="SHORTCUT ICON" HREF="images/icon32.ico">
    <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
div.sourceCode { overflow-x: initial; }
    </style>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <div class="inner">
        <a id="forkme_banner" href="https://github.com/embree">View on GitHub</a>
        <h1 id="project_title">Intel® Embree</h1>
        <h2 id="project_tagline">High Performance Ray Tracing Kernels</h2>
      </div>

      <div id="nav">
      <div id="nbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
          <li><a href="downloads.html">Downloads</a></li>
          <li id="selected"><a href="api.html">API</a></li>
          <li><a href="tutorials.html">Tutorials</a></li>
          <li><a href="gallery.html">Gallery</a></li>
          <li><a href="related.html">Related Projects</a></li>
        </ul>
      </div>
      </div>

    </div>

    <a id="news_banner" href="https://github.com/embree/embree/releases">
      We recently released Intel® Embree v3.9.0!
    </a>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <div id="main_content" class="inner">
<h1 id="embree-api">Embree API</h1>
<p>The Embree API is a low-level C99 ray tracing API which can be used to construct 3D scenes and perform ray queries of different types inside these scenes. All API calls carry the prefix <code>rtc</code> (or <code>RTC</code> for types) which stands for <strong>r</strong>ay <strong>t</strong>racing <strong>c</strong>ore.</p>
<p>The API also exists in an ISPC version, which is almost identical but contains additional functions that operate on ray packets with a size of the native SIMD width used by ISPC. For simplicity this document refers to the C99 version of the API functions. For changes when upgrading from the Embree 2 to the current Embree 3 API see Section <a href="#upgrading-from-embree-2-to-embree-3">Upgrading from Embree 2 to Embree 3</a>.</p>
<p>The API supports scenes consisting of different geometry types such as triangle meshes, quad meshes (triangle pairs), grid meshes, flat curves, round curves, oriented curves, subdivision meshes, instances, and user-defined geometries. See Section <a href="#scene-object">Scene Object</a> for more information.</p>
<p>Finding the closest hit of a ray segment with the scene (<code>rtcIntersect</code>-type functions), and determining whether any hit between a ray segment and the scene exists (<code>rtcOccluded</code>-type functions) are both supported. The API supports queries for single rays, ray packets, and ray streams. See Section <a href="#ray-queries">Ray Queries</a> for more information.</p>
<p>The API is designed in an object-oriented manner, e.g. it contains device objects (<code>RTCDevice</code> type), scene objects (<code>RTCScene</code> type), geometry objects (<code>RTCGeometry</code> type), buffer objects (<code>RTCBuffer</code> type), and BVH objects (<code>RTCBVH</code> type). All objects are reference counted, and handles can be released by calling the appropriate release function (e.g. <code>rtcReleaseDevice</code>) or retained by incrementing the reference count (e.g. <code>rtcRetainDevice</code>). In general, API calls that access the same object are not thread-safe, unless specified differently. However, attaching geometries to the same scene and performing ray queries in a scene is thread-safe.</p>
<h2 id="device-object">Device Object</h2>
<p>Embree supports a device concept, which allows different components of the application to use the Embree API without interfering with each other. An application typically first creates a device using the <a href="#rtcnewdevice">rtcNewDevice</a> function. This device can then be used to construct further objects, such as scenes and geometries. Before the application exits, it should release all devices by invoking <a href="#rtcreleasedevice">rtcReleaseDevice</a>. An application typically creates only a single device. If required differently, it should only use a small number of devices at any given time.</p>
<p>Each user thread has its own error flag per device. If an error occurs when invoking an API function, this flag is set to an error code (if it isn't already set by a previous error). See Section <a href="#rtcgetdeviceerror">rtcGetDeviceError</a> for information on how to read the error code and Section <a href="#rtcsetdeviceerrorfunction">rtcSetDeviceErrorFunction</a> on how to register a callback that is invoked for each error encountered. It is recommended to always set a error callback function, to detect all errors.</p>
<h2 id="scene-object">Scene Object</h2>
<p>A scene is a container for a set of geometries, and contains a spatial acceleration structure which can be used to perform different types of ray queries.</p>
<p>A scene is created using the <code>rtcNewScene</code> function call, and released using the <code>rtcReleaseScene</code> function call. To populate a scene with geometries use the <code>rtcAttachGeometry</code> call, and to detach them use the <code>rtcDetachGeometry</code> call. Once all scene geometries are attached, an <code>rtcCommitScene</code> call (or <code>rtcJoinCommitScene</code> call) will finish the scene description and trigger building of internal data structures. After the scene got committed, it is safe to perform ray queries (see Section <a href="#ray-queries">Ray Queries</a>) or to query the scene bounding box (see <a href="#rtcgetscenebounds">rtcGetSceneBounds</a> and <a href="#rtcgetscenelinearbounds">rtcGetSceneLinearBounds</a>).</p>
<p>If scene geometries get modified or attached or detached, the <code>rtcCommitScene</code> call must be invoked before performing any further ray queries for the scene; otherwise the effect of the ray query is undefined. The modification of a geometry, committing the scene, and tracing of rays must always happen sequentially, and never at the same time. Any API call that sets a property of the scene or geometries contained in the scene count as scene modification, e.g. including setting of intersection filter functions.</p>
<p>Scene flags can be used to configure a scene to use less memory (<code>RTC_SCENE_FLAG_COMPACT</code>), use more robust traversal algorithms (<code>RTC_SCENE_FLAG_ROBUST</code>), and to optimize for dynamic content. See Section <a href="#rtcsetsceneflags">rtcSetSceneFlags</a> for more details.</p>
<p>A build quality can be specified for a scene to balance between acceleration structure build performance and ray query performance. See Section <a href="#rtcsetscenebuildquality">rtcSetSceneBuildQuality</a> for more details on build quality.</p>
<h2 id="geometry-object">Geometry Object</h2>
<p>A new geometry is created using the <code>rtcNewGeometry</code> function. Depending on the geometry type, different buffers must be bound (e.g. using <code>rtcSetSharedGeometryBuffer</code>) to set up the geometry data. In most cases, binding of a vertex and index buffer is required. The number of primitives and vertices of that geometry is typically inferred from the size of these bound buffers.</p>
<p>Changes to the geometry always must be committed using the <code>rtcCommitGeometry</code> call before using the geometry. After committing, a geometry is not included in any scene. A geometry can be added to a scene by using the <code>rtcAttachGeometry</code> function (to automatically assign a geometry ID) or using the <code>rtcAttachGeometryById</code> function (to specify the geometry ID manually). A geometry can get attached to multiple scenes.</p>
<p>All geometry types support multi-segment motion blur with an arbitrary number of equidistant time steps (in the range of 2 to 129) inside a user specified time range. Each geometry can have a different number of time steps and a different time range. The motion blur geometry is defined by linearly interpolating the geometries of neighboring time steps. To construct a motion blur geometry, first the number of time steps of the geometry must be specified using the <code>rtcSetGeometryTimeStepCount</code> function, and then a vertex buffer for each time step must be bound, e.g. using the <code>rtcSetSharedGeometryBuffer</code> function. Optionally, a time range defining the start (and end time) of the first (and last) time step can be set using the <code>rtcSetGeometryTimeRange</code> function. This feature will also allow geometries to appear and disappear during the camera shutter time if the time range is a sub range of [0,1].</p>
<p>The API supports per-geometry filter callback functions (see <code>rtcSetGeometryIntersectFilterFunction</code> and <code>rtcSetGeometryOccludedFilterFunction</code>) that are invoked for each intersection found during the <code>rtcIntersect</code>-type or <code>rtcOccluded</code>-type calls. The former ones are called geometry intersection filter functions, the latter ones geometry occlusion filter functions. These filter functions are designed to be used to ignore intersections outside of a user-defined silhouette of a primitive, e.g. to model tree leaves using transparency textures.</p>
<h2 id="ray-queries">Ray Queries</h2>
<p>The API supports finding the closest hit of a ray segment with the scene (<code>rtcIntersect</code>-type functions), and determining whether any hit between a ray segment and the scene exists (<code>rtcOccluded</code>-type functions).</p>
<p>Supported are single ray queries (<code>rtcIntersect1</code> and <code>rtcOccluded1</code>) as well as ray packet queries for ray packets of size 4 (<code>rtcIntersect4</code> and <code>rtcOccluded4</code>), ray packets of size 8 (<code>rtcIntersect8</code> and <code>rtcOccluded8</code>), and ray packets of size 16 (<code>rtcIntersect16</code> and <code>rtcOccluded16</code>).</p>
<p>Ray streams in a variety of layouts are supported as well, such as streams of single rays (<code>rtcIntersect1M</code> and <code>rtcOccluded1M</code>), streams of pointers to single rays (<code>rtcIntersect1p</code> and <code>rtcOccluded1p</code>), streams of ray packets (<code>rtcIntersectNM</code> and <code>rtcOccludedNM</code>), and large packet-like streams in structure of pointer layout (<code>rtcIntersectNp</code> and <code>rtcOccludedNp</code>).</p>
<p>See Sections <a href="#rtcintersect1">rtcIntersect1</a> and <a href="#rtcoccluded1">rtcOccluded1</a> for a detailed description of how to set up and trace a ray.</p>
<p>See tutorial <a href="tutorials.html#triangle-geometry">Triangle Geometry</a> for a complete example of how to trace single rays and ray packets. Also have a look at the tutorial <a href="tutorials.html#stream-viewer">Stream Viewer</a> for an example of how to trace ray streams.</p>
<h2 id="point-queries">Point Queries</h2>
<p>The API supports traversal of the BVH using a point query object that specifies a location and a query radius. For all primitives intersecting the according domain, a user defined callback function is called which allows queries such as finding the closest point on the surface geometries of the scene (see Tutorial <a href="tutorials.html#closest-point">Closest Point</a>) or nearest neighbour queries (see Tutorial <a href="tutorials.html#voronoi">Voronoi</a>).</p>
<p>See Section [rtcPointQuery] for a detailed description of how to set up point queries.</p>
<h2 id="collision-detection">Collision Detection</h2>
<p>The Embree API also supports collision detection queries between two scenes consisting only of user geometries. Embree only performs broadphase collision detection, the narrow phase detection can be performed through a callback function.</p>
<p>See Section <a href="#rtccollide">rtcCollide</a> for a detailed description of how to set up collision detection.</p>
<p>Seen tutorial <a href="#collision-detection">Collision Detection</a> for a complete example of collsion detection being used on a simple cloth solver.</p>
<h2 id="miscellaneous">Miscellaneous</h2>
<p>A context filter function, which can be set per ray query is supported (see <code>rtcInitIntersectContext</code>). This filter function is designed to change the semantics of the ray query, e.g. to accumulate opacity for transparent shadows, count the number of surfaces along a ray, collect all hits along a ray, etc.</p>
<p>The internal algorithms to build a BVH are exposed through the <code>RTCBVH</code> object and <code>rtcBuildBVH</code> call. This call makes it possible to build a BVH in a user-specified format over user-specified primitives. See the documentation of the <code>rtcBuildBVH</code> call for more details.</p>
<p>For getting the most performance out of Embree, see the Section <a href="#performance-recommendations">Performance Recommendations</a>.</p>
<p></p>
<h1 id="upgrading-from-embree-2-to-embree-3">Upgrading from Embree 2 to Embree 3</h1>
<p>We decided to introduce an improved API in Embree 3 that is not backward compatible with the Embree 2 API. This step was required to remove various deprecated API functions that accumulated over time, improve extensibility of the API, fix suboptimal design decisions, fix design mistakes (such as incompatible single ray and ray packet layouts), clean up inconsistent naming, and increase flexibility.</p>
<p>To make porting to the new API easy, we provide a conversion script that can do most of the work, and will annotate the code with remaining changes required. The script can be invoked the following way for CPP files:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">./scripts/cpp-patch.py --patch embree2_to_embree3.patch
  --in infile.cpp --out outfile.cpp</code></pre></div>
<p>When invoked for ISPC files, add the <code>--ispc</code> option:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">./scripts/cpp-patch.py --ispc --patch embree2_to_embree3.patch
  --in infile.ispc --out outfile.ispc</code></pre></div>
<p>Apply the script to each source file of your project that contains Embree API calls or types. The input file and output file can also be identical to perform the patch in-place. Please always backup your original code before running the script, and inspect the code changes done by the script using diff (e.g. <code>git diff</code>), to make sure no undesired code locations got changed. Grep the code for comments containing <code>EMBREE_FIXME</code> and perform the action described in the comment.</p>
<p>The following changes need to be performed when switching from Embree 2 to Embree 3. Most of these changes are automatically done by the script if not described differently.</p>
<p>We strongly recommend to set an error callback function (see <code>rtcSetDeviceErrorFunction</code>) when porting to Embree 3 to detect all runtime errors early.</p>
<h2 id="device">Device</h2>
<ul>
<li><p><code>rtcInit</code> and <code>rtcExit</code> got removed. Please use the device concept using the <code>rtcNewDevice</code> and <code>rtcReleaseDevice</code> functions instead.</p></li>
<li><p>Functions that conceptually should operate on a device but did not get a device argument got removed. The upgrade script replaces these functions by the proper functions that operate on a device, however, manually propagating the device handle to these function calls might still be required.</p></li>
</ul>
<h2 id="scene">Scene</h2>
<ul>
<li><p>The API no longer distinguishes between a static and a dynamic scene. Some users had issues as they wanted to do minor modifications to static scenes, but maintain high traversal performance.</p>
<p>The new approach gives more flexibility, as each scene is changeable, and build quality settings can be changed on a commit basis to balance between build performance and render performance.</p></li>
<li><p>The <code>rtcCommitThread</code> function got removed; use <code>rtcJoinCommitScene</code> instead.</p></li>
<li><p>The scene now supports different build quality settings. Please use those instead of the previous way of <code>RTC_SCENE_STATIC</code>, <code>RTC_SCENE_DYNAMIC</code>, and <code>RTC_SCENE_HIGH_QUALITY</code> flags.</p></li>
</ul>
<h2 id="geometry">Geometry</h2>
<ul>
<li><p>There is now only one <code>rtcNewGeometry</code> function to create geometries which gets passed an enum to specify the type of geometry to create. The number of vertices and primitives of the geometries is inferred from the size of data buffers.</p></li>
<li><p>We introduced an object type <code>RTCGeometry</code> for all geometries. Previously a geometry was not a standalone object and could only exist inside a scene. The new approach comes with more flexibility and more readable code.</p>
<p>Operations like <code>rtcInterpolate</code> can now be performed on the geometry object directly without the need of a scene. Further, an application can choose to create its geometries independent of a scene, e.g. each time a geometry node is added to its scene graph.</p>
<p>This modification changed many API functions to get passed one <code>RTCGeometry</code> object instead of a <code>RTCScene</code> and <code>geomID</code>. The script does all required changed automatically. However, in some cases the script may introduce <code>rtcGetGeometry(scene, geomID)</code> calls to retrieve the geometry handle. Best store the geometry handle inside your scene representation (and release it in the destructor) and access the handle directly instead of calling <code>rtcGetGeometry</code>.</p></li>
<li><p>Geometries are not included inside a scene anymore but can be attached to a multiple scenes using the <code>rtcAttachGeomety</code> or <code>rtcAttachGeometryByID</code> functions.</p></li>
<li><p>As geometries are separate objects, commit semantics got introduced for them too. Thus geometries must be committed through the <code>rtcCommitGeometry</code> call before getting used. This allows for earlier error checking and pre-calculating internal data per geometry object.</p>
<p>Such commit points were previously not required in the Embree 2 API. The upgrade script attempts to insert the commits automatically, but cannot do so properly under all circumstances. Thus please check if every <code>rtcCommitGeometry</code> call inserted by the script is properly placed, and if a <code>rtcCommitGeometry</code> call is placed after a sequence of changes to a geometry.</p></li>
<li><p>Only the latest version of the previous displacement function call (<code>RTCDisplacementFunc2</code>) is now supported, and the callback is passed as a structure containing all arguments.</p></li>
<li><p>The deprecated <code>RTCBoundaryMode</code> type and <code>rtcSetBoundaryMode</code> function got removed and replaced by <code>RTCSubdivisionMode</code> enum and the <code>rtcSetGeometrySubdivisionMode</code> function. The script does this replacement automatically.</p></li>
<li><p>Ribbon curves and lines now avoid self-intersections automatically The application can be simplified by removing special code paths that previously did the self-intersection handling.</p></li>
<li><p>The previous Embree 2 way of instancing was suboptimal as it required user geometries to update the <code>instID</code> field of the ray differently when used inside an instanced scene or inside a top-level scene. The user geometry intersection code now just has to copy the <code>context.instID</code> field into the <code>ray.instID</code> field to function properly under all circumstances.</p></li>
<li><p>The internal instancing code will update the <code>context.instID</code> field properly when entering or leaving an instance. When instancing is implemented manually through user geometries, the code must be modified to set the <code>context.instID</code> field properly and no longer pass <code>instID</code> through the ray. This change must done manually and cannot be performed by the script.</p></li>
<li><p>We flipped the direction of the geometry normal to the widely used convention that a shape with counter-clockwise layout of vertices has the normal pointing upwards (right-hand rule). Most modeling tools follow that convention.</p>
<p>The conversion script does not perform this change, thus if required adjust your code to flip <code>Ng</code> for triangle, quad, and subdivision surfaces.</p></li>
</ul>
<h2 id="buffers">Buffers</h2>
<ul>
<li><p>With Embree 3 we are introducing explicit <code>RTCBuffer</code> objects. However, you can still use the short way of sharing buffers with Embree through the <code>rtcSetSharedGeometryBuffer</code> call.</p></li>
<li><p>The <code>rtcMapBuffer</code> and <code>rtcUnmapBuffer</code> API calls were removed, and we added the <code>rtcGetBufferData</code> call instead.</p>
<p>Previously the <code>rtcMapBuffer</code> call had the semantics of creating an internal buffer when no buffer was shared for the corresponding buffer slot. These invocations of <code>rtcMapBuffer</code> must be replaced by an explicit creation of an internally managed buffer using the <code>rtcNewGeometryBuffer</code> function.</p>
<p>The upgrade script cannot always detect if the <code>rtcMapBuffer</code> call would create an internal buffer or just map the buffer pointer. Thus check whether the <code>rtcNewGeometryBuffer</code> and <code>rtcGetBufferData</code> calls are correct after the conversion.</p></li>
<li><p>The <code>rtcUpdateGeometryBuffer</code> function now must be called for every buffer that got modified by the application. Note that the conversion script cannot automatically detect each location where a buffer update is now required.</p></li>
<li><p>The buffer type no longer encodes the time step or user vertex buffer index. Now <code>RTC_VERTEX_BUFFER_TYPE</code> and additional <code>slot</code> specifies the vertex buffer for a specific time step, and <code>RTC_USER_VERTEX_BUFFER_TYPE</code> and additional <code>slot</code> specifies a vertex attribute.</p></li>
</ul>
<h2 id="miscellaneous-1">Miscellaneous</h2>
<ul>
<li><p>The header files for Embree 3 are now inside the <code>embree3</code> folder (instead of <code>embree2</code> folder) and <code>libembree.so</code> is now called <code>libembree3.so</code> to be able to install multiple Embree versions side by side. We made the headers C99 compliant.</p></li>
<li><p>All API objects are now reference counted with release functions to decrement and retain functions to increment the reference count (if required).</p></li>
<li><p>Most callback functions no longer get different arguments as input, but a pointer to a structure containing all arguments. This results in more readable code, faster callback invocation (as some arguments do not change between invocations) and is extensible, as new members to the structure can be later added in a backward compatible way (if required).</p>
<p>The conversion script can convert the definition and declaration of the old callback functions in most cases. Before running the script, make sure that you never type-cast a callback function when assigning it (as this has the danger of assigning a callback function with a wrong type if the conversion did not detect some callbacks as such). If the script does not detect a callback function, make sure the argument types match exactly the types in the header (e.g. write <code>const int</code> instead of <code>int const</code> or convert the callback manually).</p></li>
<li><p>An intersection context is now required for each ray query invocation. The context should be initialized using the <code>rtcInitIntersectContext</code> function.</p></li>
<li><p>The <code>rtcIntersect</code>-type functions get as input an <code>RTCRayHit</code> type, which is similar to before, but has the ray and hit parts split into two sub-structures.</p>
<p>The <code>rtcOccluded</code>-type functions get as input an <code>RTCRay</code> type, which does not contain hit data anymore. When an occlusion is found, the <code>tfar</code> element of the ray is set to <code>-inf</code>.</p>
<p>Required code changes cannot be done by the upgrade script and need to be done manually.</p></li>
<li><p>The ray layout for single rays and packets of rays had certain incompatibilities (alignment of <code>org</code> and <code>dir</code> for single rays caused gaps in the single ray layout that were not in the ray packet layout). This issue never showed up because single rays and ray packets were separate in the system initially. This layout issue is now fixed, and a single ray has the same layout as a ray packet of size 1.</p></li>
<li><p>Previously Embree supported placing additional data at the end of the ray structure, and accessing that data inside user geometry callbacks and filter callback functions.</p>
<p>With Embree 3 this is no longer supported, and the ray passed to a callback function may be copied to a different memory location. To attach additional data to your ray, simply extend the intersection context with a pointer to that data.</p>
<p>This change cannot be done by the script. Further, code will still work if you extend the ray as the implementation did not change yet.</p></li>
<li><p>The ray structure now contains an additional <code>id</code> and <code>flags</code> field. The <code>id</code> can be used to store the index of the ray with respect to a ray packet or ray stream. The <code>flags</code> is reserved for future use, and currently must be set to 0.</p></li>
<li><p>All previous intersection filter callback variants have been removed, except for the <code>RTCFilterFuncN</code> which gets a varying size ray packet as input. The semantics of this filter function type have changed from copying the hit on acceptance to clearing the ray's valid argument in case of non-acceptance. This way, chaining multiple filters is more efficient.</p>
<p>We kept the guarantee that for <code>rtcIntersect1/4/8/16</code> and <code>rtcOccluded1/4/8/16</code> calls the packet size and ray order will not change from the initial size and ordering when entering a filter callback.</p></li>
<li><p>We no longer export ISPC-specific symbols. This has the advantage that certain linking issues went away, e.g. it is now possible to link an ISPC application compiled for any combination of ISAs, and link this to an Embree library compiled with a different set of ISAs. Previously the ISAs of the application had to be a subset of the ISAs of Embree, and when the user enabled exactly one ISA, they had to do this in Embree and the application.</p></li>
<li><p>We no longer export the ISPC tasking system, which means that the application has the responsibility to implement the ISPC tasking system itself. ISPC comes with example code on how to do this. This change is not performed by the script and must be done manually.</p></li>
<li><p>Fixed many naming inconsistencies, and changed names of further API functions. All these renamings are properly done by the script and need no further attention.</p></li>
</ul>
<p></p>
<h1 id="embree-api-reference">Embree API Reference</h1>
<h2 id="rtcnewdevice">rtcNewDevice</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewDevice - creates a <span class="kw">new</span> device</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCDevice rtcNewDevice(<span class="dt">const</span> <span class="dt">char</span>* config);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>This function creates a new device and returns a handle to this device. The device object is reference counted with an initial reference count of 1. The handle can be released using the <code>rtcReleaseDevice</code> API call.</p>
<p>The device object acts as a class factory for all other object types. All objects created from the device (like scenes, geometries, etc.) hold a reference to the device, thus the device will not be destroyed unless these objects are destroyed first.</p>
<p>Objects are only compatible if they belong to the same device, e.g it is not allowed to create a geometry in one device and attach it to a scene created with a different device.</p>
<p>A configuration string (<code>config</code> argument) can be passed to the device construction. This configuration string can be <code>NULL</code> to use the default configuration.</p>
<p>When creating the device, Embree reads configurations for the device from the following locations in order:</p>
<ol style="list-style-type: decimal">
<li><code>config</code> string passed to the <code>rtcNewDevice</code> function</li>
<li><code>.embree3</code> file in the application folder</li>
<li><code>.embree3</code> file in the home folder</li>
</ol>
<p>Settings performed later overwrite previous settings. This way the configuration for the application can be changed globally (either through the <code>rtcNewDevice</code> call or through the <code>.embree3</code> file in the application folder), and each user has the option to modify the configuration to fit their needs.</p>
<p>The following configuration is supported:</p>
<ul>
<li><p><code>threads=[int]</code>: Specifies a number of build threads to use. A value of 0 enables all detected hardware threads. By default all hardware threads are used.</p></li>
<li><p><code>user_threads=[int]</code>: Sets the number of user threads that can be used to join and participate in a scene commit using <code>rtcJoinCommitScene</code>. The tasking system will only use threads-user_threads many worker threads, thus if the app wants to solely use its threads to commit scenes, just set threads equal to user_threads. This option only has effect with the Intel(R) Threading Building Blocks (TBB) tasking system.</p></li>
<li><p><code>set_affinity=[0/1]</code>: When enabled, build threads are affinitized to hardware threads. This option is disabled by default on standard CPUs, and enabled by default on Xeon Phi Processors.</p></li>
<li><p><code>start_threads=[0/1]</code>: When enabled, the build threads are started upfront. This can be useful for benchmarking to exclude thread creation time. This option is disabled by default.</p></li>
<li><p><code>isa=[sse2,sse4.2,avx,avx2,avx512knl,avx512skx]</code>: Use specified ISA. By default the ISA is selected automatically.</p></li>
<li><p><code>max_isa=[sse2,sse4.2,avx,avx2,avx512knl,avx512skx]</code>: Configures the automated ISA selection to use maximally the specified ISA.</p></li>
<li><p><code>hugepages=[0/1]</code>: Enables or disables usage of huge pages. Under Linux huge pages are used by default but under Windows and macOS they are disabled by default.</p></li>
<li><p><code>enable_selockmemoryprivilege=[0/1]</code>: When set to 1, this enables the <code>SeLockMemoryPrivilege</code> privilege with is required to use huge pages on Windows. This option has an effect only under Windows and is ignored on other platforms. See Section <a href="#huge-page-support">Huge Page Support</a> for more details.</p></li>
<li><p><code>ignore_config_files=[0/1]</code>: When set to 1, configuration files are ignored. Default is 0.</p></li>
<li><p><code>verbose=[0,1,2,3]</code>: Sets the verbosity of the output. When set to 0, no output is printed by Embree, when set to a higher level more output is printed. By default Embree does not print anything on the console.</p></li>
<li><p><code>frequency_level=[simd128,simd256,simd512]</code>: Specifies the frequency level the application want to run on, which can be either: a) simd128 for apps that do not use AVX instructions, b) simd256 for apps that use heavy AVX instruction, c) simd512 for apps that use heavy AVX-512 instructions. When some frequency level is specified, Embree will avoid doing optimizations that may reduce the frequency level below the level specified. E.g. if your app does not use AVX instructions setting &quot;frequency_level=simd128&quot; will cause some CPUs to run at highest frequency, which may result in higher application performance. However, this will prevent Embree from using AVX optimizations to achieve higher ray tracing performance, thus applications that trace many rays may still perform better with the default setting of simd256, even though this reduces frequency on some CPUs.</p></li>
</ul>
<p>Different configuration options should be separated by commas, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewDevice(<span class="st">&quot;threads=1,isa=avx&quot;</span>);</code></pre></div>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On success returns a handle of the created device. On failure returns <code>NULL</code> as device and sets a per-thread error code that can be queried using <code>rtcGetDeviceError(NULL)</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretaindevice">rtcRetainDevice</a>, <a href="#rtcreleasedevice">rtcReleaseDevice</a></p>
<p></p>
<h2 id="rtcretaindevice">rtcRetainDevice</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainDevice - increments the device reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainDevice(RTCDevice device);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Device objects are reference counted. The <code>rtcRetainDevice</code> function increments the reference count of the passed device object (<code>device</code> argument). This function together with <code>rtcReleaseDevice</code> allows to use the internal reference counting in a C++ wrapper class to manage the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewdevice">rtcNewDevice</a>, <a href="#rtcreleasedevice">rtcReleaseDevice</a></p>
<p></p>
<h2 id="rtcreleasedevice">rtcReleaseDevice</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseDevice - decrements the device reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseDevice(RTCDevice device);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Device objects are reference counted. The <code>rtcReleaseDevice</code> function decrements the reference count of the passed device object (<code>device</code> argument). When the reference count falls to 0, the device gets destroyed.</p>
<p>All objects created from the device (like scenes, geometries, etc.) hold a reference to the device, thus the device will not get destroyed unless these objects are destroyed first.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewdevice">rtcNewDevice</a>, <a href="#rtcretaindevice">rtcRetainDevice</a></p>
<p></p>
<h2 id="rtcgetdeviceproperty">rtcGetDeviceProperty</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetDeviceProperty - queries properties of the device</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

ssize_t rtcGetDeviceProperty(
  RTCDevice device,
  <span class="kw">enum</span> RTCDeviceProperty prop
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetDeviceProperty</code> function can be used to query properties (<code>prop</code> argument) of a device object (<code>device</code> argument). The returned property is an integer of type <code>ssize_t</code>.</p>
<p>Possible properties to query are:</p>
<ul>
<li><p><code>RTC_DEVICE_PROPERTY_VERSION</code>: Queries the combined version number (MAJOR.MINOR.PATCH) with two decimal digits per component. E.g. for Embree 2.8.3 the integer 208003 is returned.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_VERSION_MAJOR</code>: Queries the major version number of Embree.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_VERSION_MINOR</code>: Queries the minor version number of Embree.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_VERSION_PATCH</code>: Queries the patch version number of Embree.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_NATIVE_RAY4_SUPPORTED</code>: Queries whether the <code>rtcIntersect4</code> and <code>rtcOccluded4</code> functions preserve packet size and ray order when invoking callback functions. This is only the case if Embree is compiled with <code>EMBREE_RAY_PACKETS</code> and <code>SSE2</code> (or <code>SSE4.2</code>) enabled, and if the machine it is running on supports <code>SSE2</code> (or <code>SSE4.2</code>).</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_NATIVE_RAY8_SUPPORTED</code>: Queries whether the <code>rtcIntersect8</code> and <code>rtcOccluded8</code> functions preserve packet size and ray order when invoking callback functions. This is only the case if Embree is compiled with <code>EMBREE_RAY_PACKETS</code> and <code>AVX</code> (or <code>AVX2</code>) enabled, and if the machine it is running on supports <code>AVX</code> (or <code>AVX2</code>).</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_NATIVE_RAY16_SUPPORTED</code>: Queries whether the <code>rtcIntersect16</code> and <code>rtcOccluded16</code> functions preserve packet size and ray order when invoking callback functions. This is only the case if Embree is compiled with <code>EMBREE_RAY_PACKETS</code> and <code>AVX512SKX</code> (or <code>AVX512KNL</code>) enabled, and if the machine it is running on supports <code>AVX512SKX</code> (or <code>AVX512KNL</code>).</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_RAY_STREAM_SUPPORTED</code>: Queries whether <code>rtcIntersect1M</code>, <code>rtcIntersect1Mp</code>, <code>rtcIntersectNM</code>, <code>rtcIntersectNp</code>, <code>rtcOccluded1M</code>, <code>rtcOccluded1Mp</code>, <code>rtcOccludedNM</code>, and <code>rtcOccludedNp</code> are supported. This is only the case if Embree is compiled with <code>EMBREE_RAY_PACKETS</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_RAY_MASK_SUPPORTED</code>: Queries whether ray masks are supported. This is only the case if Embree is compiled with <code>EMBREE_RAY_MASK</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_BACKFACE_CULLING_ENABLED</code>: Queries whether back face culling is enabled. This is only the case if Embree is compiled with <code>EMBREE_BACKFACE_CULLING</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_FILTER_FUNCTION_SUPPORTED</code>: Queries whether filter functions are supported, which is the case if Embree is compiled with <code>EMBREE_FILTER_FUNCTION</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_IGNORE_INVALID_RAYS_ENABLED</code>: Queries whether invalid rays are ignored, which is the case if Embree is compiled with <code>EMBREE_IGNORE_INVALID_RAYS</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_TRIANGLE_GEOMETRY_SUPPORTED</code>: Queries whether triangles are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_TRIANGLE</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_QUAD_GEOMETRY_SUPPORTED</code>: Queries whether quads are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_QUAD</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_SUBDIVISION_GEOMETRY_SUPPORTED</code>: Queries whether subdivision meshes are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_SUBDIVISION</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_CURVE_GEOMETRY_SUPPORTED</code>: Queries whether curves are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_CURVE</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_POINT_GEOMETRY_SUPPORTED</code>: Queries whether points are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_POINT</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_USER_GEOMETRY_SUPPORTED</code>: Queries whether user geometries are supported, which is the case if Embree is compiled with <code>EMBREE_GEOMETRY_USER</code> enabled.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_TASKING_SYSTEM</code>: Queries the tasking system Embree is compiled with. Possible return values are:</p>
<ol start="0" style="list-style-type: decimal">
<li>internal tasking system</li>
<li>Intel Threading Building Blocks (TBB)</li>
<li>Parallel Patterns Library (PPL)</li>
</ol></li>
<li><p><code>RTC_DEVICE_PROPERTY_COMMIT_JOIN_SUPPORTED</code>: Queries whether <code>rtcJoinCommitScene</code> is supported. This is not the case when Embree is compiled with PPL or older versions of TBB.</p></li>
<li><p><code>RTC_DEVICE_PROPERTY_PARALLEL_COMMIT_SUPPORTED</code>: Queries whether <code>rtcCommitScene</code> can get invoked from multiple TBB worker threads concurrently. This feature is only supported starting with TBB 2019 Update 9.</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On success returns the value of the queried property. For properties returning a boolean value, the return value 0 denotes <code>false</code> and 1 denotes <code>true</code>.</p>
<p>On failure zero is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<p></p>
<h2 id="rtcgetdeviceerror">rtcGetDeviceError</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetDeviceError - returns the error code of the device</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCError rtcGetDeviceError(RTCDevice device);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Each thread has its own error code per device. If an error occurs when calling an API function, this error code is set to the occurred error if it stores no previous error. The <code>rtcGetDeviceError</code> function reads and returns the currently stored error and clears the error code. This assures that the returned error code is always the first error occurred since the last invocation of <code>rtcGetDeviceError</code>.</p>
<p>Possible error codes returned by <code>rtcGetDeviceError</code> are:</p>
<ul>
<li><p><code>RTC_ERROR_NONE</code>: No error occurred.</p></li>
<li><p><code>RTC_ERROR_UNKNOWN</code>: An unknown error has occurred.</p></li>
<li><p><code>RTC_ERROR_INVALID_ARGUMENT</code>: An invalid argument was specified.</p></li>
<li><p><code>RTC_ERROR_INVALID_OPERATION</code>: The operation is not allowed for the specified object.</p></li>
<li><p><code>RTC_ERROR_OUT_OF_MEMORY</code>: There is not enough memory left to complete the operation.</p></li>
<li><p><code>RTC_ERROR_UNSUPPORTED_CPU</code>: The CPU is not supported as it does not support the lowest ISA Embree is compiled for.</p></li>
<li><p><code>RTC_ERROR_CANCELLED</code>: The operation got canceled by a memory monitor callback or progress monitor callback function.</p></li>
</ul>
<p>When the device construction fails, <code>rtcNewDevice</code> returns <code>NULL</code> as device. To detect the error code of a such a failed device construction, pass <code>NULL</code> as device to the <code>rtcGetDeviceError</code> function. For all other invocations of <code>rtcGetDeviceError</code>, a proper device pointer must be specified.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>Returns the error code for the device.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetdeviceerrorfunction">rtcSetDeviceErrorFunction</a></p>
<p></p>
<h2 id="rtcsetdeviceerrorfunction">rtcSetDeviceErrorFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetDeviceErrorFunction - sets an error callback function <span class="kw">for</span> the device</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCErrorFunction)(
  <span class="dt">void</span>* userPtr,
  RTCError code,
  <span class="dt">const</span> <span class="dt">char</span>* str
);

<span class="dt">void</span> rtcSetDeviceErrorFunction(
  RTCDevice device,
  RTCErrorFunction error,
  <span class="dt">void</span>* userPtr
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Using the <code>rtcSetDeviceErrorFunction</code> call, it is possible to set a callback function (<code>error</code> argument) with payload (<code>userPtr</code> argument), which is called whenever an error occurs for the specified device (<code>device</code> argument).</p>
<p>Only a single callback function can be registered per device, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>When the registered callback function is invoked, it gets passed the user-defined payload (<code>userPtr</code> argument as specified at registration time), the error code (<code>code</code> argument) of the occurred error, as well as a string (<code>str</code> argument) that further describes the error.</p>
<p>The error code is also set if an error callback function is registered.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetdeviceerror">rtcGetDeviceError</a></p>
<p></p>
<h2 id="rtcsetdevicememorymonitorfunction">rtcSetDeviceMemoryMonitorFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetDeviceMemoryMonitorFunction - registers a callback function
  to track memory consumption</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">typedef</span> <span class="dt">bool</span> (*RTCMemoryMonitorFunction)(
  <span class="dt">void</span>* userPtr,
  ssize_t bytes,
  <span class="dt">bool</span> post
);

<span class="dt">void</span> rtcSetDeviceMemoryMonitorFunction(
  RTCDevice device,
  RTCMemoryMonitorFunction memoryMonitor,
  <span class="dt">void</span>* userPtr
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Using the <code>rtcSetDeviceMemoryMonitorFunction</code> call, it is possible to register a callback function (<code>memoryMonitor</code> argument) with payload (<code>userPtr</code> argument) for a device (<code>device</code> argument), which is called whenever internal memory is allocated or deallocated by objects of that device. Using this memory monitor callback mechanism, the application can track the memory consumption of an Embree device, and optionally terminate API calls that consume too much memory.</p>
<p>Only a single callback function can be registered per device, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>Once registered, the Embree device will invoke the memory monitor callback function before or after it allocates or frees important memory blocks. The callback function gets passed the payload as specified at registration time (<code>userPtr</code> argument), the number of bytes allocated or deallocated (<code>bytes</code> argument), and whether the callback is invoked after the allocation or deallocation took place (<code>post</code> argument). The callback function might get called from multiple threads concurrently.</p>
<p>The application can track the current memory usage of the Embree device by atomically accumulating the <code>bytes</code> input parameter provided to the callback function. This parameter will be &gt;0 for allocations and &lt;0 for deallocations.</p>
<p>Embree will continue its operation normally when returning <code>true</code> from the callback function. If <code>false</code> is returned, Embree will cancel the current operation with the <code>RTC_ERROR_OUT_OF_MEMORY</code> error code. Issuing multiple cancel requests from different threads is allowed. Canceling will only happen when the callback was called for allocations (bytes &gt; 0), otherwise the cancel request will be ignored.</p>
<p>If a callback to cancel was invoked before the allocation happens (<code>post == false</code>), then the <code>bytes</code> parameter should not be accumulated, as the allocation will never happen. If the callback to cancel was invoked after the allocation happened (<code>post == true</code>), then the <code>bytes</code> parameter should be accumulated, as the allocation properly happened and a deallocation will later free that data block.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewdevice">rtcNewDevice</a></p>
<p></p>
<h2 id="rtcnewscene">rtcNewScene</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewScene - creates a <span class="kw">new</span> scene</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCScene rtcNewScene(RTCDevice device);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>This function creates a new scene bound to the specified device (<code>device</code> argument), and returns a handle to this scene. The scene object is reference counted with an initial reference count of 1. The scene handle can be released using the <code>rtcReleaseScene</code> API call.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On success a scene handle is returned. On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretainscene">rtcRetainScene</a>, <a href="#rtcreleasescene">rtcReleaseScene</a></p>
<p></p>
<h2 id="rtcgetscenedevice">rtcGetSceneDevice</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetSceneDevice - returns the device the scene got created in</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCDevice rtcGetSceneDevice(RTCScene scene);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>This function returns the device object the scene got created in. The returned handle own one additional reference to the device object, thus you should need to call <code>rtcReleaseDevice</code> when the returned handle is no longer required.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcreleasedevice">rtcReleaseDevice</a></p>
<p></p>
<h2 id="rtcretainscene">rtcRetainScene</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainScene - increments the scene reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainScene(RTCScene scene);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Scene objects are reference counted. The <code>rtcRetainScene</code> function increments the reference count of the passed scene object (<code>scene</code> argument). This function together with <code>rtcReleaseScene</code> allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewscene">rtcNewScene</a>, <a href="#rtcreleasescene">rtcReleaseScene</a></p>
<p></p>
<h2 id="rtcreleasescene">rtcReleaseScene</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseScene - decrements the scene reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseScene(RTCScene scene);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Scene objects are reference counted. The <code>rtcReleaseScene</code> function decrements the reference count of the passed scene object (<code>scene</code> argument). When the reference count falls to 0, the scene gets destroyed.</p>
<p>The scene holds a reference to all attached geometries, thus if the scene gets destroyed, all geometries get detached and their reference count decremented.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewscene">rtcNewScene</a>, <a href="#rtcretainscene">rtcRetainScene</a></p>
<p></p>
<h2 id="rtcattachgeometry">rtcAttachGeometry</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcAttachGeometry - attaches a geometry to the scene</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">unsigned</span> <span class="dt">int</span> rtcAttachGeometry(
  RTCScene scene,
  RTCGeometry geometry
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcAttachGeometry</code> function attaches a geometry (<code>geometry</code> argument) to a scene (<code>scene</code> argument) and assigns a geometry ID to that geometry. All geometries attached to a scene are defined to be included inside the scene. A geometry can get attached to multiplee scene. The geometry ID is unique for the scene, and is used to identify the geometry when hit by a ray during ray queries.</p>
<p>This function is thread-safe, thus multiple threads can attach geometries to a scene in parallel.</p>
<p>The geometry IDs are assigned sequentially, starting from 0, as long as no geometry got detached. If geometries got detached, the implementation will reuse IDs in an implementation dependent way. Consequently sequential assignment is no longer guaranteed, but a compact range of IDs.</p>
<p>These rules allow the application to manage a dynamic array to efficiently map from geometry IDs to its own geometry representation. Alternatively, the application can also use per-geometry user data to map to its geometry representation. See <code>rtcSetGeometryUserData</code> and <code>rtcGetGeometryUserData</code> for more information.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcgetgeometryuserdata">rtcGetGeometryUserData</a></p>
<p></p>
<h2 id="rtcattachgeometrybyid">rtcAttachGeometryByID</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcAttachGeometryByID - attaches a geometry to the scene
  <span class="kw">using</span> a specified geometry ID</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcAttachGeometryByID(
  RTCScene scene,
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcAttachGeometryByID</code> function attaches a geometry (<code>geometry</code> argument) to a scene (<code>scene</code> argument) and assigns a user provided geometry ID (<code>geomID</code> argument) to that geometry. All geometries attached to a scene are defined to be included inside the scene. A geometry can get attached to multiple scenes. The passed user-defined geometry ID is used to identify the geometry when hit by a ray during ray queries. Using this function, it is possible to share the same IDs to refer to geometries inside the application and Embree.</p>
<p>This function is thread-safe, thus multiple threads can attach geometries to a scene in parallel.</p>
<p>The user-provided geometry ID must be unused in the scene, otherwise the creation of the geometry will fail. Further, the user-provided geometry IDs should be compact, as Embree internally creates a vector which size is equal to the largest geometry ID used. Creating very large geometry IDs for small scenes would thus cause a memory consumption and performance overhead.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcattachgeometry">rtcAttachGeometry</a></p>
<p></p>
<h2 id="rtcdetachgeometry">rtcDetachGeometry</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcDetachGeometry - detaches a geometry from the scene</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcDetachGeometry(RTCScene scene, <span class="dt">unsigned</span> <span class="dt">int</span> geomID);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>This function detaches a geometry identified by its geometry ID (<code>geomID</code> argument) from a scene (<code>scene</code> argument). When detached, the geometry is no longer contained in the scene.</p>
<p>This function is thread-safe, thus multiple threads can detach geometries from a scene at the same time.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcattachgeometry">rtcAttachGeometry</a>, <a href="#rtcattachgeometrybyid">rtcAttachGeometryByID</a></p>
<p></p>
<h2 id="rtcgetgeometry">rtcGetGeometry</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometry - returns the geometry bound to
  the specified geometry ID</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry rtcGetGeometry(RTCScene scene, <span class="dt">unsigned</span> <span class="dt">int</span> geomID);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometry</code> function returns the geometry that is bound to the specified geometry ID (<code>geomID</code> argument) for the specified scene (<code>scene</code> argument). This function just looks up the handle and does <em>not</em> increment the reference count. If you want to get ownership of the handle, you need to additionally call <code>rtcRetainGeometry</code>. For this reason, this function is fast and can be used during rendering. However, it is generally recommended to store the geometry handle inside the application's geometry representation and look up the geometry handle from that representation directly.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcattachgeometry">rtcAttachGeometry</a>, <a href="#rtcattachgeometrybyid">rtcAttachGeometryByID</a></p>
<p></p>
<h2 id="rtccommitscene">rtcCommitScene</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcCommitScene - commits scene changes</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcCommitScene(RTCScene scene);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcCommitScene</code> function commits all changes for the specified scene (<code>scene</code> argument). This internally triggers building of a spatial acceleration structure for the scene using all available worker threads. Ray queries can be performed only after committing all scene changes.</p>
<p>If the application uses TBB 2019 Update 9 or later for parallelization of rendering, lazy scene construction during rendering is supported by <code>rtcCommitScene</code>. Therefore <code>rtcCommitScene</code> can get called from multiple TBB worker threads concurrently for the same scene. The <code>rtcCommitScene</code> function will then internally isolate the scene construction using a tbb::isolated_task_group. The alternative approach of using <code>rtcJoinCommitScene</code> which uses an tbb:task_arena internally, is not recommended due to it's high runtime overhead.</p>
<p>If scene geometries get modified or attached or detached, the <code>rtcCommitScene</code> call must be invoked before performing any further ray queries for the scene; otherwise the effect of the ray query is undefined. The modification of a geometry, committing the scene, and tracing of rays must always happen sequentially, and never at the same time. Any API call that sets a property of the scene or geometries contained in the scene count as scene modification, e.g. including setting of intersection filter functions.</p>
<p>The kind of acceleration structure built can be influenced using scene flags (see <code>rtcSetSceneFlags</code>), and the quality can be specified using the <code>rtcSetSceneBuildQuality</code> function.</p>
<p>Embree silently ignores primitives during spatial acceleration structure construction that would cause numerical issues, e.g. primitives containing NaNs, INFs, or values greater than 1.844E18f (as no reasonable calculations can be performed with such values without causing overflows).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcjoincommitscene">rtcJoinCommitScene</a></p>
<p></p>
<h2 id="rtcjoincommitscene">rtcJoinCommitScene</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcJoinCommitScene - commits the scene from multiple threads</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcJoinCommitScene(RTCScene scene);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcJoinCommitScene</code> function commits all changes for the specified scene (<code>scene</code> argument). The scene commit internally triggers building of a spatial acceleration structure for the scene. Ray queries can be performed after scene changes got properly committed.</p>
<p>The <code>rtcJoinCommitScene</code> function can get called from multiple user threads which will all cooperate in the build operation. All threads calling into this function will return from <code>rtcJoinCommitScene</code> after the scene commit is finished. All threads must consistently call <code>rtcJoinCommitScene</code> and not <code>rtcCommitScene</code>.</p>
<p>In contrast to the <code>rtcCommitScene</code> function, the <code>rtcJoinCommitScene</code> function can be called from multiple user threads, while the <code>rtcCommitScene</code> can only get called from multiple TBB worker threads when used concurrently. For optimal performance we strongly recommend using TBB inside the application together with the <code>rtcCommitScene</code> function and to avoid using the <code>rtcJoinCommitScene</code> function.</p>
<p>The <code>rtcJoinCommitScene</code> feature allows a flexible way to lazily create hierarchies during rendering. A thread reaching a not-yet-constructed sub-scene of a two-level scene can generate the sub-scene geometry and call <code>rtcJoinCommitScene</code> on that just generated scene. During construction, further threads reaching the not-yet-built scene can join the build operation by also invoking <code>rtcJoinCommitScene</code>. A thread that calls <code>rtcJoinCommitScene</code> after the build finishes will directly return from the <code>rtcJoinCommitScene</code> call.</p>
<p>Multiple scene commit operations on different scenes can be running at the same time, hence it is possible to commit many small scenes in parallel, distributing the commits to many threads.</p>
<p>When using Embree with the Intel® Threading Building Blocks (which is the default), threads that call <code>rtcJoinCommitScene</code> will join the build operation, but other TBB worker threads might also participate in the build. To avoid thread oversubscription, we recommend using TBB also inside the application. Further, the join mode only works properly starting with TBB v4.4 Update 1. For earlier TBB versions, threads that call <code>rtcJoinCommitScene</code> to join a running build will just trigger the build and wait for the build to finish. Further, old TBB versions with <code>TBB_INTERFACE_VERSION_MAJOR &lt; 8</code> do not support <code>rtcJoinCommitScene</code>, and invoking this function will result in an error.</p>
<p>When using Embree with the internal tasking system, only threads that call <code>rtcJoinCommitScene</code> will perform the build operation, and no additional worker threads will be scheduled.</p>
<p>When using Embree with the Parallel Patterns Library (PPL), <code>rtcJoinCommitScene</code> is not supported and calling that function will result in an error.</p>
<p>To detect whether <code>rtcJoinCommitScene</code> is supported, use the <code>rtcGetDeviceProperty</code> function.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtccommitscene">rtcCommitScene</a>, <a href="#rtcgetdeviceproperty">rtcGetDeviceProperty</a></p>
<p></p>
<h2 id="rtcsetsceneprogressmonitorfunction">rtcSetSceneProgressMonitorFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetSceneProgressMonitorFunction - registers a callback
  to track build progress</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">typedef</span> <span class="dt">bool</span> (*RTCProgressMonitorFunction)(
  <span class="dt">void</span>* ptr,
  <span class="dt">double</span> n
);

<span class="dt">void</span> rtcSetSceneProgressMonitorFunction(
  RTCScene scene,
  RTCProgressMonitorFunction progress,
  <span class="dt">void</span>* userPtr
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Embree supports a progress monitor callback mechanism that can be used to report progress of hierarchy build operations and to cancel build operations.</p>
<p>The <code>rtcSetSceneProgressMonitorFunction</code> registers a progress monitor callback function (<code>progress</code> argument) with payload (<code>userPtr</code> argument) for the specified scene (<code>scene</code> argument).</p>
<p>Only a single callback function can be registered per scene, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>Once registered, Embree will invoke the callback function multiple times during hierarchy build operations of the scene, by passing the payload as set at registration time (<code>userPtr</code> argument), and a double in the range <span class="math inline">[0, 1]</span> which estimates the progress of the operation (<code>n</code> argument). The callback function might be called from multiple threads concurrently.</p>
<p>When returning <code>true</code> from the callback function, Embree will continue the build operation normally. When returning <code>false</code>, Embree will cancel the build operation with the <code>RTC_ERROR_CANCELLED</code> error code. Issuing multiple cancel requests for the same build operation is allowed.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewscene">rtcNewScene</a></p>
<p></p>
<h2 id="rtcsetscenebuildquality">rtcSetSceneBuildQuality</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetSceneBuildQuality - sets the build quality <span class="kw">for</span>
  the scene</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetSceneBuildQuality(
  RTCScene scene,
  <span class="kw">enum</span> RTCBuildQuality quality
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetSceneBuildQuality</code> function sets the build quality (<code>quality</code> argument) for the specified scene (<code>scene</code> argument). Possible values for the build quality are:</p>
<ul>
<li><p><code>RTC_BUILD_QUALITY_LOW</code>: Create lower quality data structures, e.g. for dynamic scenes. A two-level spatial index structure is built when enabling this mode, which supports fast partial scene updates, and allows for setting a per-geometry build quality through the <code>rtcSetGeometryBuildQuality</code> function.</p></li>
<li><p><code>RTC_BUILD_QUALITY_MEDIUM</code>: Default build quality for most usages. Gives a good compromise between build and render performance.</p></li>
<li><p><code>RTC_BUILD_QUALITY_HIGH</code>: Create higher quality data structures for final-frame rendering. For certain geometry types this enables a spatial split BVH.</p></li>
</ul>
<p>Selecting a higher build quality results in better rendering performance but slower scene commit times. The default build quality for a scene is <code>RTC_BUILD_QUALITY_MEDIUM</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrybuildquality">rtcSetGeometryBuildQuality</a></p>
<p></p>
<h2 id="rtcsetsceneflags">rtcSetSceneFlags</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetSceneFlags - sets the flags <span class="kw">for</span> the scene</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetSceneFlags(RTCScene scene, <span class="kw">enum</span> RTCSceneFlags flags);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetSceneFlags</code> function sets the scene flags (<code>flags</code> argument) for the specified scene (<code>scene</code> argument). Possible scene flags are:</p>
<ul>
<li><p><code>RTC_SCENE_FLAG_NONE</code>: No flags set.</p></li>
<li><p><code>RTC_SCENE_FLAG_DYNAMIC</code>: Provides better build performance for dynamic scenes (but also higher memory consumption).</p></li>
<li><p><code>RTC_SCENE_FLAG_COMPACT</code>: Uses compact acceleration structures and avoids algorithms that consume much memory.</p></li>
<li><p><code>RTC_SCENE_FLAG_ROBUST</code>: Uses acceleration structures that allow for robust traversal, and avoids optimizations that reduce arithmetic accuracy. This mode is typically used for avoiding artifacts caused by rays shooting through edges of neighboring primitives.</p></li>
<li><p><code>RTC_SCENE_FLAG_CONTEXT_FILTER_FUNCTION</code>: Enables support for a filter function inside the intersection context. See Section <a href="#rtcinitintersectcontext">rtcInitIntersectContext</a> for more details.</p></li>
</ul>
<p>Multiple flags can be enabled using an <code>or</code> operation, e.g. <code>RTC_SCENE_FLAG_COMPACT | RTC_SCENE_FLAG_ROBUST</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetsceneflags">rtcGetSceneFlags</a></p>
<p></p>
<h2 id="rtcgetsceneflags">rtcGetSceneFlags</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetSceneFlags - returns the flags of the scene</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">enum</span> RTCSceneFlags rtcGetSceneFlags(RTCScene scene);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Queries the flags of a scene. This function can be useful when setting individual flags, e.g. to just set the robust mode without changing other flags the following way:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCSceneFlags flags = rtcGetSceneFlags(scene);
rtcSetSceneFlags(scene, RTC_SCENE_FLAG_ROBUST | flags);</code></pre></div>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>RTC_SCENE_FLAG_NONE</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetsceneflags">rtcSetSceneFlags</a></p>
<p></p>
<h2 id="rtcgetscenebounds">rtcGetSceneBounds</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetSceneBounds - returns the axis-aligned bounding box of the scene</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCORE_ALIGN(<span class="dv">16</span>) RTCBounds
{
  <span class="dt">float</span> lower_x, lower_y, lower_z, align0;
  <span class="dt">float</span> upper_x, upper_y, upper_z, align1;
};

<span class="dt">void</span> rtcGetSceneBounds(
  RTCScene scene,
  <span class="kw">struct</span> RTCBounds* bounds_o
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetSceneBounds</code> function queries the axis-aligned bounding box of the specified scene (<code>scene</code> argument) and stores that bounding box to the provided destination pointer (<code>bounds_o</code> argument). The stored bounding box consists of lower and upper bounds for the x, y, and z dimensions as specified by the <code>RTCBounds</code> structure.</p>
<p>The provided destination pointer must be aligned to 16 bytes. The function may be invoked only after committing the scene; otherwise the result is undefined.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetscenelinearbounds">rtcGetSceneLinearBounds</a>, <a href="#rtccommitscene">rtcCommitScene</a>, <a href="#rtcjoincommitscene">rtcJoinCommitScene</a></p>
<p></p>
<h2 id="rtcgetscenelinearbounds">rtcGetSceneLinearBounds</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetSceneLinearBounds - returns the linear bounds of the scene</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCORE_ALIGN(<span class="dv">16</span>) RTCLinearBounds
{
  RTCBounds bounds0;
  RTCBounds bounds1;
};

<span class="dt">void</span> rtcGetSceneLinearBounds(
  RTCScene scene,
  <span class="kw">struct</span> RTCLinearBounds* bounds_o
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetSceneLinearBounds</code> function queries the linear bounds of the specified scene (<code>scene</code> argument) and stores them to the provided destination pointer (<code>bounds_o</code> argument). The stored linear bounds consist of bounding boxes for time 0 (<code>bounds0</code> member) and time 1 (<code>bounds1</code> member) as specified by the <code>RTCLinearBounds</code> structure. Linearly interpolating these bounds to a specific time <code>t</code> yields bounds for the geometry at that time.</p>
<p>The provided destination pointer must be aligned to 16 bytes. The function may be called only after committing the scene, otherwise the result is undefined.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetscenebounds">rtcGetSceneBounds</a>, <a href="#rtccommitscene">rtcCommitScene</a>, <a href="#rtcjoincommitscene">rtcJoinCommitScene</a></p>
<p></p>
<h2 id="rtcnewgeometry">rtcNewGeometry</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewGeometry - creates a <span class="kw">new</span> geometry object</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">enum</span> RTCGeometryType
{
 RTC_GEOMETRY_TYPE_TRIANGLE,
 RTC_GEOMETRY_TYPE_QUAD,
 RTC_GEOMETRY_TYPE_SUBDIVISION,
 RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE,
 RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE,
 RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE,
 RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE,
 RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE,
 RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BEZIER_CURVE,
 RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BSPLINE_CURVE,
 RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_HERMITE_CURVE,
 RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_CATMULL_ROM_CURVE,
 RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE,
 RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE,
 RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE,
 RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE,
 RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE,
 RTC_GEOMETRY_TYPE_GRID,
 RTC_GEOMETRY_TYPE_SPHERE_POINT,
 RTC_GEOMETRY_TYPE_DISC_POINT,
 RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT,
 RTC_GEOMETRY_TYPE_USER,
 RTC_GEOMETRY_TYPE_INSTANCE
};

RTCGeometry rtcNewGeometry(
  RTCDevice device,
  <span class="kw">enum</span> RTCGeometryType type
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Geometries are objects that represent an array of primitives of the same type. The <code>rtcNewGeometry</code> function creates a new geometry of specified type (<code>type</code> argument) bound to the specified device (<code>device</code> argument) and returns a handle to this geometry. The geometry object is reference counted with an initial reference count of 1. The geometry handle can be released using the <code>rtcReleaseGeometry</code> API call.</p>
<p>Supported geometry types are triangle meshes (<code>RTC_GEOMETRY_TYPE_TRIANGLE</code> type), quad meshes (triangle pairs) (<code>RTC_GEOMETRY_TYPE_QUAD</code> type), Catmull-Clark subdivision surfaces (<code>RTC_GEOMETRY_TYPE_SUBDIVISION</code> type), curve geometries with different bases (<code>RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE</code>,<br />
<code>RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE</code>,<br />
<code>RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE</code>, <code>RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BSPLINE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_HERMITE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_CATMULL_ROM_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE</code> types) grid meshes (<code>RTC_GEOMETRY_TYPE_GRID</code>), point geometries (<code>RTC_GEOMETRY_TYPE_SPHERE_POINT</code>, <code>RTC_GEOMETRY_TYPE_DISC_POINT</code>, <code>RTC_TYPE_ORIENTED_DISC_POINT</code>), user-defined geometries (<code>RTC_GEOMETRY_TYPE_USER</code>), and instances (<code>RTC_GEOMETRY_TYPE_INSTANCE</code>).</p>
<p>The types <code>RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE</code>, and <code>RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE</code> will treat the curve as a sweep surface of a varying-radius circle swept tangentially along the curve. The types <code>RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE</code>, and <code>RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE</code> use ray-facing ribbons as a faster-to-intersect approximation.</p>
<p>After construction, geometries are enabled by default and not attached to any scene. Geometries can be disabled (<code>rtcDisableGeometry</code> call), and enabled again (<code>rtcEnableGeometry</code> call). A geometry can be attached to multiple scenes using the <code>rtcAttachGeometry</code> call (or <code>rtcAttachGeometryByID</code> call), and detached using the <code>rtcDetachGeometry</code> call. During attachment, a geometry ID is assigned to the geometry (or assigned by the user when using the <code>rtcAttachGeometryByID</code> call), which uniquely identifies the geometry inside that scene. This identifier is returned when primitives of the geometry are hit in later ray queries for the scene.</p>
<p>Geometries can also be modified, including their vertex and index buffers. After modifying a buffer, <code>rtcUpdateGeometryBuffer</code> must be called to notify that the buffer got modified.</p>
<p>The application can use the <code>rtcSetGeometryUserData</code> function to set a user data pointer to its own geometry representation, and later read out this pointer using the <code>rtcGetGeometryUserData</code> function.</p>
<p>After setting up the geometry or modifying it, <code>rtcCommitGeometry</code> must be called to finish the geometry setup. After committing the geometry, vertex data interpolation can be performed using the <code>rtcInterpolate</code> and <code>rtcInterpolateN</code> functions.</p>
<p>A build quality can be specified for a geometry using the <code>rtcSetGeometryBuildQuality</code> function, to balance between acceleration structure build performance and ray query performance. The build quality per geometry will be used if a two-level acceleration structure is built internally, which is the case if the <code>RTC_BUILD_QUALITY_LOW</code> is set as the scene build quality. See Section <a href="#rtcsetscenebuildquality">rtcSetSceneBuildQuality</a> for more details.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcenablegeometry">rtcEnableGeometry</a>, <a href="#rtcdisablegeometry">rtcDisableGeometry</a>, <a href="#rtcattachgeometry">rtcAttachGeometry</a>, <a href="#rtcattachgeometrybyid">rtcAttachGeometryByID</a>, <a href="#rtcupdategeometrybuffer">rtcUpdateGeometryBuffer</a>, <a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcgetgeometryuserdata">rtcGetGeometryUserData</a>, <a href="#rtccommitgeometry">rtcCommitGeometry</a>, <a href="#rtcinterpolate">rtcInterpolate</a>, <a href="#rtcinterpolaten">rtcInterpolateN</a>, <a href="#rtcsetgeometrybuildquality">rtcSetGeometryBuildQuality</a>, <a href="#rtcsetscenebuildquality">rtcSetSceneBuildQuality</a>, <a href="#rtc_geometry_type_triangle">RTC_GEOMETRY_TYPE_TRIANGLE</a>, <a href="#rtc_geometry_type_quad">RTC_GEOMETRY_TYPE_QUAD</a>, <a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a>, <a href="#rtc_geometry_type_curve">RTC_GEOMETRY_TYPE_CURVE</a>, <a href="#rtc_geometry_type_grid">RTC_GEOMETRY_TYPE_GRID</a>, <a href="#rtc_geometry_type_point">RTC_GEOMETRY_TYPE_POINT</a>, <a href="#rtc_geometry_type_user">RTC_GEOMETRY_TYPE_USER</a>, <a href="#rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</a></p>
<p></p>
<h2 id="rtc_geometry_type_triangle">RTC_GEOMETRY_TYPE_TRIANGLE</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_TRIANGLE - triangle geometry type</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_TRIANGLE);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Triangle meshes are created by passing <code>RTC_GEOMETRY_TYPE_TRIANGLE</code> to the <code>rtcNewGeometry</code> function call. The triangle indices can be specified by setting an index buffer (<code>RTC_BUFFER_TYPE_INDEX</code> type) and the triangle vertices by setting a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> type). See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers. The index buffer must contain an array of three 32-bit indices per triangle (<code>RTC_FORMAT_UINT3</code> format) and the number of primitives is inferred from the size of that buffer. The vertex buffer must contain an array of single precision <code>x</code>, <code>y</code>, <code>z</code> floating point coordinates (<code>RTC_FORMAT_FLOAT3</code> format), and the number of vertices are inferred from the size of that buffer. The vertex buffer can be at most 16 GB large.</p>
<p>The parametrization of a triangle uses the first vertex <code>p0</code> as base point, the vector <code>p1 - p0</code> as u-direction and the vector <code>p2 - p0</code> as v-direction. Thus vertex attributes <code>t0,t1,t2</code> can be linearly interpolated over the triangle the following way:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">t_uv = (<span class="dv">1</span>-u-v)*t0 + u*t1 + v*t2
     = t0 + u*(t1-t0) + v*(t2-t0)</code></pre></div>
<p>A triangle whose vertices are laid out counter-clockwise has its geometry normal pointing upwards outside the front face, like illustrated in the following picture:</p>
<div class="figure">
<img src="images/triangle_uv.png" />

</div>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers have to have the same stride and size.</p>
<p>Also see tutorial <a href="tutorials.html#triangle-geometry">Triangle Geometry</a> for an example of how to create triangle meshes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that be get queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtc_geometry_type_quad">RTC_GEOMETRY_TYPE_QUAD</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_QUAD - quad geometry type</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_QUAD);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Quad meshes are created by passing <code>RTC_GEOMETRY_TYPE_QUAD</code> to the <code>rtcNewGeometry</code> function call. The quad indices can be specified by setting an index buffer (<code>RTC_BUFFER_TYPE_INDEX</code> type) and the quad vertices by setting a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> type). See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers. The index buffer contains an array of four 32-bit indices per quad (<code>RTC_FORMAT_UINT4</code> format), and the number of primitives is inferred from the size of that buffer. The vertex buffer contains an array of single precision <code>x</code>, <code>y</code>, <code>z</code> floating point coordinates (<code>RTC_FORMAT_FLOAT3</code> format), and the number of vertices is inferred from the size of that buffer. The vertex buffer can be at most 16 GB large.</p>
<p>A quad is internally handled as a pair of two triangles <code>v0,v1,v3</code> and <code>v2,v3,v1</code>, with the <code>u'</code>/<code>v'</code> coordinates of the second triangle corrected by <code>u = 1-u'</code> and <code>v = 1-v'</code> to produce a quad parametrization where <code>u</code> and <code>v</code> are in the range 0 to 1. Thus the parametrization of a quad uses the first vertex <code>p0</code> as base point, and the vector <code>p1 - p0</code> as <code>u</code>-direction, and <code>p3 - p0</code> as v-direction. Thus vertex attributes <code>t0,t1,t2,t3</code> can be bilinearly interpolated over the quadrilateral the following way:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">t_uv = (<span class="dv">1</span>-v)((<span class="dv">1</span>-u)*t0 + u*t1) + v*((<span class="dv">1</span>-u)*t3 + u*t2)</code></pre></div>
<p>Mixed triangle/quad meshes are supported by encoding a triangle as a quad, which can be achieved by replicating the last triangle vertex (<code>v0,v1,v2</code> -&gt; <code>v0,v1,v2,v2</code>). This way the second triangle is a line (which can never get hit), and the parametrization of the first triangle is compatible with the standard triangle parametrization.</p>
<p>A quad whose vertices are laid out counter-clockwise has its geometry normal pointing upwards outside the front face, like illustrated in the following picture.</p>
<div class="figure">
<img src="images/quad_uv.png" />

</div>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtc_geometry_type_grid">RTC_GEOMETRY_TYPE_GRID</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_GRID - grid geometry type</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_GRID);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Grid meshes are created by passing <code>RTC_GEOMETRY_TYPE_GRID</code> to the <code>rtcNewGeometry</code> function call, and contain an array of grid primitives. This array of grids can be specified by setting up a grid buffer (with <code>RTC_BUFFER_TYPE_GRID</code> type and <code>RTC_FORMAT_GRID</code> format) and the grid mesh vertices by setting a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> type). See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers. The number of grid primitives in the grid mesh is inferred from the size of the grid buffer.</p>
<p>The vertex buffer contains an array of single precision <code>x</code>, <code>y</code>, <code>z</code> floating point coordinates (<code>RTC_FORMAT_FLOAT3</code> format), and the number of vertices is inferred from the size of that buffer.</p>
<p>Each grid in the grid buffer is of the type <code>RTCGrid</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> RTCGrid
{
  <span class="dt">unsigned</span> <span class="dt">int</span> startVertexID;
  <span class="dt">unsigned</span> <span class="dt">int</span> stride;
  <span class="dt">unsigned</span> <span class="dt">short</span> width,height; 
};</code></pre></div>
<p>The <code>RTCGrid</code> structure describes a 2D grid of vertices (with respect to the vertex buffer of the grid mesh). The <code>width</code> and <code>height</code> members specify the number of vertices in u and v direction, e.g. setting both <code>width</code> and <code>height</code> to 3 sets up a 3×3 vertex grid. The maximum allowed <code>width</code> and <code>height</code> is 32767. The <code>startVertexID</code> specifies the ID of the top-left vertex in the vertex grid, while the <code>stride</code> parameter specifies a stride (in number of vertices) used to step to the next row.</p>
<p>A vertex grid of dimensions <code>width</code> and <code>height</code> is treated as a <code>(width-1)</code> x <code>(height-1)</code> grid of <code>quads</code> (triangle-pairs), with the same shared edge handling as for regular quad meshes. However, the <code>u</code>/<code>v</code> coordinates have the uniform range <code>[0..1]</code> for an entire vertex grid. The <code>u</code> direction follows the <code>width</code> of the grid while the <code>v</code> direction the <code>height</code>.</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_SUBDIVISION - subdivision geometry type</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_SUBDIVISION);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Catmull-Clark subdivision meshes are supported, including support for edge creases, vertex creases, holes, non-manifold geometry, and face-varying interpolation. The number of vertices per face can be in the range of 3 to 15 vertices (triangles, quadrilateral, pentagons, etc).</p>
<p>Subdivision meshes are created by passing <code>RTC_GEOMETRY_TYPE_SUBDIVISION</code> to the <code>rtcNewGeometry</code> function. Various buffers need to be set by the application to set up the subdivision mesh. See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers. The face buffer (<code>RTC_BUFFER_TYPE_FACE</code> type and <code>RTC_FORMAT_UINT</code> format) contains the number of edges/indices of each face (3 to 15), and the number of faces is inferred from the size of this buffer. The index buffer (<code>RTC_BUFFER_TYPE_INDEX</code> type) contains multiple (3 to 15) 32-bit vertex indices (<code>RTC_FORMAT_UINT</code> format) for each face, and the number of edges is inferred from the size of this buffer. The vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> type) stores an array of single precision <code>x</code>, <code>y</code>, <code>z</code> floating point coordinates (<code>RTC_FORMAT_FLOAT3</code> format), and the number of vertices is inferred from the size of this buffer.</p>
<p>Optionally, the application may set additional index buffers using different buffer slots if multiple topologies are required for face-varying interpolation. The standard vertex buffers (<code>RTC_BUFFER_TYPE_VERTEX</code>) are always bound to the geometry topology (topology 0) thus use <code>RTC_BUFFER_TYPE_INDEX</code> with buffer slot 0. User vertex data interpolation may use different topologies as described later.</p>
<p>Optionally, the application can set up the hole buffer (<code>RTC_BUFFER_TYPE_HOLE</code>) which contains an array of 32-bit indices (<code>RTC_FORMAT_UINT</code> format) of faces that should be considered non-existing in all topologies. The number of holes is inferred from the size of this buffer.</p>
<p>Optionally, the application can fill the level buffer (<code>RTC_BUFFER_TYPE_LEVEL</code>) with a tessellation rate for each of the edges of each face. This buffer must have the same size as the index buffer. The tessellation level is a positive floating point value (<code>RTC_FORMAT_FLOAT</code> format) that specifies how many quads along the edge should be generated during tessellation. If no level buffer is specified, a level of 1 is used. The maximally supported edge level is 4096, and larger levels are clamped to that value. Note that edges may be shared between (typically 2) faces. To guarantee a watertight tessellation, the level of these shared edges should be identical. A uniform tessellation rate for an entire subdivision mesh can be set by using the <code>rtcSetGeometryTessellationRate</code> function. The existence of a level buffer has precedence over the uniform tessellation rate.</p>
<p>Optionally, the application can fill the sparse edge crease buffers to make edges appear sharper. The edge crease index buffer (<code>RTC_BUFFER_TYPE_EDGE_CREASE_INDEX</code>) contains an array of pairs of 32-bit vertex indices (<code>RTC_FORMAT_UINT2</code> format) that specify unoriented edges in the geometry topology. The edge crease weight buffer (<code>RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT</code>) stores for each of these crease edges a positive floating point weight (<code>RTC_FORMAT_FLOAT</code> format). The number of edge creases is inferred from the size of these buffers, which has to be identical. The larger a weight, the sharper the edge. Specifying a weight of infinity is supported and marks an edge as infinitely sharp. Storing an edge multiple times with the same crease weight is allowed, but has lower performance. Storing an edge multiple times with different crease weights results in undefined behavior. For a stored edge (i,j), the reverse direction edges (j,i) do not have to be stored, as both are considered the same unoriented edge. Edge crease features are shared between all topologies.</p>
<p>Optionally, the application can fill the sparse vertex crease buffers to make vertices appear sharper. The vertex crease index buffer (<code>RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX</code>), contains an array of 32-bit vertex indices (<code>RTC_FORMAT_UINT</code> format) to specify a set of vertices from the geometry topology. The vertex crease weight buffer (<code>RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT</code>) specifies for each of these vertices a positive floating point weight (<code>RTC_FORMAT_FLOAT</code> format). The number of vertex creases is inferred from the size of these buffers, and has to be identical. The larger a weight, the sharper the vertex. Specifying a weight of infinity is supported and makes the vertex infinitely sharp. Storing a vertex multiple times with the same crease weight is allowed, but has lower performance. Storing a vertex multiple times with different crease weights results in undefined behavior. Vertex crease features are shared between all topologies.</p>
<p>Subdivision modes can be used to force linear interpolation for parts of the subdivision mesh; see <code>rtcSetGeometrySubdivisionMode</code> for more details.</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers have to have the same stride and size.</p>
<p>Also see tutorial <a href="tutorials.html#subdivision-geometry">Subdivision Geometry</a> for an example of how to create subdivision surfaces.</p>
<h4 id="parametrization">Parametrization</h4>
<p>The parametrization for subdivision faces is different for quadrilaterals and non-quadrilateral faces.</p>
<p>The parametrization of a quadrilateral face uses the first vertex <code>p0</code> as base point, and the vector <code>p1 - p0</code> as u-direction and <code>p3 - p0</code> as v-direction.</p>
<p>The parametrization for all other face types (with number of vertices not equal 4), have a special parametrization where the subpatch ID <code>n</code> (of the <code>n</code>-th quadrilateral that would be obtained by a single subdivision step) and the local hit location inside this quadrilateral are encoded in the UV coordinates. The following code extracts the sub-patch ID <code>i</code> and local UVs of this subpatch:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">int</span> l = floorf(<span class="fl">0.5f</span>*U);
<span class="dt">unsigned</span> <span class="dt">int</span> h = floorf(<span class="fl">0.5f</span>*V);
<span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">4</span>*h+l;
<span class="dt">float</span> u = <span class="fl">2.0f</span>*fracf(<span class="fl">0.5f</span>*U)<span class="fl">-0.5f</span>;
<span class="dt">float</span> v = <span class="fl">2.0f</span>*fracf(<span class="fl">0.5f</span>*V)<span class="fl">-0.5f</span>;</code></pre></div>
<p>This encoding allows local subpatch UVs to be in the range <code>[-0.5,1.5[</code> thus negative subpatch UVs can be passed to <code>rtcInterpolate</code> to sample subpatches slightly out of bounds. This can be useful to calculate derivatives using finite differences if required. The encoding further has the property that one can just move the value <code>u</code> (or <code>v</code>) on a subpatch by adding <code>du</code> (or <code>dv</code>) to the special UV encoding as long as it does not fall out of the <code>[-0.5,1.5[</code> range.</p>
<p>To smoothly interpolate vertex attributes over the subdivision surface we recommend using the <code>rtcInterpolate</code> function, which will apply the standard subdivision rules for interpolation and automatically takes care of the special UV encoding for non-quadrilaterals.</p>
<h4 id="face-varying-data">Face-Varying Data</h4>
<p>Face-varying interpolation is supported through multiple topologies per subdivision mesh and binding such topologies to vertex attribute buffers to interpolate. This way, texture coordinates may use a different topology with additional boundaries to construct separate UV regions inside one subdivision mesh.</p>
<p>Each such topology <code>i</code> has a separate index buffer (specified using <code>RTC_BUFFER_TYPE_INDEX</code> with buffer slot <code>i</code>) and separate subdivision mode that can be set using <code>rtcSetGeometrySubdivisionMode</code>. A vertex attribute buffer <code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code> bound to a buffer slot <code>j</code> can be assigned to use a topology for interpolation using the <code>rtcSetGeometryVertexAttributeTopology</code> call.</p>
<p>The face buffer (<code>RTC_BUFFER_TYPE_FACE</code> type) is shared between all topologies, which means that the <code>n</code>-th primitive always has the same number of vertices (e.g. being a triangle or a quad) for each topology. However, the indices of the topologies themselves may be different.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtc_geometry_type_curve">RTC_GEOMETRY_TYPE_CURVE</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE -
  flat curve geometry with linear basis

RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE -
  flat curve geometry with cubic Bézier basis

RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE - 
  flat curve geometry with cubic B-spline basis

RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE - 
  flat curve geometry with cubic Hermite basis

RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE - 
  flat curve geometry with Catmull-Rom basis

RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BEZIER_CURVE -
  flat normal oriented curve geometry with cubic Bézier basis

RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BSPLINE_CURVE - 
  flat normal oriented curve geometry with cubic B-spline basis

RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_HERMITE_CURVE - 
  flat normal oriented curve geometry with cubic Hermite basis

RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_CATMULL_ROM_CURVE - 
  flat normal oriented curve geometry with Catmull-Rom basis

RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE -
  capped cone curve geometry with linear basis <span class="kw">and</span> spherical ending

RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE -
  swept surface curve geometry with cubic Bézier basis

RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE -
  swept surface curve geometry with cubic B-spline basis

RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE -
  swept surface curve geometry with cubic Hermite basis

RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE -
  swept surface curve geometry with Catmull-Rom basis</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BEZIER_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BSPLINE_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_HERMITE_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_CATMULL_ROM_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Curves with per vertex radii are supported with linear, cubic Bézier, cubic B-spline, and cubic Hermite bases. Such curve geometries are created by passing <code>RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE</code>, <code>RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_FLAT_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_FLAT_BSPLINE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_FLAT_HERMITE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_FLAT_CATMULL_ROM_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE</code>, <code>RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE</code>, or <code>RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE</code> to the <code>rtcNewGeometry</code> function. The curve indices can be specified through an index buffer (<code>RTC_BUFFER_TYPE_INDEX</code>) and the curve vertices through a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code>). For the Hermite basis a tangent buffer (<code>RTC_BUFFER_TYPE_TANGENT</code>), normal oriented curves a normal buffer (<code>RTC_BUFFER_TYPE_NORMAL</code>), and for normal oriented Hermite curves a normal derivative buffer (<code>RTC_BUFFER_TYPE_NORMAL_DERIVATIVE</code>) has to get specified additionally. See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers.</p>
<p>The index buffer contains an array of 32-bit indices (<code>RTC_FORMAT_UINT</code> format), each pointing to the first control vertex in the vertex buffer, but also to the first tangent in the tangent buffer, and first normal in the normal buffer if these buffers are present.</p>
<p>The vertex buffer stores each control vertex in the form of a single precision position and radius stored in (<code>x</code>, <code>y</code>, <code>z</code>, <code>r</code>) order in memory (<code>RTC_FORMAT_FLOAT4</code> format). The number of vertices is inferred from the size of this buffer. The radii may be smaller than zero but the interpolated radii should always be greater or equal to zero. Similarly, the tangent buffer stores the derivative of each control vertex (<code>x</code>, <code>y</code>, <code>z</code>, <code>r</code> order and <code>RTC_FORMAT_FLOAT4</code> format) and the normal buffer stores a single precision normal per control vertex (<code>x</code>, <code>y</code>, <code>z</code> order and <code>RTC_FORMAT_FLOAT3</code> format).</p>
<h5 id="linear-basis">Linear Basis</h5>
<p>For the linear basis the indices point to the first of 2 consecutive control points in the vertex buffer. The first control point is the start and the second control point the end of the line segment. When constructing hair strands in this basis, the end-point can be shared with the start of the next line segment.</p>
<p>For the linear basis the user has to additionally provide a flags buffer of type <code>RTC_BUFFER_TYPE_FLAGS</code> which contains bytes that encode if the left neighbor segment (<code>RTC_CURVE_FLAG_NEIGHBOR_LEFT</code> flag) and/or right neighbor segment (<code>RTC_CURVE_FLAG_NEIGHBOR_RIGHT</code> flags) exist (see <a href="#rtccurveflags">RTCCurveFlags</a>).</p>
<p>A left neighbor segment is assumed to end at the start vertex of the current segement, and to start at the previous vertex in the vertex buffer. Similarly, the right neighbor segment is assumed to start at the end vertex of the current segment, and to end at the next vertex in the vertex buffer.</p>
<p>Only when the left and right bits are properly specified the current segment can properly attach to the left and/or right neighbor, otherwise the touching area may not get rendererd properly.</p>
<h5 id="bézier-basis">Bézier Basis</h5>
<p>For the cubic Bézier basis the indices point to the first of 4 consecutive control points in the vertex buffer. These control points use the cubic Bézier basis, where the first control point represents the start point of the curve, and the 4th control point the end point of the curve. The Bézier basis is interpolating, thus the curve does go exactly through the first and fourth control vertex.</p>
<h5 id="b-spline-basis">B-spline Basis</h5>
<p>For the cubic B-spline basis the indices point to the first of 4 consecutive control points in the vertex buffer. These control points make up a cardinal cubic B-spline (implicit equidistant knot vector). This basis is not interpolating, thus the curve does in general not go through any of the control points directly. A big advantage of this basis is that 3 control points can be shared for two continuous neighboring curve segments, e.g. the curves (p0,p1,p2,p3) and (p1,p2,p3,p4) are C1 continuous. This feature make this basis a good choise to construct continuous multi-segment curves, as memory consumption can be kept minimal.</p>
<h5 id="hermite-basis">Hermite Basis</h5>
<p>For the cubic Hermite basis the indices point to the first of 2 consecutive points in the vertex buffer, and the first of 2 consecutive tangents in the tangent buffer. These two points and two tangents make up a cubic Hermite curve. This basis is interpolating, thus does exactly go through the first and second control point, and the first order derivative at the begin and end matches exactly the value specified in the tangent buffer. When connecting two segments continuously, the end point and tangent of the previous segment can be shared. Different versions of Catmull-Rom splines can be easily constructed usig the Hermite basis, by calculating a proper tangent buffer from the control points.</p>
<h5 id="catmull-rom-basis">Catmull-Rom Basis</h5>
<p>For the Catmull-Rom basis the indices point to the first of 4 consecutive control points in the vertex buffer. This basis goes through p1 and p2, with tangents (p2-p0)/2 and (p3-p1)/2.</p>
<h5 id="flat-curves">Flat Curves</h5>
<p>The <code>RTC_GEOMETRY_TYPE_FLAT_*</code> flat mode is a fast mode designed to render distant hair. In this mode the curve is rendered as a connected sequence of ray facing quads. Individual quads are considered to have subpixel size, and zooming onto the curve might show geometric artifacts. The number of quads to subdivide into can be specified through the <code>rtcSetGeometryTessellationRate</code> function. By default the tessellation rate is 4.</p>
<h5 id="normal-oriented-curves">Normal Oriented Curves</h5>
<p>The <code>RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_*</code> mode is a mode designed to render blades of grass. In this mode a vertex spline has to get specified as for the previous modes, but additionally a normal spline is required. If the Hermite basis is used, the <code>RTC_BUFFER_TYPE_NORMAL</code> and <code>RTC_BUFFER_TYPE_NORMAL_DERIVATIVE</code> buffers have both to be set.</p>
<p>The curve is rendered as a flat band whose center approximately follows the provided vertex spline, whose half width approximately follows the provided radius spline, and whose normal orientation approximately follows the provided normal spline.</p>
<p>To intersect the normal oriented curve, we perform a newton-raphson style intersection of a ray with a tensor product surface of a linear basis (perpendicular to the curve) and cubic Bézier basis (along the curve). We use a guide curve and its derivatives to construct the control points of that surface. The guide curve is defined by a sweep surface defined by sweeping a line centered at the vertex spline location along the curve. At each parameter value the half width of the line matches the radius spline, and the direction matches the cross product of the normal from the normal spline and tangent of the vertex spline. Note that this construction does not work when the provided normals are parallel to the curve direction. For this reason the provided normals should best be kept as perpendicular to the curve direction as possible.</p>
<h5 id="round-curves">Round Curves</h5>
<p>In the <code>RTC_GEOMETRY_TYPE_ROUND_*</code> round mode, a real geometric surface is rendered for the curve, which is more expensive but allows closeup views.</p>
<p>For the linear basis the round mode renders an end sphere for a segment and a cone that tangentially touches that ending sphere (and an imaginary start sphere). The geometry clips away parts of the end spheres that lies inside the neighboring segments, thus the curve interiour will also render properly as long as only neighboring segments penetrate into a segment. For this to work properly it is important that the flags buffer is properly populated with neighbor information.</p>
<p>For the cubic polynomial bases, the round mode renders a sweep surface by sweeping a varying radius circle tangential along the curve. As a limitation, the radius of the curve has to be smaller than the curvature radius of the curve at each location on the curve.</p>
<p>The intersection with the curve segment stores the parametric hit location along the curve segment as u-coordinate (range 0 to +1).</p>
<p>For flat curves, the v-coordinate is set to the normalized distance in the range -1 to +1. For normal oriented curves the v-coordinate is in the range 0 to 1. For the linear basis and in round mode the v-coordinate is set to zero.</p>
<p>In flat mode, the geometry normal <code>Ng</code> is set to the tangent of the curve at the hit location. In round mode and for normal oriented curves, the geometry normal <code>Ng</code> is set to the non-normalized geometric normal of the surface.</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size. For the Hermite basis also a tangent buffer has to be set for each time step and for normal oriented curves a normal buffer has to get specified for each time step.</p>
<p>Also see tutorials <a href="tutorials.html#hair">Hair</a> and <a href="tutorials.html#bézier-curves">Curves</a> for examples of how to create and use curve geometries.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p>[rtcNewGeometry, RTCCurveFlags]</p>
<p></p>
<h2 id="rtc_geometry_type_point">RTC_GEOMETRY_TYPE_POINT</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_SPHERE_POINT -
  point geometry spheres

RTC_GEOMETRY_TYPE_DISC_POINT -
  point geometry with ray-oriented discs

RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT -
  point geometry with normal-oriented discs</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

rtcNewGeometry(device, RTC_GEOMETRY_TYPE_SPHERE_POINT);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_DISC_POINT);
rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Points with per vertex radii are supported with sphere, ray-oriented discs, and normal-oriented discs geometric representations. Such point geometries are created by passing <code>RTC_GEOMETRY_TYPE_SPHERE_POINT</code>, <code>RTC_GEOMETRY_TYPE_DISC_POINT</code>, or <code>RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT</code> to the <code>rtcNewGeometry</code> function. The point vertices can be specified t through a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code>). For the normal oriented discs a normal buffer (<code>RTC_BUFFER_TYPE_NORMAL</code>) has to get specified additionally. See <code>rtcSetGeometryBuffer</code> and <code>rtcSetSharedGeometryBuffer</code> for more details on how to set buffers.</p>
<p>The vertex buffer stores each control vertex in the form of a single precision position and radius stored in (<code>x</code>, <code>y</code>, <code>z</code>, <code>r</code>) order in memory (<code>RTC_FORMAT_FLOAT4</code> format). The number of vertices is inferred from the size of this buffer. Similarly, the normal buffer stores a single precision normal per control vertex (<code>x</code>, <code>y</code>, <code>z</code> order and <code>RTC_FORMAT_FLOAT3</code> format).</p>
<p>In the <code>RTC_GEOMETRY_TYPE_SPHERE_POINT</code> mode, a real geometric surface is rendered for the curve, which is more expensive but allows closeup views.</p>
<p>The <code>RTC_GEOMETRY_TYPE_DISC_POINT</code> flat mode is a fast mode designed to render distant points. In this mode the point is rendered as a ray facing disc.</p>
<p>The <code>RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT</code> mode is a mode designed as a midpoint geometrically between ray facing discs and spheres. In this mode the point is rendered as a normal oriented disc.</p>
<p>For all point types, only the hit distance and geometry normal is returned as hit information, u and v are set to zero.</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size.</p>
<p>Also see tutorial [Points] for an example of how to create and use point geometries.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a></p>
<p></p>
<h2 id="rtc_geometry_type_user">RTC_GEOMETRY_TYPE_USER</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_USER - user geometry type</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_USER);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>User-defined geometries contain a number of user-defined primitives, just like triangle meshes contain multiple triangles. The shape of the user-defined primitives is specified through registered callback functions, which enable extending Embree with arbitrary types of primitives.</p>
<p>User-defined geometries are created by passing <code>RTC_GEOMETRY_TYPE_USER</code> to the <code>rtcNewGeometry</code> function call. One has to set the number of primitives (see <code>rtcSetGeometryUserPrimitiveCount</code>), a user data pointer (see <code>rtcSetGeometryUserData</code>), a bounding function closure (see <code>rtcSetGeometryBoundsFunction</code>), as well as user-defined intersect (see <code>rtcSetGeometryIntersectFunction</code>) and occluded (see <code>rtcSetGeometryOccludedFunction</code>) callback functions. The bounding function is used to query the bounds of all time steps of a user primitive, while the intersect and occluded callback functions are called to intersect the primitive with a ray. The user data pointer is passed to each callback invocation and can be used to point to the application's representation of the user geometry.</p>
<p>The creation of a user geometry typically looks the following:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCGeometry geometry = rtcNewGeometry(device, RTC_GEOMETRY_TYPE_USER);
rtcSetGeometryUserPrimitiveCount(geometry, numPrimitives);
rtcSetGeometryUserData(geometry, userGeometryRepresentation);
rtcSetGeometryBoundsFunction(geometry, boundsFunction);
rtcSetGeometryIntersectFunction(geometry, intersectFunction);
rtcSetGeometryOccludedFunction(geometry, occludedFunction);</code></pre></div>
<p>Please have a look at the <code>rtcSetGeometryBoundsFunction</code>, <code>rtcSetGeometryIntersectFunction</code>, and <code>rtcSetGeometryOccludedFunction</code> functions on the implementation of the callback functions.</p>
<p>See tutorial <a href="tutorials.html#user-geometry">User Geometry</a> for an example of how to use the user-defined geometries.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcsetgeometryuserprimitivecount">rtcSetGeometryUserPrimitiveCount</a>, <a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcsetgeometryboundsfunction">rtcSetGeometryBoundsFunction</a>, <a href="#rtcsetgeometryintersectfunction">rtcSetGeometryIntersectFunction</a>, <a href="#rtcsetgeometryoccludedfunction">rtcSetGeometryOccludedFunction</a></p>
<p></p>
<h2 id="rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTC_GEOMETRY_TYPE_INSTANCE - instance geometry type</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCGeometry geometry =
   rtcNewGeometry(device, RTC_GEOMETRY_TYPE_INSTANCE);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Embree supports instancing of scenes using affine transformations (3×3 matrix plus translation). As the instanced scene is stored only a single time, even if instanced to multiple locations, this feature can be used to create very complex scenes with small memory footprint.</p>
<p>Embree supports both single-level instancing and multi-level instancing. The maximum instance nesting depth is <code>RTC_MAX_INSTANCE_LEVEL_COUNT</code>; it can be configured at compile-time using the constant <code>EMBREE_MAX_INSTANCE_LEVEL_COUNT</code>. Users should adapt this constant to their needs: instances nested any deeper are silently ignored in release mode, and cause assertions in debug mode.</p>
<p>Instances are created by passing <code>RTC_GEOMETRY_TYPE_INSTANCE</code> to the <code>rtcNewGeometry</code> function call. The instanced scene can be set using the <code>rtcSetGeometryInstancedScene</code> call, and the affine transformation can be set using the <code>rtcSetGeometryTransform</code> function.</p>
<p>Please note that <code>rtcCommitScene</code> on the instanced scene should be called first, followed by <code>rtcCommitGeometry</code> on the instance, followed by <code>rtcCommitScene</code> for the top-level scene containing the instance.</p>
<p>If a ray hits the instance, the <code>geomID</code> and <code>primID</code> members of the hit are set to the geometry ID and primitive ID of the hit primitive in the instanced scene, and the <code>instID</code> member of the hit is set to the geometry ID of the instance in the top-level scene.</p>
<p>The instancing scheme can also be implemented using user geometries. To achieve this, the user geometry code should set the <code>instID</code> member of the intersection context to the geometry ID of the instance, then trace the transformed ray, and finally set the <code>instID</code> field of the intersection context again to -1. The <code>instID</code> field is copied automatically by each primitive intersector into the <code>instID</code> field of the hit structure when the primitive is hit. See the <a href="tutorials.html#user-geometry">User Geometry</a> tutorial for an example.</p>
<p>For multi-segment motion blur, the number of time steps must be first specified using the <code>rtcSetGeometryTimeStepCount</code> function. Then a transformation for each time step can be specified using the <code>rtcSetGeometryTransform</code> function.</p>
<p>See tutorials <a href="tutorials.html#instanced-geometry">Instanced Geometry</a> and <a href="tutorials.html#multi-level-instancing">Multi Level Instancing</a> for examples of how to use instances.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcsetgeometryinstancedscene">rtcSetGeometryInstancedScene</a>, <a href="#rtcsetgeometrytransform">rtcSetGeometryTransform</a></p>
<p></p>
<h2 id="rtccurveflags">RTCCurveFlags</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCCurveFlags - per segment flags <span class="kw">for</span> curve geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span></code></pre></div>
<p>enum RTCCurveFlags { RTC_CURVE_FLAG_NEIGHBOR_LEFT = (1 &lt;&lt; 0), RTC_CURVE_FLAG_NEIGHBOR_RIGHT = (1 &lt;&lt; 1) };</p>
<h4 id="description">DESCRIPTION</h4>
<p>The RTCCurveFlags type is used for linear curves to determine if the left and/or right neighbor segment exist. Therefore one attached a buffer of type RTC_BUFFER_TYPE_FLAGS to the curve geometry which stores an individual byte per curve segment.</p>
<p>If the RTC_CURVE_FLAG_NEIGHBOR_LEFT flag in that byte is enabled for a curve segment, then the left segment exists (which starts one vertex before the start vertex of the current curve) and the current segment is rendered to properly attach to that segment.</p>
<p>If the RTC_CURVE_FLAG_NEIGHBOR_RIGHT flag in that byte is enabled for a curve segment, then the right segment exists (which ends one vertex after the end vertex of the current curve) and the current segment is rendered to properly attach to that segment.</p>
<p>When not properly specifying left and right flags for linear curves, the rendering at the ending of these curves may not look correct, in particular when round linear curves are viewed from the inside.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_curve">RTC_GEOMETRY_TYPE_CURVE</a></p>
<p></p>
<h2 id="rtcretaingeometry">rtcRetainGeometry</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainGeometry - increments the geometry reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainGeometry(RTCGeometry geometry);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Geometry objects are reference counted. The <code>rtcRetainGeometry</code> function increments the reference count of the passed geometry object (<code>geometry</code> argument). This function together with <code>rtcReleaseGeometry</code> allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcreleasegeometry">rtcReleaseGeometry</a></p>
<p></p>
<h2 id="rtcreleasegeometry">rtcReleaseGeometry</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseGeometry - decrements the geometry reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseGeometry(RTCGeometry geometry);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Geometry objects are reference counted. The <code>rtcReleaseGeometry</code> function decrements the reference count of the passed geometry object (<code>geometry</code> argument). When the reference count falls to 0, the geometry gets destroyed.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcretaingeometry">rtcRetainGeometry</a></p>
<p></p>
<h2 id="rtccommitgeometry">rtcCommitGeometry</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcCommitGeometry - commits geometry changes</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcCommitGeometry(RTCGeometry geometry);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcCommitGeometry</code> function is used to commit all geometry changes performed to a geometry (<code>geometry</code> parameter). After a geometry gets modified, this function must be called to properly update the internal state of the geometry to perform interpolations using <code>rtcInterpolate</code> or to commit a scene containing the geometry using <code>rtcCommitScene</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcinterpolate">rtcInterpolate</a>, <a href="#rtccommitscene">rtcCommitScene</a></p>
<p></p>
<h2 id="rtcenablegeometry">rtcEnableGeometry</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcEnableGeometry - enables the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcEnableGeometry(RTCGeometry geometry);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcEnableGeometry</code> function enables the specified geometry (<code>geometry</code> argument). Only enabled geometries are rendered. Each geometry is enabled by default at construction time.</p>
<p>After enabling a geometry, the scene containing that geometry must be committed using <code>rtcCommitScene</code> for the change to have effect.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcdisablegeometry">rtcDisableGeometry</a>, <a href="#rtccommitscene">rtcCommitScene</a></p>
<p></p>
<h2 id="rtcdisablegeometry">rtcDisableGeometry</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcDisableGeometry - disables the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcDisableGeometry(RTCGeometry geometry);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcDisableGeometry</code> function disables the specified geometry (<code>geometry</code> argument). A disabled geometry is not rendered. Each geometry is enabled by default at construction time.</p>
<p>After disabling a geometry, the scene containing that geometry must be committed using <code>rtcCommitScene</code> for the change to have effect.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcenablegeometry">rtcEnableGeometry</a>, <a href="#rtccommitscene">rtcCommitScene</a></p>
<p></p>
<h2 id="rtcsetgeometrytimestepcount">rtcSetGeometryTimeStepCount</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTimeStepCount - sets the number of time steps of the
  geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTimeStepCount(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> timeStepCount
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTimeStepCount</code> function sets the number of time steps for multi-segment motion blur (<code>timeStepCount</code> parameter) of the specified geometry (<code>geometry</code> parameter).</p>
<p>For triangle meshes (<code>RTC_GEOMETRY_TYPE_TRIANGLE</code>), quad meshes (<code>RTC_GEOMETRY_TYPE_QUAD</code>), curves (<code>RTC_GEOMETRY_TYPE_CURVE</code>), points (<code>RTC_GEOMETRY_TYPE_POINT</code>), and subdivision geometries (<code>RTC_GEOMETRY_TYPE_SUBDIVISION</code>), the number of time steps directly corresponds to the number of vertex buffer slots available (<code>RTC_BUFFER_TYPE_VERTEX</code> buffer type). For these geometries, one vertex buffer per time step must be specified when creating multi-segment motion blur geometries.</p>
<p>For instance geometries (<code>RTC_GEOMETRY_TYPE_INSTANCE</code>), a transformation must be specified for each time step (see <code>rtcSetGeometryTransform</code>).</p>
<p>For user geometries, the registered bounding callback function must provide a bounding box per primitive and time step, and the intersection and occlusion callback functions should properly intersect the motion-blurred geometry at the ray time.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtcsetgeometrytimerange">rtcSetGeometryTimeRange</a></p>
<p></p>
<h2 id="rtcsetgeometrytimerange">rtcSetGeometryTimeRange</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTimeRange - sets the time range <span class="kw">for</span> a motion blur geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTimeRange(
  RTCGeometry geometry,
  <span class="dt">float</span> startTime,
  <span class="dt">float</span> endTime
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTimeRange</code> function sets a time range which defines the start (and end time) of the first (and last) time step of a motion blur geometry. The time range is defined relative to the camera shutter interval [0,1] but it can be arbitrary. Thus the startTime can be smaller, equal, or larger 0, indicating a geometry whose animation definition start before, at, or after the camera shutter opens. Similar the endTime can be smaller, equal, or larger than 1, indicating a geometry whose animation definition ends after, at, or before the camera shutter closes. The startTime has to be smaller or equal to the endTime.</p>
<p>The default time range when this function is not called is the entire camera shutter [0,1]. For best performance at most one time segment of the piece wise linear definition of the motion should fall outside the shutter window to the left and to the right. Thus do not set the startTime or endTime too far outside the [0,1] interval for best performance.</p>
<p>This time range feature will also allow geometries to appear and disappear during the camera shutter time if the specified time range is a sub range of [0,1].</p>
<p>Please also have a look at the <code>rtcSetGeometryTimeStepCount</code> function to see how to define the time steps for the specified time range.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrytimestepcount">rtcSetGeometryTimeStepCount</a></p>
<p></p>
<h2 id="rtcsetgeometryvertexattributecount">rtcSetGeometryVertexAttributeCount</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryVertexAttributeCount - sets the number of vertex
  attributes of the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryVertexAttributeCount(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> vertexAttributeCount
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryVertexAttributeCount</code> function sets the number of slots (<code>vertexAttributeCount</code> parameter) for vertex attribute buffers (<code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>) that can be used for the specified geometry (<code>geometry</code> parameter).</p>
<p>This function is supported only for triangle meshes (<code>RTC_GEOMETRY_TYPE_TRIANGLE</code>), quad meshes (<code>RTC_GEOMETRY_TYPE_QUAD</code>), curves (<code>RTC_GEOMETRY_TYPE_CURVE</code>), points (<code>RTC_GEOMETRY_TYPE_POINT</code>), and subdivision geometries (<code>RTC_GEOMETRY_TYPE_SUBDIVISION</code>).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, [RTCBufferType]</p>
<p></p>
<h2 id="rtcsetgeometrymask">rtcSetGeometryMask</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryMask - sets the geometry mask</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryMask(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> mask
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryMask</code> function sets a 32-bit geometry mask (<code>mask</code> argument) for the specified geometry (<code>geometry</code> argument).</p>
<p>This geometry mask is used together with the ray mask stored inside the <code>mask</code> field of the ray. The primitives of the geometry are hit by the ray only if the bitwise <code>and</code> operation of the geometry mask with the ray mask is not 0. This feature can be used to disable selected geometries for specifically tagged rays, e.g. to disable shadow casting for certain geometries.</p>
<p>Ray masks are disabled in Embree by default at compile time, and can be enabled through the <code>EMBREE_RAY_MASK</code> parameter in CMake. One can query whether ray masks are enabled by querying the <code>RTC_DEVICE_PROPERTY_RAY_MASK_SUPPORTED</code> device property using <code>rtcGetDeviceProperty</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcray">RTCRay</a>, <a href="#rtcgetdeviceproperty">rtcGetDeviceProperty</a></p>
<p></p>
<h2 id="rtcsetgeometrybuildquality">rtcSetGeometryBuildQuality</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryBuildQuality - sets the build quality <span class="kw">for</span> the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryBuildQuality(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBuildQuality quality
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryBuildQuality</code> function sets the build quality (<code>quality</code> argument) for the specified geometry (<code>geometry</code> argument). The per-geometry build quality is only a hint and may be ignored. Embree currently uses the per-geometry build quality when the scene build quality is set to <code>RTC_BUILD_QUALITY_LOW</code>. In this mode a two-level acceleration structure is build, and geometries build a separate acceleration structure using the geometry build quality. The per-geometry build quality can be one of:</p>
<ul>
<li><p><code>RTC_BUILD_QUALITY_LOW</code>: Creates lower quality data structures, e.g. for dynamic scenes.</p></li>
<li><p><code>RTC_BUILD_QUALITY_MEDIUM</code>: Default build quality for most usages. Gives a good compromise between build and render performance.</p></li>
<li><p><code>RTC_BUILD_QUALITY_HIGH</code>: Creates higher quality data structures for final-frame rendering. Enables a spatial split builder for certain primitive types.</p></li>
<li><p><code>RTC_BUILD_QUALITY_REFIT</code>: Uses a BVH refitting approach when changing only the vertex buffer.</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetscenebuildquality">rtcSetSceneBuildQuality</a></p>
<p></p>
<h2 id="rtcsetgeometrybuffer">rtcSetGeometryBuffer</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryBuffer - assigns a view of a buffer to the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryBuffer(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot,
  <span class="kw">enum</span> RTCFormat format,
  RTCBuffer buffer,
  size_t byteOffset,
  size_t byteStride,
  size_t itemCount
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryBuffer</code> function binds a view of a buffer object (<code>buffer</code> argument) to a geometry buffer type and slot (<code>type</code> and <code>slot</code> argument) of the specified geometry (<code>geometry</code> argument).</p>
<p>One can specify the start of the first buffer element in bytes (<code>byteOffset</code> argument), the byte stride between individual buffer elements (<code>byteStride</code> argument), the format of the buffer elements (<code>format</code> argument), and the number of elements to bind (<code>itemCount</code>).</p>
<p>The start address (<code>byteOffset</code> argument) and stride (<code>byteStride</code> argument) must be both aligned to 4 bytes, otherwise the <code>rtcSetGeometryBuffer</code> function will fail.</p>
<p>After successful completion of this function, the geometry will hold a reference to the buffer object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetsharedgeometrybuffer">rtcSetSharedGeometryBuffer</a>, <a href="#rtcsetnewgeometrybuffer">rtcSetNewGeometryBuffer</a></p>
<p></p>
<h2 id="rtcsetsharedgeometrybuffer">rtcSetSharedGeometryBuffer</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetSharedGeometryBuffer - assigns a view of a shared data buffer
  to a geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetSharedGeometryBuffer(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot,
  <span class="kw">enum</span> RTCFormat format,
  <span class="dt">const</span> <span class="dt">void</span>* ptr,
  size_t byteOffset,
  size_t byteStride,
  size_t itemCount
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetSharedGeometryBuffer</code> function binds a view of a shared user-managed data buffer (<code>ptr</code> argument) to a geometry buffer type and slot (<code>type</code> and <code>slot</code> argument) of the specified geometry (<code>geometry</code> argument).</p>
<p>One can specify the start of the first buffer element in bytes (<code>byteOffset</code> argument), the byte stride between individual buffer elements (<code>byteStride</code> argument), the format of the buffer elements (<code>format</code> argument), and the number of elements to bind (<code>itemCount</code>).</p>
<p>The start address (<code>byteOffset</code> argument) and stride (<code>byteStride</code> argument) must be both aligned to 4 bytes; otherwise the <code>rtcSetGeometryBuffer</code> function will fail.</p>
<p>When the buffer will be used as a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> and <code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>), the last buffer element must be readable using 16-byte SSE load instructions, thus padding the last element is required for certain layouts. E.g. a standard <code>float3</code> vertex buffer layout should add storage for at least one more float to the end of the buffer.</p>
<p>The buffer data must remain valid for as long as the buffer may be used, and the user is responsible for freeing the buffer data when no longer required.</p>
<p>Sharing buffers can significantly reduce the memory required by the application, thus we recommend using this feature. When enabling the <code>RTC_SCENE_COMPACT</code> scene flag, the spatial index structures index into the vertex buffer, resulting in even higher memory savings.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrybuffer">rtcSetGeometryBuffer</a>, <a href="#rtcsetnewgeometrybuffer">rtcSetNewGeometryBuffer</a></p>
<p></p>
<h2 id="rtcsetnewgeometrybuffer">rtcSetNewGeometryBuffer</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetNewGeometryBuffer - creates <span class="kw">and</span> assigns a <span class="kw">new</span> data buffer to
  the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span>* rtcSetNewGeometryBuffer(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot,
  <span class="kw">enum</span> RTCFormat format,
  size_t byteStride,
  size_t itemCount
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetNewGeometryBuffer</code> function creates a new data buffer of specified format (<code>format</code> argument), byte stride (<code>byteStride</code> argument), and number of items (<code>itemCount</code> argument), and assigns it to a geometry buffer slot (<code>type</code> and <code>slot</code> argument) of the specified geometry (<code>geometry</code> argument). The buffer data is managed internally and automatically freed when the geometry is destroyed.</p>
<p>The byte stride (<code>byteStride</code> argument) must be aligned to 4 bytes; otherwise the <code>rtcSetNewGeometryBuffer</code> function will fail.</p>
<p>The allocated buffer will be automatically over-allocated slightly when used as a vertex buffer, where a requirement is that each buffer element should be readable using 16-byte SSE load instructions.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrybuffer">rtcSetGeometryBuffer</a>, <a href="#rtcsetsharedgeometrybuffer">rtcSetSharedGeometryBuffer</a></p>
<p></p>
<h2 id="rtcgetgeometrybufferdata">rtcGetGeometryBufferData</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryBufferData - gets pointer to
  the first buffer view element</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span>* rtcGetGeometryBufferData(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryBufferData</code> function returns a pointer to the first element of the buffer view attached to the specified buffer type and slot (<code>type</code> and <code>slot</code> argument) of the geometry (<code>geometry</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrybuffer">rtcSetGeometryBuffer</a>, <a href="#rtcsetsharedgeometrybuffer">rtcSetSharedGeometryBuffer</a>, <a href="#rtcsetnewgeometrybuffer">rtcSetNewGeometryBuffer</a></p>
<p></p>
<h2 id="rtcupdategeometrybuffer">rtcUpdateGeometryBuffer</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcUpdateGeometryBuffer - marks a buffer view bound to the geometry
  as modified</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcUpdateGeometryBuffer(
  RTCGeometry geometry,
  <span class="kw">enum</span> RTCBufferType type,
  <span class="dt">unsigned</span> <span class="dt">int</span> slot
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcUpdateGeometryBuffer</code> function marks the buffer view bound to the specified buffer type and slot (<code>type</code> and <code>slot</code> argument) of a geometry (<code>geometry</code> argument) as modified.</p>
<p>If a data buffer is changed by the application, the <code>rtcUpdateGeometryBuffer</code> call must be invoked for that buffer. Each buffer view assigned to a buffer slot is initially marked as modified, thus this function needs to be called only when doing buffer modifications after the first <code>rtcCommitScene</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewgeometry">rtcNewGeometry</a>, <a href="#rtccommitscene">rtcCommitScene</a></p>
<p></p>
<h2 id="rtcsetgeometryintersectfilterfunction">rtcSetGeometryIntersectFilterFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryIntersectFilterFunction - sets the intersection filter
  <span class="kw">for</span> the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCFilterFunctionNArguments
{
  <span class="dt">int</span>* valid;
  <span class="dt">void</span>* geometryUserPtr;
  <span class="dt">const</span> <span class="kw">struct</span> RTCIntersectContext* context;
  <span class="kw">struct</span> RTCRayN* ray;
  <span class="kw">struct</span> RTCHitN* hit;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCFilterFunctionN)(
  <span class="dt">const</span> <span class="kw">struct</span> RTCFilterFunctionNArguments* args
);

<span class="dt">void</span> rtcSetGeometryIntersectFilterFunction(
  RTCGeometry geometry,
  RTCFilterFunctionN filter
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryIntersectFilterFunction</code> function registers an intersection filter callback function (<code>filter</code> argument) for the specified geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered intersection filter function is invoked for every hit encountered during the <code>rtcIntersect</code>-type ray queries and can accept or reject that hit. The feature can be used to define a silhouette for a primitive and reject hits that are outside the silhouette. E.g. a tree leaf could be modeled with an alpha texture that decides whether hit points lie inside or outside the leaf.</p>
<p>If the <code>RTC_BUILD_QUALITY_HIGH</code> mode is set, the filter functions may be called multiple times for the same primitive hit. Further, rays hitting exactly the edge might also report two hits for the same surface. For certain use cases, the application may have to work around this limitation by collecting already reported hits (<code>geomID</code>/<code>primID</code> pairs) and ignoring duplicates.</p>
<p>The filter function callback of type <code>RTCFilterFunctionN</code> gets passed a number of arguments through the <code>RTCFilterFunctionNArguments</code> structure. The <code>valid</code> parameter of that structure points to an integer valid mask (0 means invalid and -1 means valid). The <code>geometryUserPtr</code> member is a user pointer optionally set per geometry through the <code>rtcSetGeometryUserData</code> function. The <code>context</code> member points to the intersection context passed to the ray query function. The <code>ray</code> parameter points to <code>N</code> rays in SOA layout. The <code>hit</code> parameter points to <code>N</code> hits in SOA layout to test. The <code>N</code> parameter is the number of rays and hits in <code>ray</code> and <code>hit</code>. The hit distance is provided as the <code>tfar</code> value of the ray. If the hit geometry is instanced, the <code>instID</code> member of the ray is valid, and the ray and the potential hit are in object space.</p>
<p>The filter callback function has the task to check for each valid ray whether it wants to accept or reject the corresponding hit. To reject a hit, the filter callback function just has to write <code>0</code> to the integer valid mask of the corresponding ray. To accept the hit, it just has to leave the valid mask set to <code>-1</code>. The filter function is further allowed to change the hit and decrease the <code>tfar</code> value of the ray but it should not modify other ray data nor any inactive components of the ray or hit.</p>
<p>When performing ray queries using <code>rtcIntersect1</code>, it is guaranteed that the packet size is 1 when the callback is invoked. When performing ray queries using the <code>rtcIntersect4/8/16</code> functions, it is not generally guaranteed that the ray packet size (and order of rays inside the packet) passed to the callback matches the initial ray packet. However, under some circumstances these properties are guaranteed, and whether this is the case can be queried using <code>rtcGetDeviceProperty</code>. When performing ray queries using the stream API such as <code>rtcIntersect1M</code>, <code>rtcIntersect1Mp</code>, <code>rtcIntersectNM</code>, or <code>rtcIntersectNp</code> the order of rays and ray packet size of the callback function might change to either 1, 4, 8, or 16.</p>
<p>For many usage scenarios, repacking and re-ordering of rays does not cause difficulties in implementing the callback function. However, algorithms that need to extend the ray with additional data must use the <code>rayID</code> component of the ray to identify the original ray to access the per-ray data.</p>
<p>The implementation of the filter function can choose to implement a single code path that uses the ray access helper functions <code>RTCRay_XXX</code> and hit access helper functions <code>RTCHit_XXX</code> to access ray and hit data. Alternatively the code can branch to optimized implementations for specific sizes of <code>N</code> and cast the <code>ray</code> and <code>hit</code> inputs to the proper packet types.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryoccludedfilterfunction">rtcSetGeometryOccludedFilterFunction</a></p>
<p></p>
<h2 id="rtcsetgeometryoccludedfilterfunction">rtcSetGeometryOccludedFilterFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryOccludedFilterFunction - sets the occlusion filter
  <span class="kw">for</span> the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryOccludedFilterFunction(
  RTCGeometry geometry,
  RTCFilterFunctionN filter
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryOccludedFilterFunction</code> function registers an occlusion filter callback function (<code>filter</code> argument) for the specified geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered intersection filter function is invoked for every hit encountered during the <code>rtcOccluded</code>-type ray queries and can accept or reject that hit. The feature can be used to define a silhouette for a primitive and reject hits that are outside the silhouette. E.g. a tree leaf could be modeled with an alpha texture that decides whether hit points lie inside or outside the leaf.</p>
<p>Please see the description of the <code>rtcSetGeometryIntersectFilterFunction</code> for a description of the filter callback function.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryintersectfilterfunction">rtcSetGeometryIntersectFilterFunction</a></p>
<p></p>
<h2 id="rtcfilterintersection">rtcFilterIntersection</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcFilterIntersection - invokes the intersection filter function</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcFilterIntersection(
  <span class="dt">const</span> <span class="kw">struct</span> RTCIntersectFunctionNArguments* args,
  <span class="dt">const</span> <span class="kw">struct</span> RTCFilterFunctionNArguments* filterArgs
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcFilterIntersection</code> function can be called inside an <code>RTCIntersectFunctionN</code> callback function to invoke the intersection filter registered to the geometry and stored inside the context. For this an <code>RTCFilterFunctionNArguments</code> structure must be created (see <code>rtcSetGeometryIntersectFilterFunction</code>) which basically consists of a valid mask, a hit packet to filter, the corresponding ray packet, and the packet size. After the invocation of <code>rtcFilterIntersection</code>, only rays that are still valid (valid mask set to -1) should update a hit.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcfilterocclusion">rtcFilterOcclusion</a>, <a href="#rtcsetgeometryintersectfunction">rtcSetGeometryIntersectFunction</a></p>
<p></p>
<h2 id="rtcfilterocclusion">rtcFilterOcclusion</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcFilterOcclusion - invokes the occlusion filter function</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcFilterOcclusion(
  <span class="dt">const</span> <span class="kw">struct</span> RTCOccludedFunctionNArguments* args,
  <span class="dt">const</span> <span class="kw">struct</span> RTCFilterFunctionNArguments* filterArgs
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcFilterOcclusion</code> function can be called inside an <code>RTCOccludedFunctionN</code> callback function to invoke the occlusion filter registered to the geometry and stored inside the context. For this an <code>RTCFilterFunctionNArguments</code> structure must be created (see <code>rtcSetGeometryIntersectFilterFunction</code>) which basically consists of a valid mask, a hit packet to filter, the corresponding ray packet, and the packet size. After the invocation of <code>rtcFilterOcclusion</code> only rays that are still valid (valid mask set to -1) should signal an occlusion.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcfilterintersection">rtcFilterIntersection</a>, <a href="#rtcsetgeometryoccludedfunction">rtcSetGeometryOccludedFunction</a></p>
<p></p>
<h2 id="rtcsetgeometryuserdata">rtcSetGeometryUserData</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryUserData - sets the user-defined data pointer of the
  geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryUserData(RTCGeometry geometry, <span class="dt">void</span>* userPtr);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryUserData</code> function sets the user-defined data pointer (<code>userPtr</code> argument) for a geometry (<code>geometry</code> argument). This user data pointer is intended to be pointing to the application's representation of the geometry, and is passed to various callback functions. The application can use this pointer inside the callback functions to access its geometry representation.</p>
<p>The <code>rtcGetGeometryUserData</code> function can be used to query an already set user data pointer of a geometry.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetgeometryuserdata">rtcGetGeometryUserData</a></p>
<p></p>
<h2 id="rtcgetgeometryuserdata">rtcGetGeometryUserData</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryUserData - returns the user data pointer
  of the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span>* rtcGetGeometryUserData(RTCGeometry geometry);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryUserData</code> function queries the user data pointer previously set with <code>rtcSetGeometryUserData</code>. When <code>rtcSetGeometryUserData</code> was not called yet, <code>NULL</code> is returned.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a></p>
<p></p>
<h2 id="rtcsetgeometryuserprimitivecount">rtcSetGeometryUserPrimitiveCount</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryUserPrimitiveCount - sets the number of primitives
  of a user-defined geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryUserPrimitiveCount(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> userPrimitiveCount
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryUserPrimitiveCount</code> function sets the number of user-defined primitives (<code>userPrimitiveCount</code> parameter) of the specified user-defined geometry (<code>geometry</code> parameter).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_user">RTC_GEOMETRY_TYPE_USER</a></p>
<p></p>
<h2 id="rtcsetgeometryboundsfunction">rtcSetGeometryBoundsFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryBoundsFunction - sets a callback to query the
  bounding box of user-defined primitives</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCBoundsFunctionArguments
{
  <span class="dt">void</span>* geometryUserPtr;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="dt">unsigned</span> <span class="dt">int</span> timeStep;
  <span class="kw">struct</span> RTCBounds* bounds_o;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCBoundsFunction)(
  <span class="dt">const</span> <span class="kw">struct</span> RTCBoundsFunctionArguments* args
);

<span class="dt">void</span> rtcSetGeometryBoundsFunction(
  RTCGeometry geometry,
  RTCBoundsFunction bounds,
  <span class="dt">void</span>* userPtr
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryBoundsFunction</code> function registers a bounding box callback function (<code>bounds</code> argument) with payload (<code>userPtr</code> argument) for the specified user geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered bounding box callback function is invoked to calculate axis-aligned bounding boxes of the primitives of the user-defined geometry during spatial acceleration structure construction. The bounding box callback of <code>RTCBoundsFunction</code> type is invoked with a pointer to a structure of type <code>RTCBoundsFunctionArguments</code> which contains various arguments, such as: the user data of the geometry (<code>geometryUserPtr</code> member), the ID of the primitive to calculate the bounds for (<code>primID</code> member), the time step at which to calculate the bounds (<code>timeStep</code> member), and a memory location to write the calculated bound to (<code>bounds_o</code> member).</p>
<p>In a typical usage scenario one would store a pointer to the internal representation of the user geometry object using <code>rtcSetGeometryUserData</code>. The callback function can then read that pointer from the <code>geometryUserPtr</code> field and calculate the proper bounding box for the requested primitive and time, and store that bounding box to the destination structure (<code>bounds_o</code> member).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_user">RTC_GEOMETRY_TYPE_USER</a></p>
<p></p>
<h2 id="rtcsetgeometryintersectfunction">rtcSetGeometryIntersectFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryIntersectFunction - sets the callback function to
  intersect a user geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCIntersectFunctionNArguments
{
  <span class="dt">int</span>* valid;
  <span class="dt">void</span>* geometryUserPtr;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="kw">struct</span> RTCIntersectContext* context;
  <span class="kw">struct</span> RTCRayHitN* rayhit;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCIntersectFunctionN)(
  <span class="dt">const</span> <span class="kw">struct</span> RTCIntersectFunctionNArguments* args
);

<span class="dt">void</span> rtcSetGeometryIntersectFunction(
  RTCGeometry geometry,
  RTCIntersectFunctionN intersect
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryIntersectFunction</code> function registers a ray/primitive intersection callback function (<code>intersect</code> argument) for the specified user geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered callback function is invoked by <code>rtcIntersect</code>-type ray queries to calculate the intersection of a ray packet of variable size with one user-defined primitive. The callback function of type <code>RTCIntersectFunctionN</code> gets passed a number of arguments through the <code>RTCIntersectFunctionNArguments</code> structure. The value <code>N</code> specifies the ray packet size, <code>valid</code> points to an array of integers that specify whether the corresponding ray is valid (-1) or invalid (0), the <code>geometryUserPtr</code> member points to the geometry user data previously set through <code>rtcSetGeometryUserData</code>, the <code>context</code> member points to the intersection context passed to the ray query, the <code>rayhit</code> member points to a ray and hit packet of variable size <code>N</code>, and the <code>geomID</code> and <code>primID</code> member identifies the geometry ID and primitive ID of the primitive to intersect.</p>
<p>The <code>ray</code> component of the <code>rayhit</code> structure contains valid data, in particular the <code>tfar</code> value is the current closest hit distance found. All data inside the <code>hit</code> component of the <code>rayhit</code> structure are undefined and should not be read by the function.</p>
<p>The task of the callback function is to intersect each active ray from the ray packet with the specified user primitive. If the user-defined primitive is missed by a ray of the ray packet, the function should return without modifying the ray or hit. If an intersection of the user-defined primitive with the ray was found in the valid range (from <code>tnear</code> to <code>tfar</code>), it should update the hit distance of the ray (<code>tfar</code> member) and the hit (<code>u</code>, <code>v</code>, <code>Ng</code>, <code>instID</code>, <code>geomID</code>, <code>primID</code> members). In particular, the currently intersected instance is stored in the <code>instID</code> field of the intersection context, which must be deep copied into the <code>instID</code> member of the hit.</p>
<p>As a primitive might have multiple intersections with a ray, the intersection filter function needs to be invoked by the user geometry intersection callback for each encountered intersection, if filtering of intersections is desired. This can be achieved through the <code>rtcFilterIntersection</code> call.</p>
<p>Within the user geometry intersect function, it is safe to trace new rays and create new scenes and geometries.</p>
<p>When performing ray queries using <code>rtcIntersect1</code>, it is guaranteed that the packet size is 1 when the callback is invoked. When performing ray queries using the <code>rtcIntersect4/8/16</code> functions, it is not generally guaranteed that the ray packet size (and order of rays inside the packet) passed to the callback matches the initial ray packet. However, under some circumstances these properties are guaranteed, and whether this is the case can be queried using <code>rtcGetDeviceProperty</code>. When performing ray queries using the stream API such as <code>rtcIntersect1M</code>, <code>rtcIntersect1Mp</code>, <code>rtcIntersectNM</code>, or <code>rtcIntersectNp</code> the order of rays and ray packet size of the callback function might change to either 1, 4, 8, or 16.</p>
<p>For many usage scenarios, repacking and re-ordering of rays does not cause difficulties in implementing the callback function. However, algorithms that need to extend the ray with additional data must use the <code>rayID</code> component of the ray to identify the original ray to access the per-ray data.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryoccludedfunction">rtcSetGeometryOccludedFunction</a>, <a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcfilterintersection">rtcFilterIntersection</a></p>
<p></p>
<h2 id="rtcsetgeometryoccludedfunction">rtcSetGeometryOccludedFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryOccludedFunction - sets the callback function to
  test a user geometry <span class="kw">for</span> occlusion</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCOccludedFunctionNArguments
{
  <span class="dt">int</span>* valid;
  <span class="dt">void</span>* geometryUserPtr;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="kw">struct</span> RTCIntersectContext* context;
  <span class="kw">struct</span> RTCRayN* ray;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCOccludedFunctionN)(
  <span class="dt">const</span> <span class="kw">struct</span> RTCOccludedFunctionNArguments* args
);

<span class="dt">void</span> rtcSetGeometryOccludedFunction(
  RTCGeometry geometry,
  RTCOccludedFunctionN filter
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryOccludedFunction</code> function registers a ray/primitive occlusion callback function (<code>filter</code> argument) for the specified user geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered callback function is invoked by <code>rtcOccluded</code>-type ray queries to test whether the rays of a packet of variable size are occluded by a user-defined primitive. The callback function of type <code>RTCOccludedFunctionN</code> gets passed a number of arguments through the <code>RTCOccludedFunctionNArguments</code> structure. The value <code>N</code> specifies the ray packet size, <code>valid</code> points to an array of integers which specify whether the corresponding ray is valid (-1) or invalid (0), the <code>geometryUserPtr</code> member points to the geometry user data previously set through <code>rtcSetGeometryUserData</code>, the <code>context</code> member points to the intersection context passed to the ray query, the <code>ray</code> member points to a ray packet of variable size <code>N</code>, and the <code>geomID</code> and <code>primID</code> member identifies the geometry ID and primitive ID of the primitive to intersect.</p>
<p>The task of the callback function is to intersect each active ray from the ray packet with the specified user primitive. If the user-defined primitive is missed by a ray of the ray packet, the function should return without modifying the ray. If an intersection of the user-defined primitive with the ray was found in the valid range (from <code>tnear</code> to <code>tfar</code>), it should set the <code>tfar</code> member of the ray to <code>-inf</code>.</p>
<p>As a primitive might have multiple intersections with a ray, the occlusion filter function needs to be invoked by the user geometry occlusion callback for each encountered intersection, if filtering of intersections is desired. This can be achieved through the <code>rtcFilterOcclusion</code> call.</p>
<p>Within the user geometry occlusion function, it is safe to trace new rays and create new scenes and geometries.</p>
<p>When performing ray queries using <code>rtcOccluded1</code>, it is guaranteed that the packet size is 1 when the callback is invoked. When performing ray queries using the <code>rtcOccluded4/8/16</code> functions, it is not generally guaranteed that the ray packet size (and order of rays inside the packet) passed to the callback matches the initial ray packet. However, under some circumstances these properties are guaranteed, and whether this is the case can be queried using <code>rtcGetDeviceProperty</code>. When performing ray queries using the stream API such as <code>rtcOccluded1M</code>, <code>rtcOccluded1Mp</code>, <code>rtcOccludedNM</code>, or <code>rtcOccludedNp</code> the order of rays and ray packet size of the callback function might change to either 1, 4, 8, or 16.</p>
<p>For many usage scenarios, repacking and re-ordering of rays does not cause difficulties in implementing the callback function. However, algorithms that need to extend the ray with additional data must use the <code>rayID</code> component of the ray to identify the original ray to access the per-ray data.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometryintersectfunction">rtcSetGeometryIntersectFunction</a>, <a href="#rtcsetgeometryuserdata">rtcSetGeometryUserData</a>, <a href="#rtcfilterocclusion">rtcFilterOcclusion</a></p>
<p></p>
<h2 id="rtcsetgeometrypointqueryfunction">rtcSetGeometryPointQueryFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryPointQueryFunction - sets the point query callback function
  <span class="kw">for</span> a geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCPointQueryFunctionArguments
{
  <span class="co">// the (world space) query object that was passed as an argument of rtcPointQuery.</span>
  <span class="kw">struct</span> RTCPointQuery* query;

  <span class="co">// used for user input/output data. Will not be read or modified internally.</span>
  <span class="dt">void</span>* userPtr;

  <span class="co">// primitive and geometry ID of primitive</span>
  <span class="dt">unsigned</span> <span class="dt">int</span>  primID;        
  <span class="dt">unsigned</span> <span class="dt">int</span>  geomID;    

  <span class="co">// the context with transformation and instance ID stack</span>
  <span class="kw">struct</span> RTCPointQueryContext* context;

  <span class="co">// scaling factor indicating whether the current instance transformation</span>
  <span class="co">// is a similarity transformation.</span>
  <span class="dt">float</span> similarityScale;
};

<span class="kw">typedef</span> <span class="dt">bool</span> (*RTCPointQueryFunction)(
  <span class="kw">struct</span> RTCPointQueryFunctionArguments* args
);

<span class="dt">void</span> rtcSetGeometryPointQueryFunction(
  RTCGeometry geometry,
  RTCPointQueryFunction queryFunc
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryPointQueryFunction</code> function registers a point query callback function (<code>queryFunc</code> argument) for the specified geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered callback function is invoked by [rtcPointQuery] for every primitive of the geometry that intersects the corresponding point query domain. The callback function of type <code>RTCPointQueryFunction</code> gets passed a number of arguments through the <code>RTCPointQueryFunctionArguments</code> structure. The <code>query</code> object is the original point query object passed into [rtcPointQuery], <code>usrPtr</code> is an arbitrary pointer to pass input into and store results of the callback function. The <code>primID</code>, <code>geomID</code> and <code>context</code> (see <a href="#rtcinitpointquerycontext">rtcInitPointQueryContext</a> for details) can be used to identify the geometry data of the primitive.</p>
<p>A <code>RTCPointQueryFunction</code> can also be passed directly as an argument to [rtcPointQuery]. In this case the callback is invoked for all primitives in the scene that intersect the query domain. If a callback function is passed as an argument to [rtcPointQuery] and (a potentially different) callback function is set for a geometry with <a href="#rtcsetgeometrypointqueryfunction">rtcSetGeometryPointQueryFunction</a> both callback functions are invoked and the callback function passed to [rtcPointQuery] will be called before the geometry specific callback function.</p>
<p>If instancing is used, the parameter <code>simliarityScale</code> indicates whether the current instance transform (top element of the stack in <code>context</code>) is a similarity transformation or not. Similarity transformations are composed of translation, rotation and uniform scaling and if a matrix M defines a similarity transformation, there is a scaling factor D such that for all x,y: dist(Mx, My) = D * dist(x, y). In this case the parameter <code>scalingFactor</code> is this scaling factor D and otherwise it is 0. A valid similarity scale (<code>similarityScale</code> &gt; 0) allows to compute distance information in instance space and scale the distances into world space (for example, to update the query radius, see below) by dividing the instance space distance with the similarity scale. If the current instance transform is not a similarity transform (<code>similarityScale</code> is 0), the distance computation has to be performed in world space to ensure correctness. In this case the instance to world transformations given with the <code>context</code> should be used to transform the primitive data into world space. Otherwise, the query location can be transformed into instance space which can be more efficient. If there is no instance transform, the similarity scale is 1.</p>
<p>The callback function will potentially be called for primitives outside the query domain for two resons: First, the callback is invoked for all primitives inside a BVH leaf node since no geometry data of primitives is determined internally and therefore individual primitives are not culled (only their (aggregated) bounding boxes). Second, in case non similarity transformations are used, the resulting ellipsoidal query domain (in instance space) is approximated by its axis aligned bounding box internally and therefore inner nodes that do not intersect the original domain might intersect the approximative bounding box which results in unneccessary callbacks. In any case, the callbacks are conservative, i.e. if a primitive is inside the query domain a callback will be invoked but the reverse is not neccessarily true.</p>
<p>For efficiency, the radius of the <code>query</code> object can be decreased (in world space) inside the callback function to improve culling of geometry during BVH traversal. If the query radius was updated, the callback function should return <code>true</code> to issue an update of internal traversal information. Increasing the radius or modifying the time or position of the query results in undefined behaviour.</p>
<p>Within the callback function, it is safe to call [rtcPointQuery] again, for example when implementing instancing manually. In this case the instance transformation should be pushed onto the stack in <code>context</code>. Embree will internally compute the point query information in instance space using the top element of the stack in <code>context</code> when [rtcPointQuery] is called.</p>
<p>For a reference implementation of a closest point traversal of triangle meshes using instancing and user defined instancing see the tutorial [ClosestPoint].</p>
<h4 id="see-also">SEE ALSO</h4>
<p>[rtcPointQuery], <a href="#rtcinitpointquerycontext">rtcInitPointQueryContext</a></p>
<p></p>
<h2 id="rtcsetgeometryinstancedscene">rtcSetGeometryInstancedScene</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryInstancedScene - sets the instanced scene of
  an instance geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryInstancedScene(
  RTCGeometry geometry,
  RTCScene scene
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryInstancedScene</code> function sets the instanced scene (<code>scene</code> argument) of the specified instance geometry (<code>geometry</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</a>, <a href="#rtcsetgeometrytransform">rtcSetGeometryTransform</a></p>
<p></p>
<h2 id="rtcsetgeometrytransform">rtcSetGeometryTransform</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTransform - sets the transformation <span class="kw">for</span> a particular
  time step of an instance geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTransform(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> timeStep,
  <span class="kw">enum</span> RTCFormat format,
  <span class="dt">const</span> <span class="dt">float</span>* xfm
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTransform</code> function sets the local-to-world affine transformation (<code>xfm</code> parameter) of an instance geometry (<code>geometry</code> parameter) for a particular time step (<code>timeStep</code> parameter). The transformation is specified as a 3×4 matrix (3×3 linear transformation plus translation), for which the following formats (<code>format</code> parameter) are supported:</p>
<ul>
<li><p><code>RTC_FORMAT_FLOAT3X4_ROW_MAJOR</code>: The 3×4 float matrix is laid out in row-major form.</p></li>
<li><p><code>RTC_FORMAT_FLOAT3X4_COLUMN_MAJOR</code>: The 3×4 float matrix is laid out in column-major form.</p></li>
<li><p><code>RTC_FORMAT_FLOAT4X4_COLUMN_MAJOR</code>: The 3×4 float matrix is laid out in column-major form as a 4×4 homogeneous matrix with the last row being equal to (0, 0, 0, 1).</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</a></p>
<p></p>
<h2 id="rtcsetgeometrytransformquaternion">rtcSetGeometryTransformQuaternion</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTransformQuaternion - sets the transformation <span class="kw">for</span> a particular
  time step of an instance geometry as a decomposition of the
  transformation matrix <span class="kw">using</span> quaternions to represent the rotation.</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTransformQuaternion(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> timeStep,
  <span class="dt">const</span> <span class="kw">struct</span> RTCQuaternionDecomposition* qd
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTransformQuaternion</code> function sets the local-to-world affine transformation (<code>qd</code> parameter) of an instance geometry (<code>geometry</code> parameter) for a particular time step (<code>timeStep</code> parameter). The transformation is specified as a <a href="#rtcquaterniondecomposition">RTCQuaternionDecomposition</a>, which is a decomposition of an affine transformation that represents the rotational component of an affine transformation as a quaternion. This allows interpolating rotational transformations exactly using spherical linear interpolation (such as a turning wheel).</p>
<p>For more information about the decomposition see <a href="#rtcquaterniondecomposition">RTCQuaternionDecomposition</a>. The quaternion given in the <code>RTCQuaternionDecomposition</code> struct will be normalized internally.</p>
<p>For correct results, the transformation matrices for all time steps must be set either using <code>rtcSetGeometryTransform</code> or <code>rtcSetGeometryTransformQuaternion</code>. Mixing both representations is not allowed. Spherical linear interpolation will be used, iff the transformation matizes are set with <code>rtcSetGeometryTransformQuaternion</code>.</p>
<p>For an example of this feature see the tutorial <a href="tutorials.html#quaternion-motion-blur">Quaternion Motion Blur</a>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcinitquaterniondecomposition">rtcInitQuaternionDecomposition</a>, <a href="#rtcsetgeometrytransform">rtcSetGeometryTransform</a></p>
<p></p>
<h2 id="rtcgetgeometrytransform">rtcGetGeometryTransform</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryTransform - returns the interpolated instance
  transformation <span class="kw">for</span> the specified time</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcGetGeometryTransform(
  RTCGeometry geometry,
  <span class="dt">float</span> time,
  <span class="kw">enum</span> RTCFormat format,
  <span class="dt">void</span>* xfm
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryTransform</code> function returns the interpolated local to world transformation (<code>xfm</code> parameter) of an instance geometry (<code>geometry</code> parameter) for a particular time (<code>time</code> parameter in range <span class="math inline">[0, 1]</span>) in the specified format (<code>format</code> parameter).</p>
<p>Possible formats for the returned matrix are:</p>
<ul>
<li><p><code>RTC_FORMAT_FLOAT3X4_ROW_MAJOR</code>: The 3×4 float matrix is laid out in row-major form.</p></li>
<li><p><code>RTC_FORMAT_FLOAT3X4_COLUMN_MAJOR</code>: The 3×4 float matrix is laid out in column-major form.</p></li>
<li><p><code>RTC_FORMAT_FLOAT4X4_COLUMN_MAJOR</code>: The 3×4 float matrix is laid out in column-major form as a 4×4 homogeneous matrix with last row equal to (0, 0, 0, 1).</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</a>, <a href="#rtcsetgeometrytransform">rtcSetGeometryTransform</a></p>
<p></p>
<h2 id="rtcsetgeometrytessellationrate">rtcSetGeometryTessellationRate</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTessellationRate - sets the tessellation rate of the
  geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTessellationRate(
  RTCGeometry geometry,
  <span class="dt">float</span> tessellationRate
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTessellationRate</code> function sets the tessellation rate (<code>tessellationRate</code> argument) for the specified geometry (<code>geometry</code> argument). The tessellation rate can only be set for flat curves and subdivision geometries. For curves, the tessellation rate specifies the number of ray-facing quads per curve segment. For subdivision surfaces, the tessellation rate specifies the number of quads along each edge.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_curve">RTC_GEOMETRY_TYPE_CURVE</a>, <a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a></p>
<p></p>
<h2 id="rtcsetgeometrytopologycount">rtcSetGeometryTopologyCount</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryTopologyCount - sets the number of topologies of
  a subdivision geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryTopologyCount(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> topologyCount
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryTopologyCount</code> function sets the number of topologies (<code>topologyCount</code> parameter) for the specified subdivision geometry (<code>geometry</code> parameter). The number of topologies of a subdivision geometry must be greater or equal to 1.</p>
<p>To use multiple topologies, first the number of topologies must be specified, then the individual topologies can be configured using <code>rtcSetGeometrySubdivisionMode</code> and by setting an index buffer (<code>RTC_BUFFER_TYPE_INDEX</code>) using the topology ID as the buffer slot.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a>, <a href="#rtcsetgeometrysubdivisionmode">rtcSetGeometrySubdivisionMode</a></p>
<p></p>
<h2 id="rtcsetgeometrysubdivisionmode">rtcSetGeometrySubdivisionMode</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometrySubdivisionMode - sets the subdivision mode
  of a subdivision geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometrySubdivisionMode(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> topologyID,
  <span class="kw">enum</span> RTCSubdivisionMode mode
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometrySubdivisionMode</code> function sets the subdivision mode (<code>mode</code> parameter) for the topology (<code>topologyID</code> parameter) of the specified subdivision geometry (<code>geometry</code> parameter).</p>
<p>The subdivision modes can be used to force linear interpolation for certain parts of the subdivision mesh:</p>
<ul>
<li><p><code>RTC_SUBDIVISION_MODE_NO_BOUNDARY</code>: Boundary patches are ignored. This way each rendered patch has a full set of control vertices.</p></li>
<li><p><code>RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY</code>: The sequence of boundary control points are used to generate a smooth B-spline boundary curve (default mode).</p></li>
<li><p><code>RTC_SUBDIVISION_MODE_PIN_CORNERS</code>: Corner vertices are pinned to their location during subdivision.</p></li>
<li><p><code>RTC_SUBDIVISION_MODE_PIN_BOUNDARY</code>: All vertices at the border are pinned to their location during subdivision. This way the boundary is interpolated linearly. This mode is typically used for texturing to also map texels at the border of the texture to the mesh.</p></li>
<li><p><code>RTC_SUBDIVISION_MODE_PIN_ALL</code>: All vertices at the border are pinned to their location during subdivision. This way all patches are linearly interpolated.</p></li>
</ul>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a></p>
<p></p>
<h2 id="rtcsetgeometryvertexattributetopology">rtcSetGeometryVertexAttributeTopology</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryVertexAttributeTopology - binds a vertex
  attribute to a topology of the geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcSetGeometryVertexAttributeTopology(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> vertexAttributeID,
  <span class="dt">unsigned</span> <span class="dt">int</span> topologyID
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryVertexAttributeTopology</code> function binds a vertex attribute buffer slot (<code>vertexAttributeID</code> argument) to a topology (<code>topologyID</code> argument) for the specified subdivision geometry (<code>geometry</code> argument). Standard vertex buffers are always bound to the default topology (topology 0) and cannot be bound differently. A vertex attribute buffer always uses the topology it is bound to when used in the <code>rtcInterpolate</code> and <code>rtcInterpolateN</code> calls.</p>
<p>A topology with ID <code>i</code> consists of a subdivision mode set through <code>rtcSetGeometrySubdivisionMode</code> and the index buffer bound to the index buffer slot <code>i</code>. This index buffer can assign indices for each face of the subdivision geometry that are different to the indices of the default topology. These new indices can for example be used to introduce additional borders into the subdivision mesh to map multiple textures onto one subdivision geometry.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrysubdivisionmode">rtcSetGeometrySubdivisionMode</a>, <a href="#rtcinterpolate">rtcInterpolate</a>, <a href="#rtcinterpolaten">rtcInterpolateN</a></p>
<p></p>
<h2 id="rtcsetgeometrydisplacementfunction">rtcSetGeometryDisplacementFunction</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetGeometryDisplacementFunction - sets the displacement function
  <span class="kw">for</span> a subdivision geometry</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCDisplacementFunctionNArguments
{
  <span class="dt">void</span>* geometryUserPtr;
  RTCGeometry geometry;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="dt">unsigned</span> <span class="dt">int</span> timeStep;
  <span class="dt">const</span> <span class="dt">float</span>* u;
  <span class="dt">const</span> <span class="dt">float</span>* v;
  <span class="dt">const</span> <span class="dt">float</span>* Ng_x;
  <span class="dt">const</span> <span class="dt">float</span>* Ng_y;
  <span class="dt">const</span> <span class="dt">float</span>* Ng_z;
  <span class="dt">float</span>* P_x;
  <span class="dt">float</span>* P_y;
  <span class="dt">float</span>* P_z;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCDisplacementFunctionN)(
   <span class="dt">const</span> <span class="kw">struct</span> RTCDisplacementFunctionNArguments* args
);

<span class="dt">void</span> rtcSetGeometryDisplacementFunction(
  RTCGeometry geometry,
  RTCDisplacementFunctionN displacement
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcSetGeometryDisplacementFunction</code> function registers a displacement callback function (<code>displacement</code> argument) for the specified subdivision geometry (<code>geometry</code> argument).</p>
<p>Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing <code>NULL</code> as function pointer disables the registered callback function.</p>
<p>The registered displacement callback function is invoked to displace points on the subdivision geometry during spatial acceleration structure construction, during the <code>rtcCommitScene</code> call.</p>
<p>The callback function of type <code>RTCDisplacementFunctionN</code> is invoked with a number of arguments stored inside the <code>RTCDisplacementFunctionNArguments</code> structure. The provided user data pointer of the geometry (<code>geometryUserPtr</code> member) can be used to point to the application's representation of the subdivision mesh. A number <code>N</code> of points to displace are specified in a structure of array layout. For each point to displace, the local patch UV coordinates (<code>u</code> and <code>v</code> arrays), the normalized geometry normal (<code>Ng_x</code>, <code>Ng_y</code>, and <code>Ng_z</code> arrays), and the position (<code>P_x</code>, <code>P_y</code>, and <code>P_z</code> arrays) are provided. The task of the displacement function is to use this information and change the position data.</p>
<p>The geometry handle (<code>geometry</code> member) and primitive ID (<code>primID</code> member) of the patch to displace are additionally provided as well as the time step <code>timeStep</code>, which can be important if the displacement is time-dependent and motion blur is used.</p>
<p>All passed arrays must be aligned to 64 bytes and properly padded to make wide vector processing inside the displacement function easily possible.</p>
<p>Also see tutorial <a href="tutorials.html#displacement-geometry">Displacement Geometry</a> for an example of how to use the displacement mapping functions.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtc_geometry_type_subdivision">RTC_GEOMETRY_TYPE_SUBDIVISION</a></p>
<p></p>
<h2 id="rtcgetgeometryfirsthalfedge">rtcGetGeometryFirstHalfEdge</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryFirstHalfEdge - returns the first half edge of a face</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">unsigned</span> <span class="dt">int</span> rtcGetGeometryFirstHalfEdge(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> faceID
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryFirstHalfEdge</code> function returns the ID of the first half edge belonging to the specified face (<code>faceID</code> argument). For instance in the following example the first half edge of face <code>f1</code> is <code>e4</code>.</p>
<div class="figure">
<img src="images/half_edges.png" />

</div>
<p>This function can only be used for subdivision geometries. As all topologies of a subdivision geometry share the same face buffer the function does not depend on the topology ID.</p>
<p>Here f0 to f7 are 8 quadrilateral faces with 4 vertices each. The edges e0 to e23 of these faces are shown with their orientation. For each face the ID of the edges corresponds to the slots the face occupies in the index array of the geometry. E.g. as the indices of face f1 start at location 4 of the index array, the first edge is edge e4, the next edge e5, etc.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetgeometryfirsthalfedge">rtcGetGeometryFirstHalfEdge</a>, <a href="#rtcgetgeometryface">rtcGetGeometryFace</a>, <a href="#rtcgetgeometryoppositehalfedge">rtcGetGeometryOppositeHalfEdge</a>, <a href="#rtcgetgeometrynexthalfedge">rtcGetGeometryNextHalfEdge</a>, <a href="#rtcgetgeometryprevioushalfedge">rtcGetGeometryPreviousHalfEdge</a></p>
<p></p>
<h2 id="rtcgetgeometryface">rtcGetGeometryFace</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryFace - returns the face of some half edge</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">unsigned</span> <span class="dt">int</span> rtcGetGeometryFace(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> edgeID
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryFace</code> function returns the ID of the face the specified half edge (<code>edgeID</code> argument) belongs to. For instance in the following example the face <code>f1</code> is returned for edges <code>e4</code>, <code>e5</code>, <code>e6</code>, and <code>e7</code>.</p>
<div class="figure">
<img src="images/half_edges.png" />

</div>
<p>This function can only be used for subdivision geometries. As all topologies of a subdivision geometry share the same face buffer the function does not depend on the topology ID.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetgeometryfirsthalfedge">rtcGetGeometryFirstHalfEdge</a>, <a href="#rtcgetgeometryface">rtcGetGeometryFace</a>, <a href="#rtcgetgeometryoppositehalfedge">rtcGetGeometryOppositeHalfEdge</a>, <a href="#rtcgetgeometrynexthalfedge">rtcGetGeometryNextHalfEdge</a>, <a href="#rtcgetgeometryprevioushalfedge">rtcGetGeometryPreviousHalfEdge</a></p>
<p></p>
<h2 id="rtcgetgeometrynexthalfedge">rtcGetGeometryNextHalfEdge</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryNextHalfEdge - returns the next half edge</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">unsigned</span> <span class="dt">int</span> rtcGetGeometryNextHalfEdge(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> edgeID
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryNextHalfEdge</code> function returns the ID of the next half edge of the specified half edge (<code>edgeID</code> argument). For instance in the following example the next half edge of <code>e10</code> is <code>e11</code>.</p>
<div class="figure">
<img src="images/half_edges.png" />

</div>
<p>This function can only be used for subdivision geometries. As all topologies of a subdivision geometry share the same face buffer the function does not depend on the topology ID.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetgeometryfirsthalfedge">rtcGetGeometryFirstHalfEdge</a>, <a href="#rtcgetgeometryface">rtcGetGeometryFace</a>, <a href="#rtcgetgeometryoppositehalfedge">rtcGetGeometryOppositeHalfEdge</a>, <a href="#rtcgetgeometrynexthalfedge">rtcGetGeometryNextHalfEdge</a>, <a href="#rtcgetgeometryprevioushalfedge">rtcGetGeometryPreviousHalfEdge</a></p>
<p></p>
<h2 id="rtcgetgeometryprevioushalfedge">rtcGetGeometryPreviousHalfEdge</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryPreviousHalfEdge - returns the previous half edge</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">unsigned</span> <span class="dt">int</span> rtcGetGeometryPreviousHalfEdge(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> edgeID
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryPreviousHalfEdge</code> function returns the ID of the previous half edge of the specified half edge (<code>edgeID</code> argument). For instance in the following example the previous half edge of <code>e6</code> is <code>e5</code>.</p>
<div class="figure">
<img src="images/half_edges.png" />

</div>
<p>This function can only be used for subdivision geometries. As all topologies of a subdivision geometry share the same face buffer the function does not depend on the topology ID.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetgeometryfirsthalfedge">rtcGetGeometryFirstHalfEdge</a>, <a href="#rtcgetgeometryface">rtcGetGeometryFace</a>, <a href="#rtcgetgeometryoppositehalfedge">rtcGetGeometryOppositeHalfEdge</a>, <a href="#rtcgetgeometrynexthalfedge">rtcGetGeometryNextHalfEdge</a>, <a href="#rtcgetgeometryprevioushalfedge">rtcGetGeometryPreviousHalfEdge</a></p>
<p></p>
<h2 id="rtcgetgeometryoppositehalfedge">rtcGetGeometryOppositeHalfEdge</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetGeometryOppositeHalfEdge - returns the opposite half edge</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">unsigned</span> <span class="dt">int</span> rtcGetGeometryOppositeHalfEdge(
  RTCGeometry geometry,
  <span class="dt">unsigned</span> <span class="dt">int</span> topologyID,
  <span class="dt">unsigned</span> <span class="dt">int</span> edgeID
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetGeometryOppositeHalfEdge</code> function returns the ID of the opposite half edge of the specified half edge (<code>edgeID</code> argument) in the specified topology (<code>topologyID</code> argument). For instance in the following example the opposite half edge of <code>e6</code> is <code>e16</code>.</p>
<div class="figure">
<img src="images/half_edges.png" />

</div>
<p>An opposite half edge does not exist if the specified half edge has either no neighboring face, or more than 2 neighboring faces. In these cases the function just returns the same edge <code>edgeID</code> again.</p>
<p>This function can only be used for subdivision geometries. The function depends on the topology as the topologies of a subdivision geometry have different index buffers assigned.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcgetgeometryfirsthalfedge">rtcGetGeometryFirstHalfEdge</a>, <a href="#rtcgetgeometryface">rtcGetGeometryFace</a>, <a href="#rtcgetgeometryoppositehalfedge">rtcGetGeometryOppositeHalfEdge</a>, <a href="#rtcgetgeometrynexthalfedge">rtcGetGeometryNextHalfEdge</a>, <a href="#rtcgetgeometryprevioushalfedge">rtcGetGeometryPreviousHalfEdge</a></p>
<p></p>
<h2 id="rtcinterpolate">rtcInterpolate</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInterpolate - interpolates vertex attributes</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCInterpolateArguments
{
  RTCGeometry geometry;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
  <span class="dt">float</span> u;
  <span class="dt">float</span> v;
  <span class="kw">enum</span> RTCBufferType bufferType;
  <span class="dt">unsigned</span> <span class="dt">int</span> bufferSlot;
  <span class="dt">float</span>* P;
  <span class="dt">float</span>* dPdu;
  <span class="dt">float</span>* dPdv;
  <span class="dt">float</span>* ddPdudu;
  <span class="dt">float</span>* ddPdvdv;
  <span class="dt">float</span>* ddPdudv;
  <span class="dt">unsigned</span> <span class="dt">int</span> valueCount;
};

<span class="dt">void</span> rtcInterpolate(
  <span class="dt">const</span> <span class="kw">struct</span> RTCInterpolateArguments* args
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcInterpolate</code> function smoothly interpolates per-vertex data over the geometry. This interpolation is supported for triangle meshes, quad meshes, curve geometries, and subdivision geometries. Apart from interpolating the vertex attribute itself, it is also possible to get the first and second order derivatives of that value. This interpolation ignores displacements of subdivision surfaces and always interpolates the underlying base surface.</p>
<p>The <code>rtcInterpolate</code> call gets passed a number of arguments inside a structure of type <code>RTCInterpolateArguments</code>. For some geometry (<code>geometry</code> parameter) this function smoothly interpolates the per-vertex data stored inside the specified geometry buffer (<code>bufferType</code> and <code>bufferSlot</code> parameters) to the u/v location (<code>u</code> and <code>v</code> parameters) of the primitive (<code>primID</code> parameter). The number of floating point values to interpolate and store to the destination arrays can be specified using the <code>valueCount</code> parameter. As interpolation buffer, one can specify vertex buffers (<code>RTC_BUFFER_TYPE_VERTEX</code>) and vertex attribute buffers (<code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>) as well.</p>
<p>The <code>rtcInterpolate</code> call stores <code>valueCount</code> number of interpolated floating point values to the memory location pointed to by <code>P</code>. One can avoid storing the interpolated value by setting <code>P</code> to <code>NULL</code>.</p>
<p>The first order derivative of the interpolation by u and v are stored at the <code>dPdu</code> and <code>dPdv</code> memory locations. One can avoid storing first order derivatives by setting both <code>dPdu</code> and <code>dPdv</code> to <code>NULL</code>.</p>
<p>The second order derivatives are stored at the <code>ddPdudu</code>, <code>ddPdvdv</code>, and <code>ddPdudv</code> memory locations. One can avoid storing second order derivatives by setting these three pointers to <code>NULL</code>.</p>
<p>To use <code>rtcInterpolate</code> for a geometry, all changes to that geometry must be properly committed using <code>rtcCommitGeometry</code>.</p>
<p>All input buffers and output arrays must be padded to 16 bytes, as the implementation uses 16-byte SSE instructions to read and write into these buffers.</p>
<p>See tutorial <a href="tutorials.html#interpolation">Interpolation</a> for an example of using the <code>rtcInterpolate</code> function.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcinterpolaten">rtcInterpolateN</a></p>
<p></p>
<h2 id="rtcinterpolaten">rtcInterpolateN</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInterpolateN - performs N interpolations of vertex attribute data</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCInterpolateNArguments
{
  RTCGeometry geometry;
  <span class="dt">const</span> <span class="dt">void</span>* valid;
  <span class="dt">const</span> <span class="dt">unsigned</span> <span class="dt">int</span>* primIDs;
  <span class="dt">const</span> <span class="dt">float</span>* u;
  <span class="dt">const</span> <span class="dt">float</span>* v;
  <span class="dt">unsigned</span> <span class="dt">int</span> N;
  <span class="kw">enum</span> RTCBufferType bufferType;
  <span class="dt">unsigned</span> <span class="dt">int</span> bufferSlot;
  <span class="dt">float</span>* P;
  <span class="dt">float</span>* dPdu;
  <span class="dt">float</span>* dPdv;
  <span class="dt">float</span>* ddPdudu;
  <span class="dt">float</span>* ddPdvdv;
  <span class="dt">float</span>* ddPdudv;
  <span class="dt">unsigned</span> <span class="dt">int</span> valueCount;
};

<span class="dt">void</span> rtcInterpolateN(
  <span class="dt">const</span> <span class="kw">struct</span> RTCInterpolateNArguments* args
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcInterpolateN</code> is similar to <code>rtcInterpolate</code>, but performs <code>N</code> many interpolations at once. It additionally gets an array of u/v coordinates and a valid mask (<code>valid</code> parameter) that specifies which of these coordinates are valid. The valid mask points to <code>N</code> integers, and a value of -1 denotes valid and 0 invalid. If the valid pointer is <code>NULL</code> all elements are considers valid. The destination arrays are filled in structure of array (SOA) layout. The value <code>N</code> must be divisible by 4.</p>
<p>To use <code>rtcInterpolateN</code> for a geometry, all changes to that geometry must be properly committed using <code>rtcCommitGeometry</code>.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcinterpolate">rtcInterpolate</a></p>
<p></p>
<h2 id="rtcnewbuffer">rtcNewBuffer</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewBuffer - creates a <span class="kw">new</span> data buffer</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCBuffer rtcNewBuffer(
  RTCDevice device,
  size_t byteSize
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcNewBuffer</code> function creates a new data buffer object of specified size in bytes (<code>byteSize</code> argument) that is bound to the specified device (<code>device</code> argument). The buffer object is reference counted with an initial reference count of 1. The returned buffer object can be released using the <code>rtcReleaseBuffer</code> API call. The specified number of bytes are allocated at buffer construction time and deallocated when the buffer is destroyed.</p>
<p>When the buffer will be used as a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> and <code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>), the last buffer element must be readable using 16-byte SSE load instructions, thus padding the last element is required for certain layouts. E.g. a standard <code>float3</code> vertex buffer layout should add storage for at least one more float to the end of the buffer.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretainbuffer">rtcRetainBuffer</a>, <a href="#rtcreleasebuffer">rtcReleaseBuffer</a></p>
<p></p>
<h2 id="rtcnewsharedbuffer">rtcNewSharedBuffer</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewSharedBuffer - creates a <span class="kw">new</span> shared data buffer</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCBuffer rtcNewSharedBuffer(
  RTCDevice device,
  <span class="dt">void</span>* ptr,
  size_t byteSize
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcNewSharedBuffer</code> function creates a new shared data buffer object bound to the specified device (<code>device</code> argument). The buffer object is reference counted with an initial reference count of 1. The buffer can be released using the <code>rtcReleaseBuffer</code> function.</p>
<p>At construction time, the pointer to the user-managed buffer data (<code>ptr</code> argument) including its size in bytes (<code>byteSize</code> argument) is provided to create the buffer. At buffer construction time no buffer data is allocated, but the buffer data provided by the application is used. The buffer data must remain valid for as long as the buffer may be used, and the user is responsible to free the buffer data when no longer required.</p>
<p>When the buffer will be used as a vertex buffer (<code>RTC_BUFFER_TYPE_VERTEX</code> and <code>RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE</code>), the last buffer element must be readable using 16-byte SSE load instructions, thus padding the last element is required for certain layouts. E.g. a standard <code>float3</code> vertex buffer layout should add storage for at least one more float to the end of the buffer.</p>
<p>The data pointer (<code>ptr</code> argument) must be aligned to 4 bytes; otherwise the <code>rtcNewSharedBuffer</code> function will fail.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure <code>NULL</code> is returned and an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretainbuffer">rtcRetainBuffer</a>, <a href="#rtcreleasebuffer">rtcReleaseBuffer</a></p>
<p></p>
<h2 id="rtcretainbuffer">rtcRetainBuffer</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainBuffer - increments the buffer reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainBuffer(RTCBuffer buffer);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Buffer objects are reference counted. The <code>rtcRetainBuffer</code> function increments the reference count of the passed buffer object (<code>buffer</code> argument). This function together with <code>rtcReleaseBuffer</code> allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbuffer">rtcNewBuffer</a>, <a href="#rtcreleasebuffer">rtcReleaseBuffer</a></p>
<p></p>
<h2 id="rtcreleasebuffer">rtcReleaseBuffer</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseBuffer - decrements the buffer reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseBuffer(RTCBuffer buffer);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>Buffer objects are reference counted. The <code>rtcReleaseBuffer</code> function decrements the reference count of the passed buffer object (<code>buffer</code> argument). When the reference count falls to 0, the buffer gets destroyed.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbuffer">rtcNewBuffer</a>, <a href="#rtcretainbuffer">rtcRetainBuffer</a></p>
<p></p>
<h2 id="rtcgetbufferdata">rtcGetBufferData</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcGetBufferData - gets a pointer to the buffer data</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span>* rtcGetBufferData(RTCBuffer buffer);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcGetBufferData</code> function returns a pointer to the buffer data of the specified buffer object (<code>buffer</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbuffer">rtcNewBuffer</a></p>
<p></p>
<h2 id="rtcray">RTCRay</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRay - single ray structure</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore_ray.h&gt;</span>

<span class="kw">struct</span> RTC_ALIGN(<span class="dv">16</span>) RTCRay
{
  <span class="dt">float</span> org_x;        <span class="co">// x coordinate of ray origin</span>
  <span class="dt">float</span> org_y;        <span class="co">// y coordinate of ray origin</span>
  <span class="dt">float</span> org_z;        <span class="co">// z coordinate of ray origin</span>
  <span class="dt">float</span> tnear;        <span class="co">// start of ray segment</span>

  <span class="dt">float</span> dir_x;        <span class="co">// x coordinate of ray direction</span>
  <span class="dt">float</span> dir_y;        <span class="co">// y coordinate of ray direction</span>
  <span class="dt">float</span> dir_z;        <span class="co">// z coordinate of ray direction</span>
  <span class="dt">float</span> time;         <span class="co">// time of this ray for motion blur</span>

  <span class="dt">float</span> tfar;         <span class="co">// end of ray segment (set to hit distance)</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> mask;  <span class="co">// ray mask</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> id;    <span class="co">// ray ID</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> flags; <span class="co">// ray flags</span>
};</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>RTCRay</code> structure defines the ray layout for a single ray. The ray contains the origin (<code>org_x</code>, <code>org_y</code>, <code>org_z</code> members), direction vector (<code>dir_x</code>, <code>dir_y</code>, <code>dir_z</code> members), and ray segment (<code>tnear</code> and <code>tfar</code> members). The ray direction does not have to be normalized, and only the parameter range specified by the <code>tnear</code>/<code>tfar</code> interval is considered valid.</p>
<p>The ray segment must be in the range <span class="math inline">[0, ∞]</span>, thus ranges that start behind the ray origin are not allowed, but ranges can reach to infinity. For rays inside a ray stream, <code>tfar</code> &lt; <code>tnear</code> identifies an inactive ray.</p>
<p>The ray further contains a motion blur time in the range <span class="math inline">[0, 1]</span> (<code>time</code> member), a ray mask (<code>mask</code> member), a ray ID (<code>id</code> member), and ray flags (<code>flags</code> member). The ray mask can be used to mask out some geometries for some rays (see <code>rtcSetGeometryMask</code> for more details). The ray ID can be used to identify a ray inside a callback function, even if the order of rays inside a ray packet or stream has changed. The ray flags are reserved.</p>
<p>The <code>embree3/rtcore_ray.h</code> header additionally defines the same ray structure in structure of array (SOA) layout for API functions accepting ray packets of size 4 (<code>RTCRay4</code> type), size 8 (<code>RTCRay8</code> type), and size 16 (<code>RTCRay16</code> type). The header additionally defines an <code>RTCRayNt</code> template for ray packets of an arbitrary compile-time size.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtchit">RTCHit</a></p>
<p></p>
<h2 id="rtchit">RTCHit</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCHit - single hit structure</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCHit
{
  <span class="dt">float</span> Ng_x;                                        <span class="co">// x coordinate of geometry normal</span>
  <span class="dt">float</span> Ng_y;                                        <span class="co">// y coordinate of geometry normal</span>
  <span class="dt">float</span> Ng_z;                                        <span class="co">// z coordinate of geometry normal</span>

  <span class="dt">float</span> u;                                           <span class="co">// barycentric u coordinate of hit</span>
  <span class="dt">float</span> v;                                           <span class="co">// barycentric v coordinate of hit</span>

  <span class="dt">unsigned</span> <span class="dt">int</span> primID;                               <span class="co">// geometry ID</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID;                               <span class="co">// primitive ID</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> instID[RTC_MAX_INSTANCE_LEVEL_COUNT]; <span class="co">// instance ID</span>
};</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>RTCHit</code> type defines the type of a ray/primitive intersection result. The hit contains the unnormalized geometric normal in object space at the hit location (<code>Ng_x</code>, <code>Ng_y</code>, <code>Ng_z</code> members), the barycentric u/v coordinates of the hit (<code>u</code> and <code>v</code> members), as well as the primitive ID (<code>primID</code> member), geometry ID (<code>geomID</code> member), and instance ID stack (<code>instID</code> member) of the hit. The parametric intersection distance is not stored inside the hit, but stored inside the <code>tfar</code> member of the ray.</p>
<p>The <code>embree3/rtcore_ray.h</code> header additionally defines the same hit structure in structure of array (SOA) layout for hit packets of size 4 (<code>RTCHit4</code> type), size 8 (<code>RTCHit8</code> type), and size 16 (<code>RTCHit16</code> type). The header additionally defines an <code>RTCHitNt</code> template for hit packets of an arbitrary compile-time size.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcray">RTCRay</a>, [Multi-Level Instancing]</p>
<p></p>
<h2 id="rtcrayhit">RTCRayHit</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRayHit - combined single ray/hit structure</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore_ray.h&gt;</span>

<span class="kw">struct</span> RTCORE_ALIGN(<span class="dv">16</span>) RTCRayHit
{
  <span class="kw">struct</span> RTCRay ray;
  <span class="kw">struct</span> RTCHit hit;
};</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>RTCRayHit</code> structure is used as input for the <code>rtcIntersect</code>-type functions and stores the ray to intersect and some hit fields that hold the intersection result afterwards.</p>
<p>The <code>embree3/rtcore_ray.h</code> header additionally defines the same ray/hit structure in structure of array (SOA) layout for API functions accepting ray packets of size 4 (<code>RTCRayHit4</code> type), size 8 (<code>RTCRayHit8</code> type), and size 16 (<code>RTCRayHit16</code> type). The header additionally defines an <code>RTCRayHitNt</code> template to generate ray/hit packets of an arbitrary compile-time size.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcray">RTCRay</a>, <a href="#rtchit">RTCHit</a></p>
<p></p>
<h2 id="rtcrayn">RTCRayN</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRayN - ray packet of runtime size</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore_ray.h&gt;</span>

<span class="kw">struct</span> RTCRayN;

<span class="dt">float</span>&amp; RTCRayN_org_x(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_org_y(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_org_z(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_tnear(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);

<span class="dt">float</span>&amp; RTCRayN_dir_x(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_dir_y(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_dir_z(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCRayN_time (RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);

<span class="dt">float</span>&amp;        RTCRayN_tfar (RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span> <span class="dt">int</span>&amp; RTCRayN_mask (RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span> <span class="dt">int</span>&amp; RTCRayN_id   (RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span> <span class="dt">int</span>&amp; RTCRayN_flags(RTCRayN* ray, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>When the ray packet size is not known at compile time (e.g. when Embree returns a ray packet in the <code>RTCFilterFuncN</code> callback function), Embree uses the <code>RTCRayN</code> type for ray packets. These ray packets can only have sizes of 1, 4, 8, or 16. No other packet size will be used.</p>
<p>You can either implement different special code paths for each of these possible packet sizes and cast the ray to the appropriate ray packet type, or implement one general code path that uses the <code>RTCRayN_XXX</code> helper functions to access the ray packet components.</p>
<p>These helper functions get a pointer to the ray packet (<code>ray</code> argument), the packet size (<code>N</code> argument), and returns a reference to a component (e.g. x-component of origin) of the the i-th ray of the packet (<code>i</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtchitn">RTCHitN</a></p>
<p></p>
<h2 id="rtchitn">RTCHitN</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCHitN - hit packet of runtime size</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> HitN;

<span class="dt">float</span>&amp; RTCHitN_Ng_x(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCHitN_Ng_y(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCHitN_Ng_z(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);

<span class="dt">float</span>&amp; RTCHitN_u(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">float</span>&amp; RTCHitN_v(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);

<span class="dt">unsigned</span>&amp; RTCHitN_primID(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span>&amp; RTCHitN_geomID(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i);
<span class="dt">unsigned</span>&amp; RTCHitN_instID(RTCHitN* hit, <span class="dt">unsigned</span> <span class="dt">int</span> N, <span class="dt">unsigned</span> <span class="dt">int</span> i, <span class="dt">unsigned</span> <span class="dt">int</span> level);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>When the hit packet size is not known at compile time (e.g. when Embree returns a hit packet in the <code>RTCFilterFuncN</code> callback function), Embree uses the <code>RTCHitN</code> type for hit packets. These hit packets can only have sizes of 1, 4, 8, or 16. No other packet size will be used.</p>
<p>You can either implement different special code paths for each of these possible packet sizes and cast the hit to the appropriate hit packet type, or implement one general code path that uses the <code>RTCHitN_XXX</code> helper functions to access hit packet components.</p>
<p>These helper functions get a pointer to the hit packet (<code>hit</code> argument), the packet size (<code>N</code> argument), and returns a reference to a component (e.g. x component of <code>Ng</code>) of the the i-th hit of the packet (<code>i</code> argument).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcrayn">RTCRayN</a></p>
<p></p>
<h2 id="rtcrayhitn">RTCRayHitN</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRayHitN - combined ray/hit packet of runtime size</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore_ray.h&gt;</span>

<span class="kw">struct</span> RTCRayHitN;

<span class="kw">struct</span> RTCRayN* RTCRayHitN_RayN(<span class="kw">struct</span> RTCRayHitN* rayhit, <span class="dt">unsigned</span> <span class="dt">int</span> N);
<span class="kw">struct</span> RTCHitN* RTCRayHitN_HitN(<span class="kw">struct</span> RTCRayHitN* rayhit, <span class="dt">unsigned</span> <span class="dt">int</span> N);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>When the packet size of a ray/hit structure is not known at compile time (e.g. when Embree returns a ray/hit packet in the <code>RTCIntersectFunctionN</code> callback function), Embree uses the <code>RTCRayHitN</code> type for ray packets. These ray/hit packets can only have sizes of 1, 4, 8, or 16. No other packet size will be used.</p>
<p>You can either implement different special code paths for each of these possible packet sizes and cast the ray/hit to the appropriate ray/hit packet type, or extract the <code>RTCRayN</code> and <code>RTCHitN</code> components using the <code>rtcGetRayN</code> and <code>rtcGetHitN</code> helper functions and use the <code>RTCRayN_XXX</code> and <code>RTCHitN_XXX</code> functions to access the ray and hit parts of the structure.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtchitn">RTCHitN</a></p>
<p></p>
<h2 id="rtcinitintersectcontext">rtcInitIntersectContext</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInitIntersectContext - initializes the intersection context</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">enum</span> RTCIntersectContextFlags
{
  RTC_INTERSECT_CONTEXT_FLAG_NONE,
  RTC_INTERSECT_CONTEXT_FLAG_INCOHERENT,
  RTC_INTERSECT_CONTEXT_FLAG_COHERENT,
};

<span class="kw">struct</span> RTCIntersectContext
{
  <span class="kw">enum</span> RTCIntersectContextFlags flags;
  RTCFilterFunctionN filter;
  <span class="ot">#if RTC_MAX_INSTANCE_LEVEL_COUNT &gt; 1</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> instStackSize;
  <span class="ot">#endif</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> instID[RTC_MAX_INSTANCE_LEVEL_COUNT];
};

<span class="dt">void</span> rtcInitIntersectContext(
  <span class="kw">struct</span> RTCIntersectContext* context
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>A per ray-query intersection context (<code>RTCIntersectContext</code> type) is supported that can be used to configure intersection flags (<code>flags</code> member), specify a filter callback function (<code>filter</code> member), specify the chain of IDs of the current instance (<code>instID</code> and <code>instStackSize</code> members), and to attach arbitrary data to the query (e.g. per ray data).</p>
<p>The <code>rtcInitIntersectContext</code> function initializes the context to default values and should be called to initialize every intersection context. This function gets inlined, which minimizes overhead and allows for compiler optimizations.</p>
<p>The intersection context flag can be used to tune the behavior of the traversal algorithm. Using the <code>RTC_INTERSECT_CONTEXT_FLAG_INCOHERENT</code> flags uses an optimized traversal algorithm for incoherent rays (default), while <code>RTC_INTERSECT_CONTEXT_FLAG_COHERENT</code> uses an optimized traversal algorithm for coherent rays (e.g. primary camera rays).</p>
<p>Best primary ray performance can be obtained by using the ray stream API and setting the intersect context flag to <code>RTC_INTERSECT_CONTEXT_FLAG_COHERENT</code>. For secondary rays, it is typically better to use the <code>RTC_INTERSECT_CONTEXT_FLAG_INCOHERENT</code> flag, unless the rays are known to be very coherent too (e.g. for primary transparency rays).</p>
<p>A filter function can be specified inside the context. This filter function is invoked as a second filter stage after the per-geometry intersect or occluded filter function is invoked. Only rays that passed the first filter stage are valid in this second filter stage. Having such a per ray-query filter function can be useful to implement modifications of the behavior of the query, such as collecting all hits or accumulating transparencies. The support for the context filter function must be enabled for a scene by using the <code>RTC_SCENE_FLAG_CONTEXT_FILTER_FUNCTION</code> scene flag.</p>
<p>It is guaranteed that the pointer to the intersection context passed to a ray query is directly passed to the registered callback functions. This way it is possible to attach arbitrary data to the end of the intersection context, such as a per-ray payload.</p>
<p>Please note that the ray pointer is not guaranteed to be passed to the callback functions, thus reading additional data from the ray pointer passed to callbacks is not possible.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>No error code is set by this function.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersect1">rtcIntersect1</a>, <a href="#rtcoccluded1">rtcOccluded1</a></p>
<p></p>
<h2 id="rtcintersect1">rtcIntersect1</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersect1 - finds the closest hit <span class="kw">for</span> a single ray</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersect1(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit* rayhit
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersect1</code> function finds the closest hit of a single ray with the scene (<code>scene</code> argument). The provided ray/hit structure (<code>rayhit</code> argument) contains the ray to intersect and some hit output fields that are filled when a hit is found.</p>
<p>The user has to initialize the ray origin (<code>org</code> ray member), ray direction (<code>dir</code> ray member), ray segment (<code>tnear</code>, <code>tfar</code> ray members), and set the ray flags to <code>0</code> (<code>flags</code> ray member). If the scene contains motion blur geometries, also the ray time (<code>time</code> ray member) must be initialized to a value in the range <span class="math inline">[0, 1]</span>. If ray masks are enabled at compile time, the ray mask (<code>mask</code> ray member) must be initialized as well. The ray segment has to be in the range <span class="math inline">[0, ∞]</span>, thus ranges that start behind the ray origin are not valid, but ranges can reach to infinity. See Section <a href="#rtcray">RTCRay</a> for the ray layout description.</p>
<p>The geometry ID (<code>geomID</code> hit member) of the hit data must be initialized to <code>RTC_INVALID_GEOMETRY_ID</code> (-1).</p>
<p>Further, an intersection context for the ray query function must be created and initialized (see <code>rtcInitIntersectContext</code>).</p>
<p>When no intersection is found, the ray/hit data is not updated. When an intersection is found, the hit distance is written into the <code>tfar</code> member of the ray and all hit data is set, such as unnormalized geometry normal in object space (<code>Ng</code> hit member), local hit coordinates (<code>u</code>, <code>v</code> hit member), instance ID stack (<code>instID</code> hit member), geometry ID (<code>geomID</code> hit member), and primitive ID (<code>primID</code> hit member). See Section <a href="#rtchit">RTCHit</a> for the hit layout description.</p>
<p>If the instance ID stack has a prefix of values not equal to <code>RTC_INVALID_GEOMETRY_ID</code>, the instance ID on each level corresponds to the geometry ID of the hit instance of the higher-level scene, the geometry ID corresponds to the hit geometry inside the hit instanced scene, and the primitive ID corresponds to the n-th primitive of that geometry.</p>
<p>If level 0 of the instance ID stack is equal to <code>RTC_INVALID_GEOMETRY_ID</code>, the geometry ID corresponds to the hit geometry inside the top-level scene, and the primitive ID corresponds to the n-th primitive of that geometry.</p>
<p>The implementation makes no guarantees that primitives whose hit distance is exactly at (or very close to) <code>tnear</code> or <code>tfar</code> are hit or missed. If you want to exclude intersections at <code>tnear</code> just pass a slightly enlarged <code>tnear</code>, and if you want to include intersections at <code>tfar</code> pass a slightly enlarged <code>tfar</code>.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the intersection context.</p>
<p>The ray/hit structure must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded1">rtcOccluded1</a>, <a href="#rtcrayhit">RTCRayHit</a>, <a href="#rtcray">RTCRay</a>, <a href="#rtchit">RTCHit</a></p>
<p></p>
<h2 id="rtcoccluded1">rtcOccluded1</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccluded1 - finds any hit <span class="kw">for</span> a single ray</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccluded1(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay* ray
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccluded1</code> function checks for a single ray (<code>ray</code> argument) whether there is any hit with the scene (<code>scene</code> argument).</p>
<p>The user must initialize the ray origin (<code>org</code> ray member), ray direction (<code>dir</code> ray member), ray segment (<code>tnear</code>, <code>tfar</code> ray members), and must set the ray flags to <code>0</code> (<code>flags</code> ray member). If the scene contains motion blur geometries, also the ray time (<code>time</code> ray member) must be initialized to a value in the range <span class="math inline">[0, 1]</span>. If ray masks are enabled at compile time, the ray mask (<code>mask</code> ray member) must be initialized as well. The ray segment must be in the range <span class="math inline">[0, ∞]</span>, thus ranges that start behind the ray origin are not valid, but ranges can reach to infinity. See Section <a href="#rtcray">RTCRay</a> for the ray layout description.</p>
<p>When no intersection is found, the ray data is not updated. In case a hit was found, the <code>tfar</code> component of the ray is set to <code>-inf</code>.</p>
<p>The implementation makes no guarantees that primitives whose hit distance is exactly at (or very close to) <code>tnear</code> or <code>tfar</code> are hit or missed. If you want to exclude intersections at <code>tnear</code> just pass a slightly enlarged <code>tnear</code>, and if you want to include intersections at <code>tfar</code> pass a slightly enlarged <code>tfar</code>.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the intersection context.</p>
<p>The ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded1">rtcOccluded1</a>, <a href="#rtcray">RTCRay</a></p>
<p></p>
<h2 id="rtcintersect4816">rtcIntersect4/8/16</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersect4/<span class="dv">8</span>/<span class="dv">16</span> - finds the closest hits <span class="kw">for</span> a ray packet</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersect4(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit4* rayhit
);

<span class="dt">void</span> rtcIntersect8(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit8* rayhit
);

<span class="dt">void</span> rtcIntersect16(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit16* rayhit
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersect4/8/16</code> functions finds the closest hits for a ray packet of size 4, 8, or 16 (<code>rayhit</code> argument) with the scene (<code>scene</code> argument). The ray/hit input contains a ray packet and hit packet. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace rays.</p>
<p>A ray valid mask must be provided (<code>valid</code> argument) which stores one 32-bit integer (<code>-1</code> means valid and <code>0</code> invalid) per ray in the packet. Only active rays are processed, and hit data of inactive rays is not changed.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the intersection context.</p>
<p>The implementation of these functions is guaranteed to invoke callback functions always with the same ray packet size and ordering of rays as specified initially.</p>
<p>For <code>rtcIntersect4</code> the ray packet must be aligned to 16 bytes, for <code>rtcIntersect8</code> the alignment must be 32 bytes, and for <code>rtcIntersect16</code> the alignment must be 64 bytes.</p>
<p>The <code>rtcIntersect4</code>, <code>rtcIntersect8</code> and <code>rtcIntersect16</code> functions may change the ray packet size and ray order when calling back into intersect filter functions or user geometry callbacks. Under some conditions the application can assume packets to stay intakt, which can determined by querying the <code>RTC_DEVICE_PROPERTY_NATIVE_RAY4_SUPPORTED</code>, <code>RTC_DEVICE_PROPERTY_NATIVE_RAY8_SUPPORTED</code>, <code>RTC_DEVICE_PROPERTY_NATIVE_RAY16_SUPPORTED</code> properties through the <code>rtcGetDeviceProperty</code> function. See <a href="#rtcgetdeviceproperty">rtcGetDeviceProperty</a> for more information.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded4816">rtcOccluded4/8/16</a></p>
<p></p>
<h2 id="rtcoccluded4816">rtcOccluded4/8/16</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccluded4/<span class="dv">8</span>/<span class="dv">16</span> - finds any hits <span class="kw">for</span> a ray packet</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccluded4(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay4* ray
);

<span class="dt">void</span> rtcOccluded8(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay8* ray
);

<span class="dt">void</span> rtcOccluded16(
  <span class="dt">const</span> <span class="dt">int</span>* valid,
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay16* ray
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccluded4/8/16</code> functions checks for each active ray of the ray packet of size 4, 8, or 16 (<code>ray</code> argument) whether there is any hit with the scene (<code>scene</code> argument). See Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace occlusion rays.</p>
<p>A ray valid mask must be provided (<code>valid</code> argument) which stores one 32-bit integer (<code>-1</code> means valid and <code>0</code> invalid) per ray in the packet. Only active rays are processed, and hit data of inactive rays is not changed.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the intersection context.</p>
<p>The implementation of these functions is guaranteed to invoke callback functions always with the same ray packet size and ordering of rays as specified initially.</p>
<p>For <code>rtcOccluded4</code> the ray packet must be aligned to 16 bytes, for <code>rtcOccluded8</code> the alignment must be 32 bytes, and for <code>rtcOccluded16</code> the alignment must be 64 bytes.</p>
<p>The <code>rtcOccluded4</code>, <code>rtcOccluded8</code> and <code>rtcOccluded16</code> functions may change the ray packet size and ray order when calling back into intersect filter functions or user geometry callbacks. Under some conditions the application can assume packets to stay intakt, which can determined by querying the <code>RTC_DEVICE_PROPERTY_NATIVE_RAY4_SUPPORTED</code>, <code>RTC_DEVICE_PROPERTY_NATIVE_RAY8_SUPPORTED</code>, <code>RTC_DEVICE_PROPERTY_NATIVE_RAY16_SUPPORTED</code> properties through the <code>rtcGetDeviceProperty</code> function. See <a href="#rtcgetdeviceproperty">rtcGetDeviceProperty</a> for more information.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded4816">rtcOccluded4/8/16</a></p>
<p></p>
<h2 id="rtcintersect1m">rtcIntersect1M</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersect1M - finds the closest hits <span class="kw">for</span> a stream of M single
  rays</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersect1M(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit* rayhit,
  <span class="dt">unsigned</span> <span class="dt">int</span> M,
  size_t byteStride
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersect1M</code> function finds the closest hits for a stream of <code>M</code> single rays (<code>rayhit</code> argument) with the scene (<code>scene</code> argument). The <code>rayhit</code> argument points to an array of ray and hit data with specified byte stride (<code>byteStride</code> argument) between the ray/hit structures. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded1m">rtcOccluded1M</a></p>
<p></p>
<h2 id="rtcoccluded1m">rtcOccluded1M</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccluded1M - finds any hits <span class="kw">for</span> a stream of M single rays</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccluded1M(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay* ray,
  <span class="dt">unsigned</span> <span class="dt">int</span> M,
  size_t byteStride
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccluded1M</code> function checks whether there are any hits for a stream of <code>M</code> single rays (<code>ray</code> argument) with the scene (<code>scene</code> argument). The <code>ray</code> argument points to an array of rays with specified byte stride (<code>byteStride</code> argument) between the rays. See Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace occlusion rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersect1m">rtcIntersect1M</a></p>
<p></p>
<h2 id="rtcintersect1mp">rtcIntersect1Mp</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersect1Mp - finds the closest hits <span class="kw">for</span> a stream of M pointers
  to single rays</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersect1Mp(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHit** rayhit,
  <span class="dt">unsigned</span> <span class="dt">int</span> M
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersect1Mp</code> function finds the closest hits for a stream of <code>M</code> single rays (<code>rayhit</code> argument) with the scene (<code>scene</code> argument). The <code>rayhit</code> argument points to an array of pointers to the individual ray/hit structures. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace a ray.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccluded1mp">rtcOccluded1Mp</a></p>
<p></p>
<h2 id="rtcoccluded1mp">rtcOccluded1Mp</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccluded1Mp - find any hits <span class="kw">for</span> a stream of M pointers to
  single rays</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccluded1M(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRay** ray,
  <span class="dt">unsigned</span> <span class="dt">int</span> M
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccluded1Mp</code> function checks whether there are any hits for a stream of <code>M</code> single rays (<code>ray</code> argument) with the scene (<code>scene</code> argument). The <code>ray</code> argument points to an array of pointers to rays. Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace a occlusion rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersect1mp">rtcIntersect1Mp</a></p>
<p></p>
<h2 id="rtcintersectnm">rtcIntersectNM</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersectNM - finds the closest hits <span class="kw">for</span> a stream of M
  ray packets of size N</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersectNM(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHitN* rayhit,
  <span class="dt">unsigned</span> <span class="dt">int</span> N,
  <span class="dt">unsigned</span> <span class="dt">int</span> M,
  size_t byteStride
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersectNM</code> function finds the closest hits for a stream of <code>M</code> ray packets (<code>rayhit</code> argument) of size <code>N</code> with the scene (<code>scene</code> argument). The <code>rays</code> argument points to an array of ray and hit packets with specified byte stride (<code>byteStride</code> argument) between the ray/hit packets. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The packet size <code>N</code> must be larger than 0, and the stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccludednm">rtcOccludedNM</a></p>
<p></p>
<h2 id="rtcoccludednm">rtcOccludedNM</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccludedNM - finds any hits <span class="kw">for</span> a stream of M ray packets of
  size N</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccludedNM(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayN* ray,
  <span class="dt">unsigned</span> <span class="dt">int</span> N,
  <span class="dt">unsigned</span> <span class="dt">int</span> M,
  size_t byteStride
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccludedNM</code> function checks whether there are any hits for a stream of <code>M</code> ray packets (<code>ray</code> argument) of size <code>N</code> with the scene (<code>scene</code> argument). The <code>ray</code> argument points to an array of ray packets with specified byte stride (<code>byteStride</code> argument) between the ray packets. See Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace occlusion rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The packet size <code>N</code> must be larger than 0, and the stream size <code>M</code> can be an arbitrary positive integer including 0. Each ray must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersectnm">rtcIntersectNM</a></p>
<p></p>
<h2 id="rtcintersectnp">rtcIntersectNp</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcIntersectNp - finds the closest hits <span class="kw">for</span> a SOA ray stream of
  size N</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcIntersectNp(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayHitNp* rayhit,
  <span class="dt">unsigned</span> <span class="dt">int</span> N
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcIntersectNp</code> function finds the closest hits for a SOA ray stream (<code>rays</code> argument) of size <code>N</code> (basically a large ray packet) with the scene (<code>scene</code> argument). The <code>rayhit</code> argument points to two structures of pointers with one pointer for each ray and hit component. Each of these pointers points to an array with the ray or hit component data for each ray or hit. This way the individual components of the SOA ray stream do not need to be stored sequentially in memory, which makes it possible to have large varying size ray packets in SOA layout. See Section <a href="#rtcintersect1">rtcIntersect1</a> for a description of how to set up and trace rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>N</code> can be an arbitrary positive integer including 0. Each ray component array must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcoccludednp">rtcOccludedNp</a></p>
<p></p>
<h2 id="rtcoccludednp">rtcOccludedNp</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcOccludedNp - finds any hits <span class="kw">for</span> a SOA ray stream of size N</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcOccludedNp(
  RTCScene scene,
  <span class="kw">struct</span> RTCIntersectContext* context,
  <span class="kw">struct</span> RTCRayNp* ray,
  <span class="dt">unsigned</span> <span class="dt">int</span> N
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcOccludedNp</code> function checks whether there are any hits for a SOA ray stream (<code>ray</code> argument) of size <code>N</code> (basically a large ray packet) with the scene (<code>scene</code> argument). The <code>ray</code> argument points to a structure of pointers with one pointer for each ray component. Each of these pointers points to an array with the ray component data for each ray. This way the individual components of the SOA ray stream do not need to be stored sequentially in memory, which makes it possible to have large varying size ray packets in SOA layout. See Section <a href="#rtcoccluded1">rtcOccluded1</a> for a description of how to set up and trace occlusion rays.</p>
<p>The intersection context (<code>context</code> argument) can specify flags to optimize traversal and a filter callback function to be invoked for every intersection. Further, the pointer to the intersection context is propagated to callback functions invoked during traversal and can thus be used to extend the ray with additional data. See Section <code>RTCIntersectContext</code> for more information.</p>
<p>The implementation of the stream ray query functions may re-order rays arbitrarily and re-pack rays into ray packets of different size. For this reason, callback functions may be invoked with an arbitrary packet size (of size 1, 4, 8, or 16) and different ordering as specified initially. For this reason, one may have to use the <code>rayID</code> component of the ray to identify the original ray, e.g. to access a per-ray payload.</p>
<p>A ray in a ray stream is considered inactive if its <code>tnear</code> value is larger than its <code>tfar</code> value.</p>
<p>The stream size <code>N</code> can be an arbitrary positive integer including 0. Each ray component array must be aligned to 16 bytes.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcintersectnp">rtcIntersectNp</a></p>
<p></p>
<h2 id="rtcinitpointquerycontext">rtcInitPointQueryContext</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInitPointQueryContext - initializes the context information (e.g.
  stack of (multilevel-)instance transformations) <span class="kw">for</span> point queries</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTC_ALIGN(<span class="dv">16</span>) RTCPointQueryContext
{
  <span class="co">// accumulated 4x4 column major matrices from world to instance space.</span>
  <span class="dt">float</span> world2inst[RTC_MAX_INSTANCE_LEVEL_COUNT][<span class="dv">16</span>];
  
  <span class="co">// accumulated 4x4 column major matrices from instance to world space.</span>
  <span class="dt">float</span> inst2world[RTC_MAX_INSTANCE_LEVEL_COUNT][<span class="dv">16</span>];

  <span class="co">// instance ids.</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> instID[RTC_MAX_INSTANCE_LEVEL_COUNT];
  
  <span class="co">// number of instances currently on the stack.</span>
  <span class="dt">unsigned</span> <span class="dt">int</span> instStackSize;
};

<span class="dt">void</span> rtcInitPointQueryContext(
  <span class="kw">struct</span> RTCPointQueryContext* context
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>A stack (<code>RTCPointQueryContext</code> type) which stores the IDs and instance transformations during a BVH traversal for a point query. The transformations are assumed to be affine transformations (3×3 matrix plus translation) and therefore the last column is ignored (see <a href="#rtc_geometry_type_instance">RTC_GEOMETRY_TYPE_INSTANCE</a> for details).</p>
<p>The <code>rtcInitPointContext</code> function initializes the context to default values and should be called for initialization.</p>
<p>The context will be passed as an argument to the point query callback function (see <a href="#rtcsetgeometrypointqueryfunction">rtcSetGeometryPointQueryFunction</a>) and should be used to pass instance information down the instancing chain for user defined instancing (see tutorial [ClosestPoint] for a reference implementation of point queries with user defined instancing).</p>
<p>The context is an necessary argument to [rtcPointQuery] and Embree internally uses the topmost instance tranformation of the stack to transform the point query into instance space.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>No error code is set by this function.</p>
<h4 id="see-also">SEE ALSO</h4>
<p>[rtcPointQuery], <a href="#rtcsetgeometrypointqueryfunction">rtcSetGeometryPointQueryFunction</a></p>
<p>## rtcPointQuery</p>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcPointQuery - traverses the BVH with a point query object</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTC_ALIGN(<span class="dv">16</span>) RTCPointQuery
{
  <span class="co">// location of the query</span>
  <span class="dt">float</span> x;
  <span class="dt">float</span> y;
  <span class="dt">float</span> z;

  <span class="co">// radius and time of the query</span>
  <span class="dt">float</span> radius;
  <span class="dt">float</span> time;
};

<span class="dt">void</span> rtcPointQuery(
  RTCScene scene,
  <span class="kw">struct</span> RTCPointQuery* query,
  <span class="kw">struct</span> RTCPointQueryContext* context,
  <span class="kw">struct</span> RTCPointQueryFunction* queryFunc,
  <span class="dt">void</span>* userPtr
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcPointQuery</code> function traverses the BVH using a <code>RTCPointQuery</code> object (<code>query</code> argument) and calls a user defined callback function (e.g <code>queryFunc</code> argument) for each primitive of the scene (<code>scene</code> argument) that intersects the query domain.</p>
<p>The user has to initialize the query location (<code>x</code>, <code>y</code> and <code>z</code> member) and query radius in the range <span class="math inline">[0, ∞]</span>. If the scene contains motion blur geometries, also the query time (<code>time</code> member) must be initialized to a value in the range <span class="math inline">[0, 1]</span>.</p>
<p>Further, a <code>RTCPointQueryContext</code> (<code>context</code> argument) must be created and initialized. It contains ID and transformation information of the instancing hierarchy if (multilevel-)instancing is used. See <a href="#rtcinitpointquerycontext">rtcInitPointQueryContext</a> for further information.</p>
<p>For every primitive that intersects the query domain, the callback function (<code>queryFunc</code> argument) is called, in which distance computations to the primitive can be implemented. The user will be provided with the primID and geomID of the according primitive, however, the geometry information (e.g. triangle index and vertex data) has to be determined manually. The <code>userPtr</code> argument can be used to input geometry data of the scene or output results of the point query (e.g. closest point currently found on surface geometry (see tutorial [ClosestPoint])).</p>
<p>The parameter <code>queryFunc</code> is optional and can be NULL, in which case the callback function is not invoked. However, a callback function can still get attached to a specific <code>RTCGeometry</code> object using <a href="#rtcsetgeometrypointqueryfunction">rtcSetGeometryPointQueryFunction</a>. If a callback function is attached to a geometry and (a potentially different) callback function is passed as an argument to <code>rtcPointQuery</code>, both functions are called for the primitives of the according geometries.</p>
<p>The query radius can be decreased inside the callback function, which allows to efficiently cull parts of the scene during BVH traversal. Increasing the query radius and modifying time or location of the query will result in undefined behaviour.</p>
<p>The callback function will be called for all primitives in a leaf node of the BVH even if the primitive is outside the query domain, since Embree does not gather geometry information of primitives internally.</p>
<p>Point queries can be used with (multilevel)-instancing. However, care has to be taken when the instance transformation contains anisotropic scaling or sheering. In these cases distance computations have to be performed in world space to ensure correctness and the ellipsoidal query domain (in instance space) will be approximated with its axis aligned bounding box interally. Therefore, the callback function might be invoked even for primitives in inner BVH nodes that do not intersect the query domain. See <a href="#rtcsetgeometrypointqueryfunction">rtcSetGeometryPointQueryFunction</a> for details.</p>
<p>The point query structure must be aligned to 16 bytes.</p>
<h4 id="supported-primitives">SUPPORTED PRIMITIVES</h4>
<p>Currenly, all primitive types are supported by the point query API except of points (see <a href="#rtc_geometry_type_point">RTC_GEOMETRY_TYPE_POINT</a>), curves (see <a href="#rtc_geometry_type_curve">RTC_GEOMETRY_TYPE_CURVE</a>) and sudivision surfaces (see [RTC_GEOMETRY_SUBDIVISION]).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>For performance reasons this function does not do any error checks, thus will not set any error flags on failure.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrypointqueryfunction">rtcSetGeometryPointQueryFunction</a>, <a href="#rtcinitpointquerycontext">rtcInitPointQueryContext</a></p>
<p></p>
<h2 id="rtccollide">rtcCollide</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcCollide - intersects one BVH with another</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTCCollision {
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID0, primID0;
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID1, primID1;
};

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCCollideFunc) (
  <span class="dt">void</span>* userPtr,
  RTCCollision* collisions,
  size_t num_collisions);

<span class="dt">void</span> rtcCollide (
    RTCScene hscene0, 
    RTCScene hscene1, 
    RTCCollideFunc callback, 
    <span class="dt">void</span>* userPtr
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcCollide</code> function intersects the BVH of <code>hscene0</code> with the BVH of scene <code>hscene1</code> and calls a user defined callback function (e.g <code>callback</code> argument) for each pair of intersecting primitives between the two scenes. A user defined data pointer (<code>userPtr</code> argument) can also be passed in.</p>
<p>For every pair of primitives that may intersect each other, the callback function (<code>callback</code> argument) is called. The user will be provided with the primID's and geomID's of multiple potentially intersecting primitive pairs. Currently, only scene entirely composed of user geometries are supported, thus the user is expected to implement a primitive/primitive intersection to filter out false positives in the callback function. The <code>userPtr</code> argument can be used to input geometry data of the scene or output results of the intersection query.</p>
<h4 id="supported-primitives">SUPPORTED PRIMITIVES</h4>
<p>Currently, the only supported type is the user geometry type (see <a href="#rtc_geometry_type_user">RTC_GEOMETRY_TYPE_USER</a>).</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p></p>
<h2 id="rtcnewbvh">rtcNewBVH</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcNewBVH - creates a <span class="kw">new</span> BVH object</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

RTCBVH rtcNewBVH(RTCDevice device);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>This function creates a new BVH object and returns a handle to this BVH. The BVH object is reference counted with an initial reference count of 1. The handle can be released using the <code>rtcReleaseBVH</code> API call.</p>
<p>The BVH object can be used to build a BVH in a user-specified format over user-specified primitives. See the documentation of the <code>rtcBuildBVH</code> call for more details.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcretainbvh">rtcRetainBVH</a>, <a href="#rtcreleasebvh">rtcReleaseBVH</a>, <a href="#rtcbuildbvh">rtcBuildBVH</a></p>
<p></p>
<h2 id="rtcretainbvh">rtcRetainBVH</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcRetainBVH - increments the BVH reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcRetainBVH(RTCBVH bvh);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>BVH objects are reference counted. The <code>rtcRetainBVH</code> function increments the reference count of the passed BVH object (<code>bvh</code> argument). This function together with <code>rtcReleaseBVH</code> allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbvh">rtcNewBVH</a>, <a href="#rtcreleasebvh">rtcReleaseBVH</a></p>
<p></p>
<h2 id="rtcreleasebvh">rtcReleaseBVH</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcReleaseBVH - decrements the BVH reference count</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="dt">void</span> rtcReleaseBVH(RTCBVH bvh);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>BVH objects are reference counted. The <code>rtcReleaseBVH</code> function decrements the reference count of the passed BVH object (<code>bvh</code> argument). When the reference count falls to 0, the BVH gets destroyed.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbvh">rtcNewBVH</a>, <a href="#rtcretainbvh">rtcRetainBVH</a></p>
<p></p>
<h2 id="rtcbuildbvh">rtcBuildBVH</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcBuildBVH - builds a BVH</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree3/rtcore.h&gt;</span>

<span class="kw">struct</span> RTC_ALIGN(<span class="dv">32</span>) RTCBuildPrimitive
{
  <span class="dt">float</span> lower_x, lower_y, lower_z; 
  <span class="dt">unsigned</span> <span class="dt">int</span> geomID;
  <span class="dt">float</span> upper_x, upper_y, upper_z;
  <span class="dt">unsigned</span> <span class="dt">int</span> primID;
};

<span class="kw">typedef</span> <span class="dt">void</span>* (*RTCCreateNodeFunction) (
  RTCThreadLocalAllocator allocator,
  <span class="dt">unsigned</span> <span class="dt">int</span> childCount,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCSetNodeChildrenFunction) (
  <span class="dt">void</span>* nodePtr,
  <span class="dt">void</span>** children,
  <span class="dt">unsigned</span> <span class="dt">int</span> childCount,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCSetNodeBoundsFunction) (
  <span class="dt">void</span>* nodePtr,
  <span class="dt">const</span> <span class="kw">struct</span> RTCBounds** bounds,
  <span class="dt">unsigned</span> <span class="dt">int</span> childCount,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">void</span>* (*RTCCreateLeafFunction) (
  RTCThreadLocalAllocator allocator,
  <span class="dt">const</span> <span class="kw">struct</span> RTCBuildPrimitive* primitives,
  size_t primitiveCount,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">void</span> (*RTCSplitPrimitiveFunction) (
  <span class="dt">const</span> <span class="kw">struct</span> RTCBuildPrimitive* primitive,
  <span class="dt">unsigned</span> <span class="dt">int</span> dimension,
  <span class="dt">float</span> position,
  <span class="kw">struct</span> RTCBounds* leftBounds,
  <span class="kw">struct</span> RTCBounds* rightBounds,
  <span class="dt">void</span>* userPtr
);

<span class="kw">typedef</span> <span class="dt">bool</span> (*RTCProgressMonitorFunction)(
  <span class="dt">void</span>* userPtr, <span class="dt">double</span> n
);

<span class="kw">enum</span> RTCBuildFlags
{
  RTC_BUILD_FLAG_NONE,
  RTC_BUILD_FLAG_DYNAMIC
};

<span class="kw">struct</span> RTCBuildArguments
{
  size_t byteSize;

  <span class="kw">enum</span> RTCBuildQuality buildQuality;
  <span class="kw">enum</span> RTCBuildFlags buildFlags;
  <span class="dt">unsigned</span> <span class="dt">int</span> maxBranchingFactor;
  <span class="dt">unsigned</span> <span class="dt">int</span> maxDepth;
  <span class="dt">unsigned</span> <span class="dt">int</span> sahBlockSize;
  <span class="dt">unsigned</span> <span class="dt">int</span> minLeafSize;
  <span class="dt">unsigned</span> <span class="dt">int</span> maxLeafSize;
  <span class="dt">float</span> traversalCost;
  <span class="dt">float</span> intersectionCost;

  RTCBVH bvh;
  <span class="kw">struct</span> RTCBuildPrimitive* primitives;
  size_t primitiveCount;
  size_t primitiveArrayCapacity;
  
  RTCCreateNodeFunction createNode;
  RTCSetNodeChildrenFunction setNodeChildren;
  RTCSetNodeBoundsFunction setNodeBounds;
  RTCCreateLeafFunction createLeaf;
  RTCSplitPrimitiveFunction splitPrimitive;
  RTCProgressMonitorFunction buildProgress;
  <span class="dt">void</span>* userPtr;
};

<span class="kw">struct</span> RTCBuildArguments rtcDefaultBuildArguments();

<span class="dt">void</span>* rtcBuildBVH(
  <span class="dt">const</span> <span class="kw">struct</span> RTCBuildArguments* args
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcBuildBVH</code> function can be used to build a BVH in a user-defined format over arbitrary primitives. All arguments to the function are provided through the <code>RTCBuildArguments</code> structure. The first member of that structure must be set to the size of the structure in bytes (<code>bytesSize</code> member) which allows future extensions of the structure. It is recommended to initialize the build arguments structure using the <code>rtcDefaultBuildArguments</code> function.</p>
<p>The <code>rtcBuildBVH</code> function gets passed the BVH to build (<code>bvh</code> member), the array of primitives (<code>primitives</code> member), the capacity of that array (<code>primitiveArrayCapacity</code> member), the number of primitives stored inside the array (<code>primitiveCount</code> member), callback function pointers, and a user-defined pointer (<code>userPtr</code> member) that is passed to all callback functions when invoked. The <code>primitives</code> array can be freed by the application after the BVH is built. All callback functions are typically called from multiple threads, thus their implementation must be thread-safe.</p>
<p>Four callback functions must be registered, which are invoked during build to create BVH nodes (<code>createNode</code> member), to set the pointers to all children (<code>setNodeChildren</code> member), to set the bounding boxes of all children (<code>setNodeBounds</code> member), and to create a leaf node (<code>createLeaf</code> member).</p>
<p>The function pointer to the primitive split function (<code>splitPrimitive</code> member) may be <code>NULL</code>, however, then no spatial splitting in high quality mode is possible. The function pointer used to report the build progress (<code>buildProgress</code> member) is optional and may also be <code>NULL</code>.</p>
<p>Further, some build settings are passed to configure the BVH build. Using the build quality settings (<code>buildQuality</code> member), one can select between a faster, low quality build which is good for dynamic scenes, and a standard quality build for static scenes. One can also specify the desired maximum branching factor of the BVH (<code>maxBranchingFactor</code> member), the maximum depth the BVH should have (<code>maxDepth</code> member), the block size for the SAH heuristic (<code>sahBlockSize</code> member), the minimum and maximum leaf size (<code>minLeafSize</code> and <code>maxLeafSize</code> member), and the estimated costs of one traversal step and one primitive intersection (<code>traversalCost</code> and <code>intersectionCost</code> members). When enabling the <code>RTC_BUILD_FLAG_DYNAMIC</code> build flags (<code>buildFlags</code> member), re-build performance for dynamic scenes is improved at the cost of higher memory requirements.</p>
<p>To spatially split primitives in high quality mode, the builder needs extra space at the end of the build primitive array to store splitted primitives. The total capacity of the build primitive array is passed using the <code>primitiveArrayCapacity</code> member, and should be about twice the number of primitives when using spatial splits.</p>
<p>The <code>RTCCreateNodeFunc</code> and <code>RTCCreateLeafFunc</code> callbacks are passed a thread local allocator object that should be used for fast allocation of nodes using the <code>rtcThreadLocalAlloc</code> function. We strongly recommend using this allocation mechanism, as alternative approaches like standard <code>malloc</code> can be over 10× slower. The allocator object passed to the create callbacks may be used only inside the current thread. Memory allocated using <code>rtcThreadLocalAlloc</code> is automatically freed when the <code>RTCBVH</code> object is deleted. If you use your own memory allocation scheme you have to free the memory yourself when the <code>RTCBVH</code> object is no longer used.</p>
<p>The <code>RTCCreateNodeFunc</code> callback additionally gets the number of children for this node in the range from 2 to <code>maxBranchingFactor</code> (<code>childCount</code> argument).</p>
<p>The <code>RTCSetNodeChildFunc</code> callback function gets a pointer to the node as input (<code>nodePtr</code> argument), an array of pointers to the children (<code>childPtrs</code> argument), and the size of this array (<code>childCount</code> argument).</p>
<p>The <code>RTCSetNodeBoundsFunc</code> callback function gets a pointer to the node as input (<code>nodePtr</code> argument), an array of pointers to the bounding boxes of the children (<code>bounds</code> argument), and the size of this array (<code>childCount</code> argument).</p>
<p>The <code>RTCCreateLeafFunc</code> callback additionally gets an array of primitives as input (<code>primitives</code> argument), and the size of this array (<code>primitiveCount</code> argument). The callback should read the <code>geomID</code> and <code>primID</code> members from the passed primitives to construct the leaf.</p>
<p>The <code>RTCSplitPrimitiveFunc</code> callback is invoked in high quality mode to split a primitive (<code>primitive</code> argument) at the specified position (<code>position</code> argument) and dimension (<code>dimension</code> argument). The callback should return bounds of the clipped left and right parts of the primitive (<code>leftBounds</code> and <code>rightBounds</code> arguments).</p>
<p>The <code>RTCProgressMonitorFunction</code> callback function is called with the estimated completion rate <code>n</code> in the range <span class="math inline">[0, 1]</span>. Returning <code>true</code> from the callback lets the build continue; returning <code>false</code> cancels the build.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>On failure an error code is set that can be queried using <code>rtcGetDeviceError</code>.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcnewbvh">rtcNewBVH</a></p>
<p></p>
<h2 id="rtcquaterniondecomposition">RTCQuaternionDecomposition</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RTCQuaternionDecomposition - structure that represents a quaternion
  decomposition of an affine transformation</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> RTCQuaternionDecomposition
{
  <span class="dt">float</span> scale_x, scale_y, scale_z;
  <span class="dt">float</span> skew_xy, skew_xz, skew_yz;
  <span class="dt">float</span> shift_x, shift_y, shift_z;
  <span class="dt">float</span> quaternion_r, quaternion_i, quaternion_j, quaternion_k;
  <span class="dt">float</span> translation_x, translation_y, translation_z;
};</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The struct <code>RTCQuaternionDecomposition</code> represents an affine transformation decomposed into three parts. An upper triangular scaling/skew/shift matrix</p>
<p><br /><span class="math display">$$
S = \left( \begin{array}{cccc}
scale_x &amp; skew_{xy} &amp; skew_{xz} &amp; shift_x \\ 
0 &amp; scale_y &amp; skew_{yz} &amp; shift_y \\ 
0 &amp; 0 &amp; scale_z &amp; shift_z \\ 
0 &amp; 0 &amp; 0 &amp; 1 \\ 
\end{array} \right),
$$</span><br /></p>
<p>a translation matrix</p>
<p><br /><span class="math display">$$
T = \left( \begin{array}{cccc}
1 &amp; 0 &amp; 0 &amp; translation_x \\ 
0 &amp; 1 &amp; 0 &amp; translation_y \\ 
0 &amp; 0 &amp; 1 &amp; translation_z \\ 
0 &amp; 0 &amp; 0 &amp; 1 \\ 
\end{array} \right),
$$</span><br /></p>
<p>and a rotation matrix <span class="math inline"><em>R</em></span>, represented as a quaternion</p>
<p><span class="math inline"><em>q</em><em>u</em><em>a</em><em>t</em><em>e</em><em>r</em><em>n</em><em>i</em><em>o</em><em>n</em><sub><em>r</em></sub> + <em>q</em><em>u</em><em>a</em><em>t</em><em>e</em><em>r</em><em>n</em><em>i</em><em>o</em><em>n</em><sub><em>i</em></sub> <strong>i</strong> + <em>q</em><em>u</em><em>a</em><em>t</em><em>e</em><em>r</em><em>n</em><em>i</em><em>o</em><em>n</em><sub><em>j</em></sub> <strong>i</strong> + <em>q</em><em>u</em><em>a</em><em>t</em><em>e</em><em>r</em><em>n</em><em>i</em><em>o</em><em>n</em><sub><em>k</em></sub> <strong>k</strong></span></p>
<p>where <span class="math inline"><strong>i</strong></span>, <span class="math inline"><strong>j</strong></span> <span class="math inline"><strong>k</strong></span> are the imaginary quaternion units. The passed quaternion will be normalized internally.</p>
<p>The affine transformation matrix corresponding to a <code>RTCQuaternionDecomposition</code> is <span class="math inline"><em>T</em><em>R</em><em>S</em></span> and a point <span class="math inline"><em>p</em> = (<em>p</em><sub><em>x</em></sub>, <em>p</em><sub><em>y</em></sub>, <em>p</em><sub><em>z</em></sub>, 1)<sup><em>T</em></sup></span> will be transformed as <br /><span class="math display"><em>p</em>′=<em>T</em> <em>R</em> <em>S</em> <em>p</em>.</span><br /></p>
<p>The functions <code>rtcInitQuaternionDecomposition</code>, <code>rtcQuaternionDecompositionSetQuaternion</code>, <code>rtcQuaternionDecompositionSetScale</code>, <code>rtcQuaternionDecompositionSetSkew</code>, <code>rtcQuaternionDecompositionSetShift</code>, and <code>rtcQuaternionDecompositionSetTranslation</code> allow to set the fields of the structure more conveniently.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>No error code is set by this function.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrytransformquaternion">rtcSetGeometryTransformQuaternion</a>, <a href="#rtcinitquaterniondecomposition">rtcInitQuaternionDecomposition</a></p>
<p></p>
<h2 id="rtcinitquaterniondecomposition">rtcInitQuaternionDecomposition</h2>
<h4 id="name">NAME</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInitQuaternionDecomposition - initializes quaternion decomposition</code></pre></div>
<h4 id="synopsis">SYNOPSIS</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcInitQuaternionDecomposition(
  <span class="kw">struct</span> RTCQuaternionDecomposition* qd
);</code></pre></div>
<h4 id="description">DESCRIPTION</h4>
<p>The <code>rtcInitQuaternionDecomposition</code> function initializes a <code>RTCQuaternionDecomposition</code> structure to represent an identity transformation.</p>
<h4 id="exit-status">EXIT STATUS</h4>
<p>No error code is set by this function.</p>
<h4 id="see-also">SEE ALSO</h4>
<p><a href="#rtcsetgeometrytransformquaternion">rtcSetGeometryTransformQuaternion</a>, <a href="#rtcquaterniondecomposition">RTCQuaternionDecomposition</a></p>
<p></p>
<h1 id="performance-recommendations">Performance Recommendations</h1>
<h2 id="mxcsr-control-and-status-register">MXCSR control and status register</h2>
<p>It is strongly recommended to have the <code>Flush to Zero</code> and <code>Denormals are Zero</code> mode of the MXCSR control and status register enabled for each thread before calling the <code>rtcIntersect</code>-type and <code>rtcOccluded</code>-type functions. Otherwise, under some circumstances special handling of denormalized floating point numbers can significantly reduce application and Embree performance. When using Embree together with the Intel® Threading Building Blocks, it is sufficient to execute the following code at the beginning of the application main thread (before the creation of the <code>tbb::task_scheduler_init</code> object):</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;xmmintrin.h&gt;</span>
<span class="ot">#include &lt;pmmintrin.h&gt;</span>
...
_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
_MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);</code></pre></div>
<p>If using a different tasking system, make sure each rendering thread has the proper mode set.</p>
<h2 id="thread-creation-and-affinity-settings">Thread Creation and Affinity Settings</h2>
<p>Tasking systems like TBB create worker threads on demand, which will add a runtime overhead for the very first <code>rtcCommitScene</code> call. In case you want to benchmark the scene build time, you should start the threads at application startup. You can let Embree start TBB threads by passing <code>start_threads=1</code> to the <code>cfg</code> parameter of <code>rtcNewDevice</code>.</p>
<p>On machines with a high thread count (e.g. dual-socket Xeon or Xeon Phi machines), affinitizing TBB worker threads increases build and rendering performance. You can let Embree affinitize TBB worker threads by passing <code>set_affinity=1</code> to the <code>cfg</code> parameter of <code>rtcNewDevice</code>. By default, threads are not affinitized by Embree with the exception of Xeon Phi Processors where they are affinitized by default.</p>
<p>All Embree tutorials automatically start and affinitize TBB worker threads by passing <code>start_threads=1,set_affinity=1</code> to <code>rtcNewDevice</code>.</p>
<h2 id="fast-coherent-rays">Fast Coherent Rays</h2>
<p>For getting the highest performance for highly coherent rays, e.g. primary or hard shadow rays, it is recommended to use packets or streams of single rays/packets with setting the <code>RTC_INTERSECT_CONTEXT_FLAG_COHERENT</code> flag in the <code>RTCIntersectContext</code> passed to the <code>rtcIntersect</code>/<code>rtcOccluded</code> calls. The total number of rays in a coherent stream of ray packets should be around 64, e.g. 8 times 8-wide packets, or 4 times 16-wide packets. The rays inside each packet should be grouped as coherent as possible.</p>
<h2 id="huge-page-support">Huge Page Support</h2>
<p>It is recommended to use huge pages under Linux to increase rendering performance. Embree supports 2MB huge pages under Windows, Linux, and macOS. Under Linux huge page support is enabled by default, and under Windows and macOS disabled by default. Huge page support can be enabled in Embree by passing <code>hugepages=1</code> to <code>rtcNewDevice</code> or disabled by passing <code>hugepages=0</code> to <code>rtcNewDevice</code>.</p>
<p>We recommend using 2MB huge pages with Embree under Linux as this improves ray tracing performance by about 5-10%. Under Windows using huge pages requires the application to run in elevated mode which is a security issue, thus likely not an option for most use cases. Under macOS huge pages are rarely available as memory tends to get quickly fragmented, thus we do not recommend using huge pages on macOS.</p>
<h3 id="huge-pages-under-linux">Huge Pages under Linux</h3>
<p>Linux supports transparent huge pages and explicit huge pages. To enable transparent huge page support under Linux, execute the following as root:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">echo always &gt; /sys/kernel/mm/transparent_hugepage/enabled</code></pre></div>
<p>When transparent huge pages are enabled, the kernel tries to merge 4KB pages to 2MB pages when possible as a background job. Many Linux distributions have transparent huge pages enabled by default. See the following webpage for more information on <a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt">transparent huge pages under Linux</a>. In this mode each application, including your rendering application based on Embree, will automatically tend to use huge pages.</p>
<p>Using transparent huge pages, the transitioning from 4KB to 2MB pages might take some time. For that reason Embree also supports allocating 2MB pages directly when a huge page pool is configured. Such a pool can be configured by writing some number of huge pages to allocate to <code>/proc/sys/vm/nr_overcommit_hugepages</code> as root user. E.g. to configure 2GB of address space for huge page allocation, execute the following as root:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">echo <span class="dv">1000</span> &gt; /proc/sys/vm/nr_overcommit_hugepages</code></pre></div>
<p>See the following webpage for more information on <a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">huge pages under Linux</a>.</p>
<h3 id="huge-pages-under-windows">Huge Pages under Windows</h3>
<p>To use huge pages under Windows, the current user must have the &quot;Lock pages in memory&quot; (SeLockMemoryPrivilege) assigned. This can be configured through the &quot;Local Security Policy&quot; application, by adding a user to &quot;Local Policies&quot; -&gt; &quot;User Rights Assignment&quot; -&gt; &quot;Lock pages in memory&quot;. You have to log out and in again for this change to take effect.</p>
<p>Further, your application must be executed as an elevated process (&quot;Run as administrator&quot;) and the &quot;SeLockMemoryPrivilege&quot; must be explicitly enabled by your application. Example code on how to enable this privilege can be found in the &quot;common/sys/alloc.cpp&quot; file of Embree. Alternatively, Embree will try to enable this privilege when passing <code>enable_selockmemoryprivilege=1</code> to <code>rtcNewDevice</code>. Further, huge pages should be enabled in Embree by passing <code>hugepages=1</code> to <code>rtcNewDevice</code>.</p>
<p>When the system has been running for a while, physical memory gets fragmented, which can slow down the allocation of huge pages significantly under Windows.</p>
<h3 id="huge-pages-under-macos">Huge Pages under macOS</h3>
<p>To use huge pages under macOS you have to pass <code>hugepages=1</code> to <code>rtcNewDevice</code> to enable that feature in Embree.</p>
<p>When the system has been running for a while, physical memory gets quickly fragmented, and causes huge page allocations to fail. For this reason, huge pages are not very useful under macOS in practice.</p>
<h2 id="avoid-store-to-load-forwarding-issues-with-single-rays">Avoid store-to-load forwarding issues with single rays</h2>
<p>We recommend to use a single SSE store to set up the <code>org</code> and <code>tnear</code> components, and a single SSE store to set up the <code>dir</code> and <code>time</code> components of a single ray (<code>RTCRay</code> type). Storing these values using scalar stores causes a store-to-load forwarding penalty because Embree is reading these components using SSE loads later on.</p>
      </div>

      <div id="footer">
        © 2009–2020 Intel Corporation <a href="legal.html">Disclaimer and Legal Information</a>
        <a href="https://www.intel.com/privacy">Privacy</a>
      </div>
    </div>
  </body>
</html>
